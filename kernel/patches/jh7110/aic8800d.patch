diff --git a/drivers/net/wireless/aic8800/.gitignore b/drivers/net/wireless/aic8800/.gitignore
new file mode 100644
index 000000000000..55bf95cf9dbf
--- /dev/null
+++ b/drivers/net/wireless/aic8800/.gitignore
@@ -0,0 +1,5 @@
+*.symvers
+*.order
+*.symvers.cmd
+*.order.cmd
+.tmp_versions/
diff --git a/drivers/net/wireless/aic8800/Kconfig b/drivers/net/wireless/aic8800/Kconfig
old mode 100755
new mode 100644
diff --git a/drivers/net/wireless/aic8800/Makefile b/drivers/net/wireless/aic8800/Makefile
old mode 100755
new mode 100644
index 3d06d677af5e..509f64291add
--- a/drivers/net/wireless/aic8800/Makefile
+++ b/drivers/net/wireless/aic8800/Makefile
@@ -1,54 +1,63 @@
 CONFIG_AIC_LOADFW_SUPPORT := m
 CONFIG_AIC8800_WLAN_SUPPORT := m
 
-
 obj-$(CONFIG_AIC_LOADFW_SUPPORT)    += aic_load_fw/
 obj-$(CONFIG_AIC8800_WLAN_SUPPORT) += aic8800_fdrv/
 
+########## config option ##########
+export CONFIG_USE_FW_REQUEST = n
+export CONFIG_PREALLOC_RX_SKB = y
+export CONFIG_PREALLOC_TXQ = y
+###################################
 
-# Platform support list
-CONFIG_PLATFORM_ROCKCHIP ?= n
-CONFIG_PLATFORM_ALLWINNER ?= n
-CONFIG_PLATFORM_AMLOGIC ?= n
-CONFIG_PLATFORM_UBUNTU ?= y
+########## platform support list ##########
+export CONFIG_PLATFORM_ROCKCHIP = n
+export CONFIG_PLATFORM_ALLWINNER = n
+export CONFIG_PLATFORM_AMLOGIC = n
+export CONFIG_PLATFORM_HI = n
+export CONFIG_PLATFORM_UBUNTU = y
 
 ifeq ($(CONFIG_PLATFORM_ROCKCHIP), y)
-#KDIR := /home/yaya/E/Rockchip/3229/Android7/RK3229_ANDROID7.1_v1.01_20170914/rk3229_Android7.1_v1.01_xml0914/kernel
-#ARCH ?= arm
-#CROSS_COMPILE ?= /home/yaya/E/Rockchip/3229/Android7/RK3229_ANDROID7.1_v1.01_20170914/rk3229_Android7.1_v1.01_xml0914/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin/arm-eabi-
-KDIR  := /home/yaya/E/Rockchip/3229/Android9/rk3229_android9.0_box/kernel
-ARCH ?= arm
-CROSS_COMPILE ?= /home/yaya/E/Rockchip/3229/Android9/rk3229_android9.0_box/prebuilts/gcc/linux-x86/arm/gcc-linaro-6.3.1-2017.05-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-
-#KDIR  := /home/yaya/E/Rockchip/3399/rk3399-android-10/kernel
-#ARCH ?= arm64
-#CROSS_COMPILE ?= /home/yaya/E/Rockchip/3399/rk3399-android-10/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-
+ARCH = arm64
+KDIR = /home/yaya/E/Rockchip/3566/firefly/Android11.0/Firefly-RK356X_Android11.0_git_20210824/RK356X_Android11.0/kernel
+CROSS_COMPILE = /home/yaya/E/Rockchip/3566/firefly/Android11.0/Firefly-RK356X_Android11.0_git_20210824/RK356X_Android11.0/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-
 ccflags-y += -DANDROID_PLATFORM
 endif
 
 ifeq ($(CONFIG_PLATFORM_ALLWINNER), y)
-KDIR  := /home/yaya/E/Allwinner/R818/R818/AndroidQ/lichee/kernel/linux-4.9
-ARCH ?= arm64
-CROSS_COMPILE ?= /home/yaya/E/Allwinner/R818/R818/AndroidQ/lichee/out/gcc-linaro-5.3.1-2016.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-
+KDIR  = /home/yaya/E/Allwinner/R818/R818/AndroidQ/lichee/kernel/linux-4.9
+ARCH = arm64
+CROSS_COMPILE = /home/yaya/E/Allwinner/R818/R818/AndroidQ/lichee/out/gcc-linaro-5.3.1-2016.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-
 ccflags-y += -DANDROID_PLATFORM
 endif
 
 ifeq ($(CONFIG_PLATFORM_AMLOGIC), y)
 ccflags-y += -DANDROID_PLATFORM
-ARCH := arm
-CROSS_COMPILE := /home/yaya/D/Workspace/CyberQuantum/JinHaoYue/amls905x3/SDK/20191101-0tt-asop/android9.0/prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.9/bin/arm-linux-androidkernel-
-KDIR := /home/yaya/D/Workspace/CyberQuantum/JinHaoYue/amls905x3/SDK/20191101-0tt-asop/android9.0/out/target/product/u202/obj/KERNEL_OBJ/
+ARCH = arm
+CROSS_COMPILE = /home/yaya/D/Workspace/CyberQuantum/JinHaoYue/amls905x3/SDK/20191101-0tt-asop/android9.0/prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.9/bin/arm-linux-androidkernel-
+KDIR = /home/yaya/D/Workspace/CyberQuantum/JinHaoYue/amls905x3/SDK/20191101-0tt-asop/android9.0/out/target/product/u202/obj/KERNEL_OBJ/
+endif
 
+ifeq ($(CONFIG_PLATFORM_HI), y)
+ccflags-y += -DANDROID_PLATFORM
+ARCH = arm
+CROSS_COMPILE = /home/yaya/D/Workspace/CyberQuantum/JinHaoYue/amls905x3/SDK/20191101-0tt-asop/android9.0/prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.9/bin/arm-linux-androidkernel-
+KDIR = /home/yaya/D/Workspace/CyberQuantum/JinHaoYue/amls905x3/SDK/20191101-0tt-asop/android9.0/out/target/product/u202/obj/KERNEL_OBJ/
 endif
 
 ifeq ($(CONFIG_PLATFORM_UBUNTU), y)
-KDIR  := /lib/modules/$(shell uname -r)/build
-PWD   := $(shell pwd)
-KVER := $(shell uname -r)
-MODDESTDIR := /lib/modules/$(KVER)/kernel/drivers/net/wireless/aic8800
-ARCH ?= x86_64
+KDIR  = /lib/modules/$(shell uname -r)/build
+PWD   = $(shell pwd)
+KVER = $(shell uname -r)
+MODDESTDIR = /lib/modules/$(KVER)/kernel/drivers/net/wireless/aic8800
+SUBARCH = $(shell uname -m | sed -e s/i.86/i386/ -e s/armv.l/arm/ -e s/aarch64/arm64/)
+ARCH ?= $(SUBARCH)
 CROSS_COMPILE ?=
 endif
 
+###########################################
+
+MAKEFLAGS +=-j$(shell nproc)
 
 all: modules
 modules:
@@ -68,4 +77,4 @@ uninstall:
 clean:
 	cd aic_load_fw/;make clean;cd ..
 	cd aic8800_fdrv/;make clean;cd ..
-	rm -rf modules.order Module.symvers .tmp_versions/
+	rm -rf modules.order Module.symvers .modules.order.cmd .Module.symvers.cmd .tmp_versions/
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/.gitignore b/drivers/net/wireless/aic8800/aic8800_fdrv/.gitignore
new file mode 100644
index 000000000000..c3c2d151e157
--- /dev/null
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/.gitignore
@@ -0,0 +1,10 @@
+*.o
+*.ko
+*.order
+*.symvers
+*.o.d
+*.o.cmd
+*.ko.cmd
+*.mod
+*.mod.c
+*.mod.cmd
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/Makefile b/drivers/net/wireless/aic8800/aic8800_fdrv/Makefile
index 28643107cd27..d0970cbd3d5e 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/Makefile
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/Makefile
@@ -1,5 +1,6 @@
-#EXTRA_CFLAGS += $(USER_EXTRA_CFLAGS)
-#EXTRA_CFLAGS += -Wno-implicit-fallthrough
+EXTRA_CFLAGS += $(USER_EXTRA_CFLAGS)
+EXTRA_CFLAGS += -Wno-implicit-fallthrough
+#EXTRA_CFLAGS += -Wno-unused-variable
 
 RWNX_VERS_NUM := 6.4.3.0
 
@@ -58,28 +59,29 @@ CONFIG_RWNX_BFMER ?= n
 
 CONFIG_SDIO_SUPPORT =n
 CONFIG_USB_SUPPORT =y
-CONFIG_RX_REORDER ?=y
+CONFIG_RX_REORDER =y
 CONFIG_ARP_OFFLOAD =y
-CONFIG_USE_5G ?= n
+CONFIG_USE_5G = y
 CONFIG_RADAR_OR_IR_DETECT =n
 CONFIG_DOWNLOAD_FW =n
 CONFIG_RFTEST=y
 CONFIG_USB_BT=y
 CONFIG_MAC_RANDOM_IF_NO_MAC_IN_EFUSE = y
-CONFIG_WPA3_FOR_OLD_KERNEL ?= n
-CONFIG_HE_FOR_OLD_KERNEL ?= n
-CONFIG_VHT_FOR_OLD_KERNEL ?= n
+CONFIG_WPA3_FOR_OLD_KERNEL = n
+CONFIG_HE_FOR_OLD_KERNEL = n
+CONFIG_VHT_FOR_OLD_KERNEL = n
 # CONFIG_COEX = n for BT_ONLY, CONFIG_COEX =y for combo and sw
 CONFIG_COEX = y
-CONFIG_ALIGN_8BYTES = n
-CONFIG_TXRX_THREAD_PRIO = n
-CONFIG_USB_ALIGN_DATA = n
+CONFIG_ALIGN_8BYTES = y
+CONFIG_TXRX_THREAD_PRIO = y
+CONFIG_USB_ALIGN_DATA = y
 CONFIG_RX_TASKLET = n
 CONFIG_TX_TASKLET = n
 CONFIG_RX_NETIF_RECV_SKB = y
 CONFIG_BR_SUPPORT = n
 CONFIG_USB_MSG_OUT_EP = y
 CONFIG_USB_MSG_IN_EP = y
+CONFIG_USB_RX_REASSEMBLE = n
 
 #DCDW support tx aggr, D80 support both
 CONFIG_USB_RX_AGGR = n
@@ -98,16 +100,34 @@ CONFIG_FWLOG_EN = n
 CONFIG_FOR_IPCAM = n
 CONFIG_5M10M = n
 # Need to set fw path in BOARD_KERNEL_CMDLINE
-CONFIG_USE_FW_REQUEST = n
+CONFIG_USE_FW_REQUEST ?= n
 CONFIG_USE_P2P0 = n
 CONFIG_ONE_TXQ = n
 CONFIG_PER_STA_FC = n
-CONFIG_PREALLOC_RX_SKB = n
-CONFIG_PREALLOC_TXQ = n
-CONFIG_USE_WIRELESS_EXT = n
-CONFIG_DPD = n
+CONFIG_PREALLOC_RX_SKB ?= n
+CONFIG_PREALLOC_TXQ ?= y
+CONFIG_USE_WIRELESS_EXT = y
+CONFIG_DPD = y
+CONFIG_FORCE_DPD_CALIB = y
+CONFIG_LOFT_CALIB = n
 CONFIG_GKI = n
 CONFIG_SCHED_SCAN = n
+CONFIG_TEMP_COMP = n
+CONFIG_POWER_LIMIT = n
+CONFIG_EXT_FEM_8800DCDW = n
+# CONFIG_MCC = n for sta and p2p concurrent in same channel.
+CONFIG_MCC = y
+CONFIG_LOAD_BT_PATCH_IN_FDRV = n
+
+ifneq ($(CONFIG_WIRELESS_EXT), y)
+CONFIG_USE_WIRELESS_EXT = n
+endif
+
+ifeq ($(CONFIG_EXT_FEM_8800DCDW), y)
+CONFIG_DPD = n
+CONFIG_FORCE_DPD_CALIB = n
+CONFIG_LOFT_CALIB = y
+endif
 
 # Support of MU-MIMO transmission (need FW support)
 ifeq ($(CONFIG_RWNX_BFMER), y)
@@ -127,6 +147,8 @@ CONFIG_RWNX_MON_DATA =n
 CONFIG_RWNX_MON_XMIT ?= n
 CONFIG_RWNX_MON_RXFILTER ?= n
 
+CONFIG_FILTER_TCP_ACK =y
+
 # extra DEBUG config
 CONFIG_RWNX_SW_PROFILING ?= n
 CONFIG_RWNX_DBG ?= y
@@ -134,6 +156,7 @@ BR_NAME = br0
 
 obj-$(CONFIG_AIC8800_WLAN_SUPPORT) := $(MODULE_NAME).o
 $(MODULE_NAME)-y := \
+    rwnx_wakelock.o        \
 	rwnx_msg_tx.o          \
 	rwnx_msg_rx.o          \
 	rwnx_utils.o           \
@@ -156,8 +179,10 @@ $(MODULE_NAME)-y := \
 	regdb.o                \
 	md5.o                  \
 	aic_vendor.o           \
+        aic_priv_cmd.o         \
 	aicwf_compat_8800dc.o  \
-	aicwf_compat_8800d80.o  \
+	aicwf_compat_8800d80.o \
+	aicwf_compat_8800d80x2.o
 
 $(MODULE_NAME)-$(CONFIG_BR_SUPPORT)       += aic_br_ext.o
 $(MODULE_NAME)-$(CONFIG_RWNX_RADAR)       += rwnx_radar.o
@@ -169,6 +194,7 @@ $(MODULE_NAME)-$(CONFIG_RWNX_MUMIMO_TX)   += rwnx_mu_group.o
 $(MODULE_NAME)-$(CONFIG_SDIO_SUPPORT)     += sdio_host.o
 $(MODULE_NAME)-$(CONFIG_SDIO_SUPPORT)     += aicwf_txrxif.o
 $(MODULE_NAME)-$(CONFIG_SDIO_SUPPORT)     += aicwf_sdio.o
+$(MODULE_NAME)-$(CONFIG_FILTER_TCP_ACK)   += aicwf_tcp_ack.o
 
 $(MODULE_NAME)-$(CONFIG_USB_SUPPORT)     += usb_host.o
 $(MODULE_NAME)-$(CONFIG_USB_SUPPORT)     += aicwf_txrxif.o
@@ -223,7 +249,8 @@ ccflags-$(CONFIG_RWNX_DBG) += -DCONFIG_RWNX_DBG
 ccflags-$(CONFIG_RWNX_SW_PROFILING) += -DCONFIG_RWNX_SW_PROFILING
 ccflags-$(CONFIG_RWNX_MUMIMO_TX) += -DCONFIG_RWNX_MUMIMO_TX
 ccflags-$(CONFIG_RFTEST) += -DCONFIG_RFTEST
-
+ccflags-$(CONFIG_MCC) += -DCONFIG_MCC
+ccflags-$(CONFIG_LOAD_BT_PATCH_IN_FDRV) += -DCONFIG_LOAD_BT_PATCH_IN_FDRV
 
 ifeq ($(CONFIG_SDIO_SUPPORT), y)
 ccflags-y += -DAICWF_SDIO_SUPPORT
@@ -269,6 +296,7 @@ ccflags-y += -DDEFAULT_COUNTRY_CODE=""\$(CONFIG_COUNTRY_CODE)"\"
 ccflags-$(CONFIG_RX_NETIF_RECV_SKB) += -DCONFIG_RX_NETIF_RECV_SKB
 ccflags-$(CONFIG_USB_MSG_OUT_EP) += -DCONFIG_USB_MSG_OUT_EP
 ccflags-$(CONFIG_USB_MSG_IN_EP) += -DCONFIG_USB_MSG_IN_EP
+ccflags-$(CONFIG_USB_RX_REASSEMBLE) += -DCONFIG_USB_RX_REASSEMBLE
 ccflags-$(CONFIG_USB_RX_AGGR)  += -DCONFIG_USB_RX_AGGR
 ccflags-$(CONFIG_USB_TX_AGGR) += -DCONFIG_USB_TX_AGGR
 ccflags-$(CONFIG_USB_NO_TRANS_DMA_MAP) += -DCONFIG_USB_NO_TRANS_DMA_MAP
@@ -281,7 +309,7 @@ ccflags-$(CONFIG_STA_SCAN_WHEN_P2P_WORKING) += -DCONFIG_STA_SCAN_WHEN_P2P_WORKIN
 ccflags-$(CONFIG_SUPPORT_REALTIME_CHANGE_MAC) += -DCONFIG_SUPPORT_REALTIME_CHANGE_MAC
 ccflags-$(CONFIG_SET_VENDOR_EXTENSION_IE) += -DCONFIG_SET_VENDOR_EXTENSION_IE
 ccflags-$(CONFIG_FWLOG_EN) += -DCONFIG_FWLOG_EN
-ccflags-$(CONFIG_FOR_IPCAM) += -DCONFIG_FOR_IPCAM
+ccflags-$(CONFIG_FOR_IPCAM) += -DCONFIG_FOR_IPCAM -DCONFIG_ONE_TXQ
 ccflags-$(CONFIG_5M10M) += -DCONFIG_5M10M
 ccflags-$(CONFIG_USE_FW_REQUEST) += -DCONFIG_USE_FW_REQUEST
 ccflags-$(CONFIG_USE_P2P0) += -DCONFIG_USE_P2P0
@@ -291,40 +319,27 @@ ccflags-$(CONFIG_PREALLOC_RX_SKB) += -DCONFIG_PREALLOC_RX_SKB
 ccflags-$(CONFIG_PREALLOC_TXQ) += -DCONFIG_PREALLOC_TXQ
 ccflags-$(CONFIG_USE_WIRELESS_EXT) += -DCONFIG_USE_WIRELESS_EXT
 ccflags-$(CONFIG_DPD) += -DCONFIG_DPD
+ccflags-$(CONFIG_FORCE_DPD_CALIB) += -DCONFIG_FORCE_DPD_CALIB -DCONFIG_DPD
+ccflags-$(CONFIG_LOFT_CALIB) += -DCONFIG_LOFT_CALIB
 ccflags-$(CONFIG_GKI) += -DCONFIG_GKI
 ccflags-$(CONFIG_SCHED_SCAN) += -DCONFIG_SCHED_SCAN
+ccflags-$(CONFIG_FILTER_TCP_ACK) += -DCONFIG_FILTER_TCP_ACK
+ccflags-$(CONFIG_TEMP_COMP) += -DCONFIG_TEMP_COMP
+ccflags-$(CONFIG_POWER_LIMIT) += -DCONFIG_POWER_LIMIT
+ccflags-$(CONFIG_EXT_FEM_8800DCDW) += -DCONFIG_EXT_FEM_8800DCDW
+MAKEFLAGS +=-j$(shell nproc)
 
 # Platform support list
-CONFIG_PLATFORM_ROCKCHIP ?= y
+CONFIG_PLATFORM_ROCKCHIP ?= n
 CONFIG_PLATFORM_ALLWINNER ?= n
 CONFIG_PLATFORM_AMLOGIC ?= n
-CONFIG_PLATFORM_UBUNTU ?= n
+CONFIG_PLATFORM_HI ?= n
+CONFIG_PLATFORM_UBUNTU ?= y
 
 ifeq ($(CONFIG_PLATFORM_ROCKCHIP), y)
-#KDIR ?= /home/yaya/E/Rockchip/3288/Android5/kernel/
-#ARCH ?= arm
-#CROSS_COMPILE ?= /home/yaya/D/Workspace/CyberQuantum/JinHaoYue/rk3288/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin/arm-eabi-
-#KDIR ?= /home/yaya/E/Rockchip/3229/Android7/RK3229_ANDROID7.1_v1.01_20170914/rk3229_Android7.1_v1.01_xml0914/kernel
-#ARCH ?= arm
-#CROSS_COMPILE ?= /home/yaya/E/Rockchip/3229/Android7/RK3229_ANDROID7.1_v1.01_20170914/rk3229_Android7.1_v1.01_xml0914/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin/arm-eabi-
-#KDIR  ?= /home/yaya/E/Rockchip/3229/Android9/rk3229_android9.0_box/kernel
-#ARCH ?= arm
-#CROSS_COMPILE ?= /home/yaya/E/Rockchip/3229/Android9/rk3229_android9.0_box/prebuilts/gcc/linux-x86/arm/gcc-linaro-6.3.1-2017.05-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-
+ARCH := arm64
 KDIR ?= /home/yaya/E/Rockchip/3566/firefly/Android11.0/Firefly-RK356X_Android11.0_git_20210824/RK356X_Android11.0/kernel
-ARCH ?= arm64
-CROSS_COMPILE ?= /home/yaya/E/Rockchip/3566/Android11/rk3566_rk3568_android11_oranth/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-
-#ARCH ?= arm
-#CROSS_COMPILE ?=/home/yaya/D/Workspace/CyberQuantum/JinHaoYue/rk3288/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin/arm-eabi-
-#KDIR ?=/home/yaya/D/Workspace/CyberQuantum/JinHaoYue/rk3288/kernel
-#KDIR := /home/yaya/E/Rockchip/3566/Android/kernel
-#ARCH ?= arm64
-#CROSS_COMPILE ?= /home/yaya/E/Rockchip/3566/Android/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-
-#KDIR ?= /home/yaya/E/Rockchip/3566/Android11/rk3566_rk3568_android11_oranth/kernel
-#ARCH ?= arm64
-#CROSS_COMPILE ?= /home/yaya/E/Rockchip/3566/Android11/rk3566_rk3568_android11_oranth/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-
-#KDIR ?= /home/yaya/D/samba1/aiden/SDK/Rockchip/3588/Android12/RK3588_Android12.0/kernel-5.10
-#ARCH ?= arm64
-#CROSS_COMPILE ?= /home/yaya/D/samba1/aiden/SDK/Rockchip/3588/Android12/RK3588_Android12.0/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-
+CROSS_COMPILE := /home/yaya/E/Rockchip/3566/firefly/Android11.0/Firefly-RK356X_Android11.0_git_20210824/RK356X_Android11.0/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-
 ccflags-y += -DANDROID_PLATFORM
 ccflags-y += -DCONFIG_PLATFORM_ROCKCHIP
 endif
@@ -341,7 +356,14 @@ ccflags-y += -DANDROID_PLATFORM
 ARCH ?= arm
 CROSS_COMPILE ?= /home/yaya/D/Workspace/CyberQuantum/JinHaoYue/amls905x3/SDK/20191101-0tt-asop/android9.0/prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.9/bin/arm-linux-androidkernel-
 KDIR ?= /home/yaya/D/Workspace/CyberQuantum/JinHaoYue/amls905x3/SDK/20191101-0tt-asop/android9.0/out/target/product/u202/obj/KERNEL_OBJ/
+endif
 
+ifeq ($(CONFIG_PLATFORM_HI), y)
+ccflags-y += -DANDROID_PLATFORM
+ccflags-y += -DCONFIG_PLATFORM_HI
+ARCH ?= arm
+CROSS_COMPILE ?= /home/yaya/D/Workspace/CyberQuantum/JinHaoYue/amls905x3/SDK/20191101-0tt-asop/android9.0/prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.9/bin/arm-linux-androidkernel-
+KDIR ?= /home/yaya/D/Workspace/CyberQuantum/JinHaoYue/amls905x3/SDK/20191101-0tt-asop/android9.0/out/target/product/u202/obj/KERNEL_OBJ/
 endif
 
 ifeq ($(CONFIG_PLATFORM_UBUNTU), y)
@@ -350,7 +372,8 @@ KDIR  ?= /lib/modules/$(shell uname -r)/build
 PWD   ?= $(shell pwd)
 KVER ?= $(shell uname -r)
 MODDESTDIR ?= /lib/modules/$(KVER)/kernel/drivers/net/wireless/aic8800
-ARCH ?= x86_64
+SUBARCH = $(shell uname -m | sed -e s/i.86/i386/ -e s/armv.l/arm/ -e s/aarch64/arm64/)
+ARCH ?= $(SUBARCH)
 CROSS_COMPILE ?=
 endif
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aic_priv_cmd.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aic_priv_cmd.c
new file mode 100644
index 000000000000..2ff3561d25a1
--- /dev/null
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aic_priv_cmd.c
@@ -0,0 +1,1590 @@
+/**
+ ******************************************************************************
+ *
+ * @file aic_priv_cmd.c
+ *
+ * @brief Entry point of the AIC driver
+ *
+ * Copyright (C) Aicsemi 2018-2024
+ *
+ ******************************************************************************
+ */
+
+#include <linux/netdevice.h>
+#include <linux/ctype.h>
+#include "rwnx_defs.h"
+#include "rwnx_msg_tx.h"
+#include "rwnx_debugfs.h"
+#include "rwnx_main.h"
+#include "aic_priv_cmd.h"
+#include "aicwf_compat_8800dc.h"
+#include "aicwf_compat_8800d80.h"
+#include "aicwf_compat_8800d80x2.h"
+
+extern void set_testmode(int);
+extern int testmode;
+static void print_help(const char *cmd);
+struct dbg_rftest_cmd_cfm cfm = {{0,}};
+
+#ifdef CONFIG_RFTEST
+enum {
+	SET_TX,
+	SET_TXSTOP,
+	SET_TXTONE,
+	SET_RX,
+	GET_RX_RESULT,
+	SET_RXSTOP,
+	SET_RX_METER,
+	SET_POWER,
+	SET_XTAL_CAP,
+	SET_XTAL_CAP_FINE,
+	GET_EFUSE_BLOCK,
+	SET_FREQ_CAL,
+	SET_FREQ_CAL_FINE,
+	GET_FREQ_CAL,
+	SET_MAC_ADDR,
+	GET_MAC_ADDR,
+	SET_BT_MAC_ADDR,
+	GET_BT_MAC_ADDR,
+	SET_VENDOR_INFO,
+	GET_VENDOR_INFO,
+	RDWR_PWRMM,
+	RDWR_PWRIDX,
+	RDWR_PWRLVL = RDWR_PWRIDX,
+	RDWR_PWROFST,
+	RDWR_DRVIBIT,
+	RDWR_EFUSE_PWROFST,
+	RDWR_EFUSE_DRVIBIT,
+	SET_PAPR,
+	SET_CAL_XTAL,
+	GET_CAL_XTAL_RES,
+	SET_COB_CAL,
+	GET_COB_CAL_RES,
+	RDWR_EFUSE_USRDATA,
+	SET_NOTCH,
+	RDWR_PWROFSTFINE,
+	RDWR_EFUSE_PWROFSTFINE,
+	RDWR_EFUSE_SDIOCFG,
+	RDWR_EFUSE_USBVIDPID,
+	SET_SRRC,
+	SET_FSS,
+	RDWR_EFUSE_HE_OFF,
+	SET_USB_OFF,
+	SET_PLL_TEST,
+	SET_ANT_MODE,
+};
+
+typedef struct {
+	u8_l chan;
+	u8_l bw;
+	u8_l mode;
+	u8_l rate;
+	u16_l length;
+	u16_l tx_intv_us;
+	s8_l max_pwr;
+} cmd_rf_settx_t;
+
+typedef struct {
+	u8_l val;
+} cmd_rf_setfreq_t;
+
+typedef struct {
+	u8_l chan;
+	u8_l bw;
+} cmd_rf_rx_t;
+
+typedef struct {
+	u8_l block;
+} cmd_rf_getefuse_t;
+
+typedef struct {
+	u8_l dutid;
+	u8_l chip_num;
+	u8_l dis_xtal;
+} cmd_rf_setcobcal_t;
+
+typedef struct {
+	u16_l dut_rcv_golden_num;
+	u8_l golden_rcv_dut_num;
+	s8_l rssi_static;
+	s8_l snr_static;
+	s8_l dut_rssi_static;
+	u16_l reserved;
+} cob_result_ptr_t;
+#endif
+
+typedef struct
+{
+	u8_l func;
+	u8_l cnt;
+	u8_l reserved[2];
+	u32_l usrdata[3]; // 3 words totally
+} cmd_ef_usrdata_t;
+
+#define CMD_MAXARGS 30
+
+#if 0//#include <linux/ctype.h>
+#define isblank(c)		((c) == ' ' || (c) == '\t')
+#define isascii(c)		(((unsigned char)(c)) <= 0x7F)
+
+static int isdigit(unsigned char c)
+{
+	return ((c >= '0') && (c <='9'));
+}
+
+static int isxdigit(unsigned char c)
+{
+	if ((c >= '0') && (c <='9'))
+		return 1;
+	if ((c >= 'a') && (c <='f'))
+		return 1;
+	if ((c >= 'A') && (c <='F'))
+		return 1;
+	return 0;
+}
+
+static int islower(unsigned char c)
+{
+	return ((c >= 'a') && (c <='z'));
+}
+
+static unsigned char toupper(unsigned char c)
+{
+	if (islower(c))
+		c -= 'a'-'A';
+	return c;
+}
+#endif
+
+static int parse_line (char *line, char *argv[])
+{
+	int nargs = 0;
+
+	while (nargs < CMD_MAXARGS) {
+		/* skip any white space */
+		while ((*line == ' ') || (*line == '\t')) {
+			++line;
+		}
+
+		if (*line == '\0') {    /* end of line, no more args    */
+			argv[nargs] = 0;
+			return nargs;
+		}
+
+		/* Argument include space should be bracketed by quotation mark */
+		if (*line == '\"') {
+			/* Skip quotation mark */
+			line++;
+
+			/* Begin of argument string */
+			argv[nargs++] = line;
+
+			/* Until end of argument */
+			while (*line && (*line != '\"')) {
+				++line;
+			}
+		} else {
+			argv[nargs++] = line;    /* begin of argument string    */
+
+			/* find end of string */
+			while (*line && (*line != ' ') && (*line != '\t')) {
+				++line;
+			}
+		}
+
+		if (*line == '\0') {    /* end of line, no more args    */
+			argv[nargs] = 0;
+			return nargs;
+		}
+
+		*line++ = '\0';         /* terminate current arg     */
+	}
+
+	printk("** Too many args (max. %d) **\n", CMD_MAXARGS);
+
+	return nargs;
+}
+
+unsigned int command_strtoul(const char *cp, char **endp, unsigned int base)
+{
+	unsigned int result = 0, value, is_neg = 0;
+
+	if (*cp == '0') {
+		cp++;
+		if ((*cp == 'x') && isxdigit(cp[1])) {
+			base = 16;
+			cp++;
+		}
+		if (!base) {
+			base = 8;
+		}
+	}
+	if (!base) {
+		base = 10;
+	}
+	if (*cp == '-') {
+		is_neg = 1;
+		cp++;
+	}
+	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp - '0' : (islower(*cp) ? toupper(*cp) : *cp) - 'A' + 10) < base) {
+		result = result * base + value;
+		cp++;
+	}
+	if (is_neg)
+		result = (unsigned int)((int)result * (-1));
+
+	if (endp)
+		*endp = (char *)cp;
+	return result;
+}
+
+int str_starts(const char *str, const char *start)
+{
+	return strncmp(str, start, strlen(start)) == 0;
+}
+
+/*
+ * aic_priv_cmd handers.
+ */
+static int aic_priv_cmd_set_tx (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	cmd_rf_settx_t settx_param;
+
+	if (argc < 6)
+		return -EINVAL;
+
+	settx_param.chan = command_strtoul(argv[1], NULL, 10);
+	settx_param.bw = command_strtoul(argv[2], NULL, 10);
+	settx_param.mode = command_strtoul(argv[3], NULL, 10);
+	settx_param.rate = command_strtoul(argv[4], NULL, 10);
+	settx_param.length = command_strtoul(argv[5], NULL, 10);
+	if (argc > 6) {
+		settx_param.tx_intv_us = command_strtoul(argv[6], NULL, 10);
+	} else {
+		settx_param.tx_intv_us = 10000; // set default val 10ms
+	}
+	settx_param.max_pwr = POWER_LEVEL_INVALID_VAL;
+	AICWFDBG(LOGINFO, "txparam:%d,%d,%d,%d,%d,%d\n", settx_param.chan, settx_param.bw,
+		settx_param.mode, settx_param.rate, settx_param.length, settx_param.tx_intv_us);
+#ifdef CONFIG_POWER_LIMIT
+	settx_param.max_pwr = get_powerlimit_by_chnum(settx_param.chan);
+	AICWFDBG(LOGINFO, "max_pwr:%d\n", settx_param.max_pwr);
+#endif
+	rwnx_send_rftest_req(rwnx_hw, SET_TX, sizeof(cmd_rf_settx_t), (u8_l *)&settx_param, NULL);
+	return 0;
+}
+
+static int aic_priv_cmd_set_txstop (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	rwnx_send_rftest_req(rwnx_hw, SET_TXSTOP, 0, NULL, NULL);
+	return 0;
+}
+
+static int aic_priv_cmd_set_rx (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	cmd_rf_rx_t setrx_param;
+
+	if (argc < 3) {
+		return -EINVAL;
+	}
+	setrx_param.chan = command_strtoul(argv[1], NULL, 10);
+	setrx_param.bw = command_strtoul(argv[2], NULL, 10);
+	rwnx_send_rftest_req(rwnx_hw, SET_RX, sizeof(cmd_rf_rx_t), (u8_l *)&setrx_param, NULL);
+	return 0;
+}
+
+static int aic_priv_cmd_get_rx_result (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	rwnx_send_rftest_req(rwnx_hw, GET_RX_RESULT, 0, NULL, &cfm);
+	memcpy(command, &cfm.rftest_result[0], 8);
+	return 8;
+}
+
+static int aic_priv_cmd_set_rxstop (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	rwnx_send_rftest_req(rwnx_hw, SET_RXSTOP, 0, NULL, NULL);
+	return 0;
+}
+
+static int aic_priv_cmd_set_tx_tone (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+	u8_l buf[2];
+	s8_l freq_ = 0;
+
+	AICWFDBG(LOGINFO, "%s argc:%d\n", argv[0], argc);
+	if ((argc == 2) || (argc == 3)) {
+		AICWFDBG(LOGINFO, "argv 1:%s\n",argv[1]);
+		func = (u8_l)command_strtoul(argv[1], NULL, 16);
+		if (argc == 3) {
+			AICWFDBG(LOGINFO, "argv 2:%s\n",argv[2]);
+			freq_ = (u8_l)command_strtoul(argv[2], NULL, 10);
+		} else {
+			freq_ = 0;
+		};
+		buf[0] = func;
+		buf[1] = (u8_l)freq_;
+		rwnx_send_rftest_req(rwnx_hw, SET_TXTONE, argc - 1, buf, NULL);
+	} else {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int aic_priv_cmd_set_rx_meter (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	s8_l freq = 0;
+
+	freq = (int)command_strtoul(argv[1], NULL, 10);
+	rwnx_send_rftest_req(rwnx_hw, SET_RX_METER, sizeof(freq), (u8_l *)&freq, NULL);
+	return 0;
+}
+
+static int aic_priv_cmd_set_set_power (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l ana_pwr;
+	u8_l dig_pwr;
+	u8_l pwr;
+#ifdef AICWF_SDIO_SUPPORT
+	struct aic_sdio_dev *dev = g_rwnx_plat->sdiodev;
+#endif
+#ifdef AICWF_USB_SUPPORT
+	struct aic_usb_dev *dev = g_rwnx_plat->usbdev;
+#endif
+
+	if (dev->chipid == PRODUCT_ID_AIC8801) {
+		ana_pwr = command_strtoul(argv[1], NULL, 16);
+		dig_pwr = command_strtoul(argv[2], NULL, 16);
+		pwr = (ana_pwr << 4 | dig_pwr);
+		if (ana_pwr > 0xf || dig_pwr > 0xf)
+			return -EINVAL;
+	} else {
+		ana_pwr = command_strtoul(argv[1], NULL, 10);
+		pwr = ana_pwr;
+		if (ana_pwr > 0x1e)
+			return -EINVAL;
+	}
+	AICWFDBG(LOGINFO, "pwr =%x\r\n", pwr);
+	rwnx_send_rftest_req(rwnx_hw, SET_POWER, sizeof(pwr), (u8_l *)&pwr, NULL);
+	return 0;
+}
+
+static int aic_priv_cmd_set_xtal_cap (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l xtal_cap;
+
+	if (argc < 2)
+		return -EINVAL;
+
+	xtal_cap = command_strtoul(argv[1], NULL, 10);
+	AICWFDBG(LOGINFO, "xtal_cap =%x\r\n", xtal_cap);
+	rwnx_send_rftest_req(rwnx_hw, SET_XTAL_CAP, sizeof(xtal_cap), (u8_l *)&xtal_cap, &cfm);
+	memcpy(command, &cfm.rftest_result[0], 4);
+	return 4;
+}
+
+static int aic_priv_cmd_set_xtal_cap_fine (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l xtal_cap_fine;
+
+	if (argc < 2)
+		return -EINVAL;
+
+	xtal_cap_fine = command_strtoul(argv[1], NULL, 10);
+	AICWFDBG(LOGINFO, "xtal_cap_fine =%x\r\n", xtal_cap_fine);
+	rwnx_send_rftest_req(rwnx_hw, SET_XTAL_CAP_FINE, sizeof(xtal_cap_fine), (u8_l *)&xtal_cap_fine, &cfm);
+	memcpy(command, &cfm.rftest_result[0], 4);
+	return 4;
+}
+
+static int aic_priv_cmd_get_efuse_block (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	cmd_rf_getefuse_t getefuse_param;
+
+	if (argc < 2)
+		return -EINVAL;
+
+	getefuse_param.block = command_strtoul(argv[1], NULL, 10);
+	rwnx_send_rftest_req(rwnx_hw, GET_EFUSE_BLOCK, sizeof(cmd_rf_getefuse_t), (u8_l *)&getefuse_param, &cfm);
+	AICWFDBG(LOGINFO, "get val=%x\r\n", cfm.rftest_result[0]);
+	memcpy(command, &cfm.rftest_result[0], 4);
+	return 4;
+}
+
+static int aic_priv_cmd_set_freq_cal (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	cmd_rf_setfreq_t cmd_setfreq;
+
+	if (argc < 2)
+		return -EINVAL;
+
+	cmd_setfreq.val = command_strtoul(argv[1], NULL, 16);
+	AICWFDBG(LOGINFO, "param:%x\r\n", cmd_setfreq.val);
+	rwnx_send_rftest_req(rwnx_hw, SET_FREQ_CAL, sizeof(cmd_rf_setfreq_t), (u8_l *)&cmd_setfreq, &cfm);
+	memcpy(command, &cfm.rftest_result[0], 4);
+	return 4;
+}
+
+static int aic_priv_cmd_set_freq_cal_fine (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	cmd_rf_setfreq_t cmd_setfreq;
+
+	if (argc < 2)
+		return -EINVAL;
+
+	cmd_setfreq.val = command_strtoul(argv[1], NULL, 16);
+	AICWFDBG(LOGINFO, "param:%x\r\n", cmd_setfreq.val);
+	rwnx_send_rftest_req(rwnx_hw, SET_FREQ_CAL_FINE, sizeof(cmd_rf_setfreq_t), (u8_l *)&cmd_setfreq, &cfm);
+	memcpy(command, &cfm.rftest_result[0], 4);
+	return 4;
+}
+
+static int aic_priv_cmd_get_freq_cal (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l val;
+#ifdef AICWF_SDIO_SUPPORT
+	struct aic_sdio_dev *dev = g_rwnx_plat->sdiodev;
+#endif
+#ifdef AICWF_USB_SUPPORT
+	struct aic_usb_dev *dev = g_rwnx_plat->usbdev;
+#endif
+
+	rwnx_send_rftest_req(rwnx_hw, GET_FREQ_CAL, 0, NULL, &cfm);
+	memcpy(command, &cfm.rftest_result[0], 4);
+	val = cfm.rftest_result[0];
+	if (dev->chipid != PRODUCT_ID_AIC8801) {
+		AICWFDBG(LOGINFO, "cap=0x%x (remain:%x), cap_fine=%x (remain:%x)\n",
+				val & 0xff, (val >> 8) & 0xff, (val >> 16) & 0xff, (val >> 24) & 0xff);
+	} else {
+		AICWFDBG(LOGINFO, "cap=0x%x, cap_fine=0x%x\n", val & 0xff, (val >> 8) & 0xff);
+	}
+	return 4;
+}
+
+static int aic_priv_cmd_set_mac_addr (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l mac_addr[6];
+
+	if (argc < 7)
+		return -EINVAL;
+
+	mac_addr[5] = command_strtoul(argv[1], NULL, 16);
+	mac_addr[4] = command_strtoul(argv[2], NULL, 16);
+	mac_addr[3] = command_strtoul(argv[3], NULL, 16);
+	mac_addr[2] = command_strtoul(argv[4], NULL, 16);
+	mac_addr[1] = command_strtoul(argv[5], NULL, 16);
+	mac_addr[0] = command_strtoul(argv[6], NULL, 16);
+	AICWFDBG(LOGINFO, "set macaddr:%x,%x,%x,%x,%x,%x\n", mac_addr[5], mac_addr[4], mac_addr[3], mac_addr[2], mac_addr[1], mac_addr[0]);
+	rwnx_send_rftest_req(rwnx_hw, SET_MAC_ADDR, sizeof(mac_addr), (u8_l *)&mac_addr, NULL);
+	return 0;
+}
+
+static int aic_priv_cmd_get_mac_addr (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u32_l addr0, addr1;
+#ifdef AICWF_SDIO_SUPPORT
+	struct aic_sdio_dev *dev = g_rwnx_plat->sdiodev;
+#endif
+#ifdef AICWF_USB_SUPPORT
+	struct aic_usb_dev *dev = g_rwnx_plat->usbdev;
+#endif
+
+	rwnx_send_rftest_req(rwnx_hw, GET_MAC_ADDR, 0, NULL, &cfm);
+	memcpy(command, &cfm.rftest_result[0], 8);
+	addr0 = cfm.rftest_result[0];
+	if ((dev->chipid == PRODUCT_ID_AIC8800DC) || (dev->chipid == PRODUCT_ID_AIC8800DW)) {
+		int rem_cnt = (cfm.rftest_result[1] >> 16) & 0x00FF;
+		addr1 = cfm.rftest_result[1] & 0x0000FFFF;
+		AICWFDBG(LOGINFO, "0x%x,0x%x (remain:%x)\n", addr0, addr1, rem_cnt);
+	} else {
+		addr1 = cfm.rftest_result[1];
+		AICWFDBG(LOGINFO, "0x%x,0x%x\n", addr0, addr1);
+	}
+	return 8;
+}
+
+static int aic_priv_cmd_set_bt_mac_addr (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l mac_addr[6];
+
+	if (argc < 7)
+		return -EINVAL;
+
+	mac_addr[5] = command_strtoul(argv[1], NULL, 16);
+	mac_addr[4] = command_strtoul(argv[2], NULL, 16);
+	mac_addr[3] = command_strtoul(argv[3], NULL, 16);
+	mac_addr[2] = command_strtoul(argv[4], NULL, 16);
+	mac_addr[1] = command_strtoul(argv[5], NULL, 16);
+	mac_addr[0] = command_strtoul(argv[6], NULL, 16);
+	AICWFDBG(LOGINFO, "set bt macaddr:%x,%x,%x,%x,%x,%x\n", mac_addr[5], mac_addr[4], mac_addr[3], mac_addr[2], mac_addr[1], mac_addr[0]);
+	rwnx_send_rftest_req(rwnx_hw, SET_BT_MAC_ADDR, sizeof(mac_addr), (u8_l *)&mac_addr, NULL);
+	return 0;
+}
+
+static int aic_priv_cmd_get_bt_mac_addr (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u32_l addr0, addr1;
+#ifdef AICWF_SDIO_SUPPORT
+	struct aic_sdio_dev *dev = g_rwnx_plat->sdiodev;
+#endif
+#ifdef AICWF_USB_SUPPORT
+	struct aic_usb_dev *dev = g_rwnx_plat->usbdev;
+#endif
+
+	rwnx_send_rftest_req(rwnx_hw, GET_BT_MAC_ADDR, 0, NULL, &cfm);
+	memcpy(command, &cfm.rftest_result[0], 8);
+	addr0 = cfm.rftest_result[0];
+	if ((dev->chipid == PRODUCT_ID_AIC8800DC) || (dev->chipid == PRODUCT_ID_AIC8800DW)) {
+		int rem_cnt = (cfm.rftest_result[1] >> 16) & 0x00FF;
+		addr1 = cfm.rftest_result[1] & 0x0000FFFF;
+		AICWFDBG(LOGINFO, "0x%x,0x%x (remain:%x)\n", addr0, addr1, rem_cnt);
+	} else {
+		addr1 = cfm.rftest_result[1];
+		AICWFDBG(LOGINFO, "0x%x,0x%x\n", addr0, addr1);
+	}
+	return 8;
+}
+
+static int aic_priv_cmd_set_vendor_info (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l vendor_info;
+#ifdef AICWF_SDIO_SUPPORT
+	struct aic_sdio_dev *dev = g_rwnx_plat->sdiodev;
+#endif
+#ifdef AICWF_USB_SUPPORT
+	struct aic_usb_dev *dev = g_rwnx_plat->usbdev;
+#endif
+
+	vendor_info = command_strtoul(argv[1], NULL, 16);
+	AICWFDBG(LOGINFO, "set vendor info:%x\n", vendor_info);
+	rwnx_send_rftest_req(rwnx_hw, SET_VENDOR_INFO, 1, &vendor_info, &cfm);
+	if ((dev->chipid == PRODUCT_ID_AIC8800DC) || (dev->chipid == PRODUCT_ID_AIC8800DW)) {
+		memcpy(command, &cfm.rftest_result[0], 2);
+		return 2;
+	} else {
+		memcpy(command, &cfm.rftest_result[0], 1);
+		return 1;
+	}
+	AICWFDBG(LOGINFO, "0x%x\n", cfm.rftest_result[0]);
+}
+
+static int aic_priv_cmd_get_vendor_info (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+#ifdef AICWF_SDIO_SUPPORT
+	struct aic_sdio_dev *dev = g_rwnx_plat->sdiodev;
+#endif
+#ifdef AICWF_USB_SUPPORT
+	struct aic_usb_dev *dev = g_rwnx_plat->usbdev;
+#endif
+
+	rwnx_send_rftest_req(rwnx_hw, GET_VENDOR_INFO, 0, NULL, &cfm);
+	if ((dev->chipid == PRODUCT_ID_AIC8800DC) || (dev->chipid == PRODUCT_ID_AIC8800DW)) {
+		memcpy(command, &cfm.rftest_result[0], 2);
+		return 2;
+	} else {
+		memcpy(command, &cfm.rftest_result[0], 1);
+		return 1;
+	}
+	AICWFDBG(LOGINFO, "0x%x\n", cfm.rftest_result[0]);
+}
+
+static int aic_priv_cmd_rdwr_pwrmm (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	if (argc <= 1) { // read cur
+		rwnx_send_rftest_req(rwnx_hw, RDWR_PWRMM, 0, NULL, &cfm);
+	} else { // write
+		u8_l pwrmm = (u8_l)command_strtoul(argv[1], NULL, 16);
+		pwrmm = (pwrmm) ? 1 : 0;
+		AICWFDBG(LOGINFO, "set pwrmm = %x\r\n", pwrmm);
+		rwnx_send_rftest_req(rwnx_hw, RDWR_PWRMM, sizeof(pwrmm), (u8_l *)&pwrmm, &cfm);
+	}
+	memcpy(command, &cfm.rftest_result[0], 4);
+	return 4;
+}
+
+static int aic_priv_cmd_rdwr_pwridx (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+#ifdef AICWF_SDIO_SUPPORT
+	struct aic_sdio_dev *dev = g_rwnx_plat->sdiodev;
+#endif
+#ifdef AICWF_USB_SUPPORT
+	struct aic_usb_dev *dev = g_rwnx_plat->usbdev;
+#endif
+
+	if (dev->chipid != PRODUCT_ID_AIC8801){
+		AICWFDBG(LOGERROR, "unsupported cmd\n");
+		return -EINVAL;
+	}
+	if (argc > 1) {
+		func = (u8_l)command_strtoul(argv[1], NULL, 16);
+		}
+	if (func == 0) { // read cur
+		rwnx_send_rftest_req(rwnx_hw, RDWR_PWRIDX, 0, NULL, &cfm);
+	} else if (func <= 2) { // write 2.4g/5g pwr idx
+		if (argc > 3) {
+			u8_l type = (u8_l)command_strtoul(argv[2], NULL, 16);
+			u8_l pwridx = (u8_l)command_strtoul(argv[3], NULL, 10);
+			u8_l buf[3] = {func, type, pwridx};
+			AICWFDBG(LOGINFO, "set pwridx:[%x][%x]=%x\r\n", func, type, pwridx);
+			rwnx_send_rftest_req(rwnx_hw, RDWR_PWRIDX, sizeof(buf), buf, &cfm);
+		} else {
+			return -EINVAL;
+		}
+	} else {
+		return -EINVAL;
+	}
+	memcpy(command, &cfm.rftest_result[0], 9);
+	return 9;
+}
+
+static int aic_priv_cmd_rdwr_pwrlvl (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+#ifdef AICWF_SDIO_SUPPORT
+	struct aic_sdio_dev *dev = g_rwnx_plat->sdiodev;
+#endif
+#ifdef AICWF_USB_SUPPORT
+	struct aic_usb_dev *dev = g_rwnx_plat->usbdev;
+#endif
+
+	if (dev->chipid == PRODUCT_ID_AIC8801){
+		AICWFDBG(LOGERROR, "unsupported cmd\n");
+		return -EINVAL;
+	}
+	if (argc > 1) {
+		func = (u8_l)command_strtoul(argv[1], NULL, 16);
+	}
+	if (func == 0) { // read cur
+		rwnx_send_rftest_req(rwnx_hw, RDWR_PWRLVL, 0, NULL, &cfm);
+	} else if (func <= 2) { // write 2.4g/5g pwr lvl
+		if (argc > 4) {
+			u8_l grp = (u8_l)command_strtoul(argv[2], NULL, 16);
+			u8_l idx, size;
+			u8_l buf[14] = {func, grp,};
+			if (argc > 12) { // set all grp
+			AICWFDBG(LOGINFO, "set pwrlvl %s:\n"
+				   "  [%x] =", (func == 1) ? "2.4g" : "5g", grp);
+				if (grp == 1) { // TXPWR_LVL_GRP_11N_11AC
+					size = 10;
+				} else {
+					size = 12;
+				}
+				for (idx = 0; idx < size; idx++) {
+					s8_l pwrlvl = (s8_l)command_strtoul(argv[3 + idx], NULL, 10);
+					buf[2 + idx] = (u8_l)pwrlvl;
+					if (idx && !(idx & 0x3)) {
+						AICWFDBG(LOGINFO, " ");
+					}
+					AICWFDBG(LOGINFO, " %2d", pwrlvl);
+				}
+				AICWFDBG(LOGINFO, "\n");
+				size += 2;
+			} else { // set grp[idx]
+				u8_l idx = (u8_l)command_strtoul(argv[3], NULL, 10);
+				s8_l pwrlvl = (s8_l)command_strtoul(argv[4], NULL, 10);
+				buf[2] = idx;
+				buf[3] = (u8_l)pwrlvl;
+				size = 4;
+				AICWFDBG(LOGINFO, "set pwrlvl %s:\n"
+					   "  [%x][%d] = %d\n", (func == 1) ? "2.4g" : "5g", grp, idx, pwrlvl);
+			}
+		rwnx_send_rftest_req(rwnx_hw, RDWR_PWRLVL, size, buf, &cfm);
+		} else {
+		AICWFDBG(LOGERROR, "wrong args\n");
+		return -EINVAL;
+		}
+	} else {
+		AICWFDBG(LOGERROR, "wrong func: %x\n", func);
+		return -EINVAL;
+	}
+	if((dev->chipid == PRODUCT_ID_AIC8800D81) || (dev->chipid == PRODUCT_ID_AIC8800D81X2) || (dev->chipid == PRODUCT_ID_AIC8800D89X2)){
+		memcpy(command, &cfm.rftest_result[0], 6 * 12);
+		return (6 * 12);
+	} else {
+		memcpy(command, &cfm.rftest_result[0], 3 * 12);
+		return (3 * 12);
+	}
+}
+
+static int aic_priv_cmd_rdwr_pwrofst (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+	int res_len = 0;
+#ifdef AICWF_SDIO_SUPPORT
+	struct aic_sdio_dev *dev = g_rwnx_plat->sdiodev;
+#endif
+#ifdef AICWF_USB_SUPPORT
+	struct aic_usb_dev *dev = g_rwnx_plat->usbdev;
+#endif
+
+	if (argc > 1) {
+		func = (u8_l)command_strtoul(argv[1], NULL, 16);
+	}
+	if (func == 0) { // read cur
+		rwnx_send_rftest_req(rwnx_hw, RDWR_PWROFST, 0, NULL, &cfm);
+	} else if (func <= 2) { // write 2.4g/5g pwr ofst
+		if ((argc > 4) && ((dev->chipid == PRODUCT_ID_AIC8800D81) || (dev->chipid == PRODUCT_ID_AIC8800D81X2) || (dev->chipid == PRODUCT_ID_AIC8800D89X2))) {
+			u8_l type = (u8_l)command_strtoul(argv[2], NULL, 16);
+			u8_l chgrp = (u8_l)command_strtoul(argv[3], NULL, 16);
+			s8_l pwrofst = (u8_l)command_strtoul(argv[4], NULL, 10);
+			u8_l buf[4] = {func, type, chgrp, (u8_l)pwrofst};
+			AICWFDBG(LOGINFO, "set pwrofst_%s:[%x][%x]=%d\r\n", (func == 1) ? "2.4g" : "5g", type, chgrp, pwrofst);
+			rwnx_send_rftest_req(rwnx_hw, RDWR_PWROFST, sizeof(buf), buf, &cfm);
+		} else if ((argc > 3) && ((dev->chipid == PRODUCT_ID_AIC8801) || (dev->chipid == PRODUCT_ID_AIC8800DW) || (dev->chipid == PRODUCT_ID_AIC8800DC))) {
+			u8_l chgrp = (u8_l)command_strtoul(argv[2], NULL, 16);
+			s8_l pwrofst = (u8_l)command_strtoul(argv[3], NULL, 10);
+			u8_l buf[3] = {func, chgrp, (u8_l)pwrofst};
+			AICWFDBG(LOGINFO, "set pwrofst_%s:[%x]=%d\r\n", (func == 1) ? "2.4g" : "5g", chgrp, pwrofst);
+			rwnx_send_rftest_req(rwnx_hw, RDWR_PWROFST, sizeof(buf), buf, &cfm);
+		} else {
+			return -EINVAL;
+		}
+	} else {
+		AICWFDBG(LOGERROR, "wrong func: %x\n", func);
+		return -EINVAL;
+	}
+	if ((dev->chipid == PRODUCT_ID_AIC8800DC) || (dev->chipid == PRODUCT_ID_AIC8800DW)) { // 3 = 3 (2.4g)
+		res_len = 3;
+	} else if ((dev->chipid == PRODUCT_ID_AIC8800D81) || (dev->chipid == PRODUCT_ID_AIC8800D81X2) || (dev->chipid == PRODUCT_ID_AIC8800D89X2)) { // 3 * 2 (2.4g) + 3 * 6 (5g)
+		res_len = 3 * 3 + 3 * 6;
+	} else {
+		res_len = 3 + 4;
+	}
+	memcpy(command, &cfm.rftest_result[0], res_len);
+	return res_len;
+}
+
+static int aic_priv_cmd_rdwr_pwrofstfine (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+
+	if (argc > 1) {
+		func = (u8_l)command_strtoul(argv[1], NULL, 16);
+	}
+	if (func == 0) { // read cur
+		rwnx_send_rftest_req(rwnx_hw, RDWR_PWROFSTFINE, 0, NULL, &cfm);
+	} else if (func <= 2) { // write 2.4g/5g pwr ofst
+		if (argc > 3) {
+			u8_l chgrp = (u8_l)command_strtoul(argv[2], NULL, 16);
+			s8_l pwrofst = (u8_l)command_strtoul(argv[3], NULL, 10);
+			u8_l buf[3] = {func, chgrp, (u8_l)pwrofst};
+			AICWFDBG(LOGINFO, "set pwrofstfine:[%x][%x]=%d\r\n", func, chgrp, pwrofst);
+			rwnx_send_rftest_req(rwnx_hw, RDWR_PWROFSTFINE, sizeof(buf), buf, &cfm);
+		} else {
+			AICWFDBG(LOGERROR, "wrong args\n");
+			return -EINVAL;
+
+		}
+	} else {
+		AICWFDBG(LOGERROR, "wrong func: %x\n", func);
+		return -EINVAL;
+
+	}
+	memcpy(command, &cfm.rftest_result[0], 7);
+	return 7;
+}
+
+static int aic_priv_cmd_rdwr_drvibit (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+
+	if (argc > 1) {
+		func = (u8_l)command_strtoul(argv[1], NULL, 16);
+	}
+	if (func == 0) { // read cur
+		rwnx_send_rftest_req(rwnx_hw, RDWR_DRVIBIT, 0, NULL, &cfm);
+	} else if (func == 1) { // write 2.4g pa drv_ibit
+		if (argc > 2) {
+			u8_l ibit = (u8_l)command_strtoul(argv[2], NULL, 16);
+			u8_l buf[2] = {func, ibit};
+			AICWFDBG(LOGINFO, "set drvibit:[%x]=%x\r\n", func, ibit);
+			rwnx_send_rftest_req(rwnx_hw, RDWR_DRVIBIT, sizeof(buf), buf, &cfm);
+		} else {
+			AICWFDBG(LOGERROR, "wrong args\n");
+			return -EINVAL;
+		}
+	} else {
+		AICWFDBG(LOGERROR, "wrong func: %x\n", func);
+		return -EINVAL;
+	}
+	memcpy(command, &cfm.rftest_result[0], 16);
+	return 16;
+}
+
+static int aic_priv_cmd_rdwr_efuse_pwrofst (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+	int res_len = 0;
+#ifdef AICWF_SDIO_SUPPORT
+	struct aic_sdio_dev *dev = g_rwnx_plat->sdiodev;
+#endif
+#ifdef AICWF_USB_SUPPORT
+	struct aic_usb_dev *dev = g_rwnx_plat->usbdev;
+#endif
+
+	if (argc > 1) {
+		func = (u8_l)command_strtoul(argv[1], NULL, 16);
+	}
+	if (func == 0) { // read cur
+		rwnx_send_rftest_req(rwnx_hw, RDWR_EFUSE_PWROFST, 0, NULL, &cfm);
+	} else if (func <= 2) { // write 2.4g/5g pwr ofst
+		if ((argc > 4) && ((dev->chipid == PRODUCT_ID_AIC8800D81) || (dev->chipid == PRODUCT_ID_AIC8800D81X2) || (dev->chipid == PRODUCT_ID_AIC8800D89X2))) {
+			u8_l type = (u8_l)command_strtoul(argv[2], NULL, 16);
+			u8_l chgrp = (u8_l)command_strtoul(argv[3], NULL, 16);
+			s8_l pwrofst = (u8_l)command_strtoul(argv[4], NULL, 10);
+			u8_l buf[4] = {func, type, chgrp, (u8_l)pwrofst};
+			AICWFDBG(LOGINFO, "set efuse pwrofst_%s:[%x][%x]=%d\r\n", (func == 1) ? "2.4g" : "5g", type, chgrp, pwrofst);
+			rwnx_send_rftest_req(rwnx_hw, RDWR_EFUSE_PWROFST, sizeof(buf), buf, &cfm);
+		} else if ((argc > 3) && ((dev->chipid == PRODUCT_ID_AIC8801) || (dev->chipid == PRODUCT_ID_AIC8800DW) || (dev->chipid == PRODUCT_ID_AIC8800DC))) {
+			u8_l chgrp = (u8_l)command_strtoul(argv[2], NULL, 16);
+			s8_l pwrofst = (u8_l)command_strtoul(argv[3], NULL, 10);
+			u8_l buf[3] = {func, chgrp, (u8_l)pwrofst};
+			AICWFDBG(LOGINFO, "set efuse pwrofst_%s:[%x]=%d\r\n", (func == 1) ? "2.4g" : "5g", chgrp, pwrofst);
+			rwnx_send_rftest_req(rwnx_hw, RDWR_EFUSE_PWROFST, sizeof(buf), buf, &cfm);
+		} else {
+			AICWFDBG(LOGERROR, "wrong args\n");
+			return -EINVAL;
+		}
+	} else {
+		AICWFDBG(LOGERROR, "wrong func: %x\n", func);
+		return -EINVAL;
+	}
+	if ((dev->chipid == PRODUCT_ID_AIC8800DC) || (dev->chipid == PRODUCT_ID_AIC8800DW)) { // 6 = 3 (2.4g) * 2
+		res_len = 3 * 2;
+	} else if ((dev->chipid == PRODUCT_ID_AIC8800D81) || (dev->chipid == PRODUCT_ID_AIC8800D81X2) || (dev->chipid == PRODUCT_ID_AIC8800D89X2)) { // 3 * 2 (2.4g) + 3 * 6 (5g)
+		res_len = (3 * 3 + 3 * 6) * 2;
+	} else { // 7 = 3(2.4g) + 4(5g)
+		res_len = 3 + 4;
+	}
+	memcpy(command, &cfm.rftest_result[0], res_len);
+	return res_len;
+}
+
+static int aic_priv_cmd_rdwr_efuse_pwrofstfine (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+
+	if (argc > 1) {
+		func = (u8_l)command_strtoul(argv[1], NULL, 16);
+	}
+	if (func == 0) { // read cur
+		rwnx_send_rftest_req(rwnx_hw, RDWR_EFUSE_PWROFSTFINE, 0, NULL, &cfm);
+	} else if (func <= 2) { // write 2.4g/5g pwr ofst
+		if (argc > 3) {
+			u8_l chgrp = (u8_l)command_strtoul(argv[2], NULL, 16);
+			s8_l pwrofst = (u8_l)command_strtoul(argv[3], NULL, 10);
+			u8_l buf[3] = {func, chgrp, (u8_l)pwrofst};
+			AICWFDBG(LOGINFO, "set pwrofstfine:[%x][%x]=%d\r\n", func, chgrp, pwrofst);
+			rwnx_send_rftest_req(rwnx_hw, RDWR_EFUSE_PWROFSTFINE, sizeof(buf), buf, &cfm);
+		} else {
+			AICWFDBG(LOGERROR, "wrong args\n");
+			return -EINVAL;
+		}
+	} else {
+		AICWFDBG(LOGERROR, "wrong func: %x\n", func);
+		return -EINVAL;
+	}
+	memcpy(command, &cfm.rftest_result[0], 7);
+	return 7;
+}
+
+static int aic_priv_cmd_rdwr_efuse_drvibit (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+
+	if (argc > 1) {
+		func = (u8_l)command_strtoul(argv[1], NULL, 16);
+	}
+	if (func == 0) { // read cur
+		rwnx_send_rftest_req(rwnx_hw, RDWR_EFUSE_DRVIBIT, 0, NULL, &cfm);
+	} else if (func == 1) { // write 2.4g pa drv_ibit
+		if (argc > 2) {
+		u8_l ibit = (u8_l)command_strtoul(argv[2], NULL, 16);
+		u8_l buf[2] = {func, ibit};
+		AICWFDBG(LOGINFO, "set efuse drvibit:[%x]=%x\r\n", func, ibit);
+		rwnx_send_rftest_req(rwnx_hw, RDWR_EFUSE_DRVIBIT, sizeof(buf), buf, &cfm);
+		} else {
+			AICWFDBG(LOGERROR, "wrong args\n");
+			return -EINVAL;
+		}
+	} else {
+		AICWFDBG(LOGERROR, "wrong func: %x\n", func);
+		return -EINVAL;
+	}
+	memcpy(command, &cfm.rftest_result[0], 4);
+	return 4;
+}
+
+static int aic_priv_cmd_rdwr_efuse_usrdata (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	cmd_ef_usrdata_t cmd_ef_usrdata;
+
+	if (argc <= 1) { // read all
+		cmd_ef_usrdata.func = 0;
+		cmd_ef_usrdata.cnt = 3;
+	} else if (argc >= 2) { // read/write
+		cmd_ef_usrdata.func = (u8_l)command_strtoul(argv[1], NULL, 10);
+		cmd_ef_usrdata.cnt = (u8_l)command_strtoul(argv[2], NULL, 10);
+		if (cmd_ef_usrdata.func == 1) {
+			int idx;
+			for (idx = 0; idx < cmd_ef_usrdata.cnt; idx++) {
+				cmd_ef_usrdata.usrdata[idx] = (u32_l)command_strtoul(argv[3 + idx], NULL, 16);
+			}
+		}
+	} else {
+		AICWFDBG(LOGERROR, "wrong argc: %x\n", argc);
+		return -EINVAL;
+	}
+	rwnx_send_rftest_req(rwnx_hw, RDWR_EFUSE_USRDATA, sizeof(cmd_ef_usrdata), (u8_l *)&cmd_ef_usrdata, &cfm);
+	memcpy(command, &cfm.rftest_result[0], 12);
+	return 12;
+}
+
+static int aic_priv_cmd_rdwr_efuse_sdiocfg (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+
+	if (argc > 1) {
+		func = (u8_l)command_strtoul(argv[1], NULL, 16);
+	}
+	if (func == 0) { // read cur
+		rwnx_send_rftest_req(rwnx_hw, RDWR_EFUSE_SDIOCFG, 0, NULL, &cfm);
+	} else if (func == 1) { // write sdiocfg
+		if (argc > 2) {
+			u8_l ibit = (u8_l)command_strtoul(argv[2], NULL, 16);
+			u8_l buf[2] = {func, ibit};
+			AICWFDBG(LOGINFO, "set efuse sdiocfg:[%x]=%x\r\n", func, ibit);
+			rwnx_send_rftest_req(rwnx_hw, RDWR_EFUSE_SDIOCFG, sizeof(buf), buf, &cfm);
+		} else {
+			AICWFDBG(LOGERROR, "wrong args\n");
+			return -EINVAL;
+		}
+	} else {
+		AICWFDBG(LOGERROR, "wrong func: %x\n", func);
+		return -EINVAL;
+	}
+	memcpy(command, &cfm.rftest_result[0], 4);
+	return 4;
+}
+
+static int aic_priv_cmd_rdwr_efuse_usbvidpid (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+	AICWFDBG(LOGINFO, "read/write usb vid/pid into efuse\n");
+	if (argc > 1) {
+		func = (u8_l)command_strtoul(argv[1], NULL, 16);
+	}
+	if (func == 0) { // read cur
+		rwnx_send_rftest_req(rwnx_hw, RDWR_EFUSE_USBVIDPID, 0, NULL, &cfm);
+	} else if (func == 1) { // write USB vid+pid
+		if (argc > 2) {
+			u32_l usb_id = (u32_l)command_strtoul(argv[2], NULL, 16);
+			u8_l buf[5] = {func, (u8_l)usb_id, (u8_l)(usb_id >> 8), (u8_l)(usb_id >> 16), (u8_l)(usb_id >> 24)};
+			AICWFDBG(LOGINFO, "set efuse usb vid/pid:[%x]=%x\r\n", func, usb_id);
+			rwnx_send_rftest_req(rwnx_hw, RDWR_EFUSE_USBVIDPID, sizeof(buf), buf, &cfm);
+		} else {
+			AICWFDBG(LOGERROR, "wrong args\n");
+			return -EINVAL;
+		}
+	} else {
+		AICWFDBG(LOGERROR, "wrong func: %x\n", func);
+		return -EINVAL;
+	}
+	memcpy(command, &cfm.rftest_result[0], 4);
+	return 4;
+}
+
+static int aic_priv_cmd_rdwr_efuse_he_off (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+
+	func = command_strtoul(argv[1], NULL, 10);
+	AICWFDBG(LOGINFO, "set he off: %d\n", func);
+	if(func == 1 || func == 0) {
+		rwnx_send_rftest_req(rwnx_hw, RDWR_EFUSE_HE_OFF, sizeof(func), (u8_l *)&func, &cfm);
+		AICWFDBG(LOGINFO, "he_off cfm: %d\n", cfm.rftest_result[0]);
+		memcpy(command, &cfm.rftest_result[0], 4);
+		return 4;
+	}
+	return 0;
+}
+
+static int aic_priv_cmd_set_cal_xtal (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	rwnx_send_rftest_req(rwnx_hw, SET_CAL_XTAL, 0, NULL, NULL);
+	return 0;
+}
+
+static int aic_priv_cmd_get_cal_xtal_res (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	rwnx_send_rftest_req(rwnx_hw, GET_CAL_XTAL_RES, 0, NULL, &cfm);
+	memcpy(command, &cfm.rftest_result[0], 4);
+	AICWFDBG(LOGINFO, "cap=0x%x, cap_fine=0x%x\n", cfm.rftest_result[0] & 0x0000ffff, (cfm.rftest_result[0] >> 16) & 0x0000ffff);
+	return 4;
+}
+
+static int aic_priv_cmd_set_cob_cal (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	cmd_rf_setcobcal_t setcob_cal;
+
+	if (argc < 3)
+		return -EINVAL;
+	setcob_cal.dutid = command_strtoul(argv[1], NULL, 10);
+	setcob_cal.chip_num = command_strtoul(argv[2], NULL, 10);
+	setcob_cal.dis_xtal = command_strtoul(argv[3], NULL, 10);
+	rwnx_send_rftest_req(rwnx_hw, SET_COB_CAL, sizeof(cmd_rf_setcobcal_t), (u8_l *)&setcob_cal, NULL);
+	return 0;
+}
+
+static int aic_priv_cmd_get_cob_cal_res (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l state;
+	cob_result_ptr_t *cob_result_ptr;
+
+	rwnx_send_rftest_req(rwnx_hw, GET_COB_CAL_RES, 0, NULL, &cfm);
+	state = (cfm.rftest_result[0] >> 16) & 0x000000ff;
+	if (!state){
+		AICWFDBG(LOGINFO, "cap= 0x%x, cap_fine= 0x%x, freq_ofst= %d Hz\n",
+		cfm.rftest_result[0] & 0x000000ff, (cfm.rftest_result[0] >> 8) & 0x000000ff, cfm.rftest_result[1]);
+		cob_result_ptr = (cob_result_ptr_t *) & (cfm.rftest_result[2]);
+		AICWFDBG(LOGINFO, "golden_rcv_dut= %d , tx_rssi= %d dBm, snr = %d dB\ndut_rcv_godlden= %d , rx_rssi= %d dBm",
+		cob_result_ptr->golden_rcv_dut_num, cob_result_ptr->rssi_static, cob_result_ptr->snr_static,
+		cob_result_ptr->dut_rcv_golden_num, cob_result_ptr->dut_rssi_static);
+		memcpy(command, &cfm.rftest_result, 16);
+		return 16;
+	} else {
+		AICWFDBG(LOGERROR, "cob not idle\n");
+		return -EINVAL;
+	}
+}
+
+static int aic_priv_cmd_do_cob_test (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l state;
+	cmd_rf_setcobcal_t setcob_cal;
+	cob_result_ptr_t *cob_result_ptr;
+
+	setcob_cal.dutid = 1;
+	setcob_cal.chip_num = 1;
+	setcob_cal.dis_xtal = 0;
+	if (argc > 1)
+		setcob_cal.dis_xtal = command_strtoul(argv[1], NULL, 10);
+	rwnx_send_rftest_req(rwnx_hw, SET_COB_CAL, sizeof(cmd_rf_setcobcal_t), (u8_l *)&setcob_cal, NULL);
+	msleep(2000);
+	rwnx_send_rftest_req(rwnx_hw, GET_COB_CAL_RES, 0, NULL, &cfm);
+	state = (cfm.rftest_result[0] >> 16) & 0x000000ff;
+	if (!state){
+		AICWFDBG(LOGINFO, "cap= 0x%x, cap_fine= 0x%x, freq_ofst= %d Hz\n",
+		cfm.rftest_result[0] & 0x000000ff, (cfm.rftest_result[0] >> 8) & 0x000000ff, cfm.rftest_result[1]);
+		cob_result_ptr = (cob_result_ptr_t *) & (cfm.rftest_result[2]);
+		AICWFDBG(LOGINFO, "golden_rcv_dut= %d , tx_rssi= %d dBm, snr = %d dB\ndut_rcv_godlden= %d , rx_rssi= %d dBm",
+		cob_result_ptr->golden_rcv_dut_num, cob_result_ptr->rssi_static, cob_result_ptr->snr_static,
+		cob_result_ptr->dut_rcv_golden_num, cob_result_ptr->dut_rssi_static);
+		memcpy(command, &cfm.rftest_result, 16);
+		return 16;
+	} else {
+		AICWFDBG(LOGERROR, "cob not idle\n");
+		return -EINVAL;
+	}
+}
+
+static int aic_priv_cmd_set_papr (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+	if (argc > 1) {
+		func = command_strtoul(argv[1], NULL, 10);
+		AICWFDBG(LOGINFO, "papr %d\r\n", func);
+		rwnx_send_rftest_req(rwnx_hw, SET_PAPR, sizeof(func), (u8_l *)&func, NULL);
+	} else {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int aic_priv_cmd_set_notch (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+	if (argc > 1) {
+		func = command_strtoul(argv[1], NULL, 10);
+		AICWFDBG(LOGINFO, "notch %d\r\n", func);
+		rwnx_send_rftest_req(rwnx_hw, SET_NOTCH, sizeof(func), (u8_l *)&func, NULL);
+	} else {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int aic_priv_cmd_set_srrc (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+	if (argc > 1) {
+		func = command_strtoul(argv[1], NULL, 10);
+		AICWFDBG(LOGINFO, "srrc %d\r\n", func);
+		rwnx_send_rftest_req(rwnx_hw, SET_SRRC, sizeof(func), (u8_l *)&func, NULL);
+	} else {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int aic_priv_cmd_set_fss (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+	if (argc > 1) {
+		func = command_strtoul(argv[1], NULL, 10);
+		AICWFDBG(LOGINFO, "fss %d\r\n", func);
+		rwnx_send_rftest_req(rwnx_hw, SET_FSS, sizeof(func), (u8_l *)&func, NULL);
+	} else {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int aic_priv_cmd_set_usb_off (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	rwnx_send_rftest_req(rwnx_hw, SET_USB_OFF, 0, NULL, NULL);
+	return 0;
+}
+
+static int aic_priv_cmd_set_pll_test (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0, tx_pwr = 0xc;
+	s8_l freq = 0;
+
+	if (argc > 1) {
+		func = command_strtoul(argv[1], NULL, 16);
+	}
+	if (argc > 3) {
+		freq = (s8_l)command_strtoul(argv[2], NULL, 10);
+		tx_pwr = command_strtoul(argv[3], NULL, 16);
+	}
+	if (func <= 1) {
+		u8_l buf[3] = {func, (u8_l)freq, tx_pwr};
+		AICWFDBG(LOGINFO, "set pll_test %d: freq=%d, tx_pwr=0x%x\n", func, freq, tx_pwr);
+		rwnx_send_rftest_req(rwnx_hw, SET_PLL_TEST, sizeof(buf), buf, &cfm);
+	} else {
+		AICWFDBG(LOGERROR, "wrong func: %x\n", func);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int aic_priv_cmd_set_ant_mode (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+	if (argc > 1) {
+		func = command_strtoul(argv[1], NULL, 10);
+		AICWFDBG(LOGINFO, "ant %d\r\n", func);
+		rwnx_send_rftest_req(rwnx_hw, SET_ANT_MODE, sizeof(func), (u8_l *)&func, NULL);
+	} else {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+
+static int aic_priv_cmd_help (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	print_help(argc > 0 ? argv[0] : NULL);
+	return 0;
+}
+
+struct aic_priv_cmd {
+	const char *cmd;
+	int (*handler)(struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command);
+	const char *usage;
+};
+
+static const struct aic_priv_cmd aic_priv_commands[] = {
+	{ "set_tx", aic_priv_cmd_set_tx,
+	  "<chan> <bw> <mode> <rate> <length> <interval>" },
+	{ "set_txstop", aic_priv_cmd_set_txstop,
+	  "= stop tx " },
+	{ "set_rx", aic_priv_cmd_set_rx,
+	  "<chan_num> <bw> " },
+	{ "get_rx_result", aic_priv_cmd_get_rx_result,
+	  "= display rx fcsok/total pkt num" },
+	{ "set_rxstop", aic_priv_cmd_set_rxstop,
+	  "= stop rx " },
+	{ "set_txtone", aic_priv_cmd_set_tx_tone,
+	  "<val> val = 0/off" },
+	{ "set_rx_meter", aic_priv_cmd_set_rx_meter,
+	  "= set rx meter " },
+	{ "set_power", aic_priv_cmd_set_set_power,
+	  "<dec val> " },
+	{ "set_xtal_cap", aic_priv_cmd_set_xtal_cap,
+	  "<dec val> [0 ~ 31]" },
+	{ "set_xtal_cap_fine", aic_priv_cmd_set_xtal_cap_fine,
+	  "<dec val> [0 ~ 63]" },
+	{ "get_efuse_block", aic_priv_cmd_get_efuse_block,
+	  "<val>" },
+	{ "set_freq_cal", aic_priv_cmd_set_freq_cal,
+	  "<hex val>" },
+	{ "set_freq_cal_fine", aic_priv_cmd_set_freq_cal_fine,
+	  "<hex val>" },
+	{ "get_freq_cal", aic_priv_cmd_get_freq_cal,
+	  "= display cap & cap fine" },
+	{ "set_mac_addr", aic_priv_cmd_set_mac_addr,
+	  "= write WiFi MAC into efuse or flash is limited to a maximum of two times" },
+	{ "get_mac_addr", aic_priv_cmd_get_mac_addr,
+	  "= display WiFi MAC stored in efuse or flash" },
+	{ "set_bt_mac_addr", aic_priv_cmd_set_bt_mac_addr,
+	  "= write BT MAC into efuse or flash is limited to a maximum of two times" },
+	{ "get_bt_mac_addr", aic_priv_cmd_get_bt_mac_addr,
+	  "= display BT MAC stored in efuse or flash" },
+	{ "set_vendor_info", aic_priv_cmd_set_vendor_info,
+	  "= write vendor info into efuse or flash is allowed only once" },
+	{ "get_vendor_info", aic_priv_cmd_get_vendor_info,
+	  "= display vendor info stored in efuse or flash" },
+	{ "rdwr_pwrmm", aic_priv_cmd_rdwr_pwrmm,
+	  "<val> = 0/rdwr_pwrlvl, 1/set_power = read/write txpwr manul mode" },
+	{ "rdwr_pwridx", aic_priv_cmd_rdwr_pwridx,
+	  "<band> <mod> <idx>" },
+	{ "rdwr_pwrlvl", aic_priv_cmd_rdwr_pwrlvl,
+	  "<band> <mod> <idx>" },
+	{ "rdwr_pwrofst", aic_priv_cmd_rdwr_pwrofst,
+	  "<band> <rate> <ch> <ofst>" },
+	{ "rdwr_pwrofstfine", aic_priv_cmd_rdwr_pwrofstfine,
+	  "<band> <rate> <ch> <ofstfine>" },
+	{ "rdwr_drvibit", aic_priv_cmd_rdwr_drvibit,
+	  "<func> <val> read/write 8800D pa drvibit" },
+	{ "set_cal_xtal", aic_priv_cmd_set_cal_xtal,
+	  "= set cal xtal" },
+	{ "get_cal_xtal_res", aic_priv_cmd_get_cal_xtal_res,
+	  "= get cal xtal result cap & cap_fine" },
+	{ "set_cob_cal", aic_priv_cmd_set_cob_cal,
+	  "<dutid> <chip_num> <disxtal> = dut cob test" },
+	{ "get_cob_cal_res", aic_priv_cmd_get_cob_cal_res,
+	  "= get cob cal result" },
+	{ "do_cob_test", aic_priv_cmd_do_cob_test,
+	  "<func> = 0/xtal, 1/dis_xtal, 2/only_xtal" },
+	{ "rdwr_efuse_pwrofst", aic_priv_cmd_rdwr_efuse_pwrofst,
+	  "<band> <rate> <ch> <ofst> limited to a maximum of two times" },
+	{ "rdwr_efuse_pwrofstfine", aic_priv_cmd_rdwr_efuse_pwrofstfine,
+	  "<band> <rate> <ch> <ofstfine> limited to a maximum of two times" },
+	{ "rdwr_efuse_drvibit", aic_priv_cmd_rdwr_efuse_drvibit,
+	  "<func> <val> = read/write 8800D efuse pa drvibitis allowed only once" },
+	{ "rdwr_efuse_usrdata", aic_priv_cmd_rdwr_efuse_usrdata,
+	  "<func> <val> = read/write efuse usrdata" },
+	{ "rdwr_efuse_sdiocfg", aic_priv_cmd_rdwr_efuse_sdiocfg,
+	  "<func> <val> = read/write sdiocfg_bit into efuse" },
+	{ "rdwr_efuse_usbvidpid", aic_priv_cmd_rdwr_efuse_usbvidpid,
+	  "<func> <val> = read/write usb vid/pid into efuse" },
+	{ "rdwr_efuse_he_off", aic_priv_cmd_rdwr_efuse_he_off,
+	  "<func> = read/write he_off into efuse" },
+	{ "set_papr", aic_priv_cmd_set_papr,
+	  "<val> = configure papr filter to optimize sideband suppression" },
+	{ "set_notch", aic_priv_cmd_set_notch,
+	  "<val> = configure filter to optimize sideband suppression" },
+	{ "set_srrc", aic_priv_cmd_set_srrc,
+	  "<func> = disable/enable sideband suppression for SRRC" },
+	{ "set_fss", aic_priv_cmd_set_fss,
+	  "<func> = disable/enable treatment of spurious emissions and burrs" },
+	{ "set_usb_off", aic_priv_cmd_set_usb_off,
+	  "= off usb configure before usb disconnect" },
+	{ "set_pll_test", aic_priv_cmd_set_pll_test,
+	  "<func> <freq> <tx_pwr> = use pll test to measure saturation power" },
+	{ "set_ant", aic_priv_cmd_set_ant_mode,
+	  "<val> = 0/ant0, 1/ant1, 2/both" },
+//Reserve for new aic_priv_cmd.
+	{ "help", aic_priv_cmd_help,
+	  "= show usage help" },
+	{ NULL, NULL, NULL },
+
+};
+
+
+/*
+ * Prints command usage, lines are padded with the specified string.
+ */
+static void print_help(const char *cmd)
+{
+	int n;
+	printk("commands:\n");
+	for (n = 0; aic_priv_commands[n].cmd; n++) {
+		if (cmd != NULL)
+			printk("%s %s\n", aic_priv_commands[n].cmd, aic_priv_commands[n].usage);
+	}
+}
+
+int handle_private_cmd(struct net_device *net, char *command, u32 cmd_len)
+{
+	const struct aic_priv_cmd *cmd, *match = NULL;
+	int count;
+	int bytes_written = 0;
+	char *argv[CMD_MAXARGS + 1];
+	int argc;
+	struct rwnx_vif *vif = container_of(net->ieee80211_ptr, struct rwnx_vif, wdev);
+	struct rwnx_hw *p_rwnx_hw = vif->rwnx_hw;
+	
+	RWNX_DBG(RWNX_FN_ENTRY_STR);
+
+	argc = parse_line(command, argv);
+	if (argc == 0) {
+		return -1;
+	}
+
+	count = 0;
+	cmd = aic_priv_commands;
+	while (cmd->cmd) {
+		if (strncasecmp(cmd->cmd, argv[0], strlen(argv[0])) == 0)
+		{
+			match = cmd;
+			if (strcasecmp(cmd->cmd, argv[0]) == 0) {
+				/* we have an exact match */
+				count = 1;
+				break;
+			}
+			count++;
+		}
+		cmd++;
+	}
+
+	if (count > 1) {
+		AICWFDBG(LOGINFO, "Ambiguous command '%s'; possible commands:", argv[0]);
+		cmd = aic_priv_commands;
+		while (cmd->cmd) {
+			if (strncasecmp(cmd->cmd, argv[0],
+					   strlen(argv[0])) == 0) {
+				AICWFDBG(LOGINFO, " %s", cmd->cmd);
+			}
+			cmd++;
+		}
+		AICWFDBG(LOGINFO, "\n");
+	} else if (count == 0) {
+		AICWFDBG(LOGERROR, "Unknown command '%s'\n", argv[0]);
+	} else {
+		AICWFDBG(LOGINFO, "match %s", match->cmd);
+		bytes_written = match->handler(p_rwnx_hw, argc, &argv[0], command);
+	}
+
+	if (bytes_written < 0)
+		AICWFDBG(LOGERROR, "wrong param\n");
+
+	return bytes_written;
+}
+
+#define RWNX_COUNTRY_CODE_LEN 2
+#define CMD_SET_COUNTRY         "COUNTRY"
+#define CMD_SET_VENDOR_EX_IE    "SET_VENDOR_EX_IE"
+#define CMD_SET_AP_WPS_P2P_IE   "SET_AP_WPS_P2P_IE"
+#define CMD_SET_TESTMODE        "SET_TESTMODE"
+#define CMD_SET_BLE_WAKE	"SET_BLE_WAKE"
+
+
+struct ieee80211_regdomain *getRegdomainFromRwnxDB(struct wiphy *wiphy, char *alpha2);
+struct ieee80211_regdomain *getRegdomainFromRwnxDBIndex(struct wiphy *wiphy, int index);
+extern int reg_regdb_size;
+
+#ifdef CONFIG_SET_VENDOR_EXTENSION_IE
+extern u8_l vendor_extension_data[256];
+extern u8_l vendor_extension_len;
+
+void set_vendor_extension_ie(char *command){
+
+	char databyte[3]={0x00, 0x00, 0x00};
+	int skip = strlen(CMD_SET_VENDOR_EX_IE) + 1;
+	int command_index = skip;
+	int data_index = 0;
+
+	memset(vendor_extension_data, 0, 256);
+	vendor_extension_len = 0;
+	memcpy(databyte, command + command_index, 2);
+	vendor_extension_len = command_strtoul(databyte, NULL, 16);
+	AICWFDBG(LOGINFO, "%s len:%d \r\n", __func__, vendor_extension_len);
+
+	//parser command and save data in vendor_extension_data
+	for(data_index = 0;data_index < vendor_extension_len; data_index++){
+		command_index = command_index + 3;
+		memcpy(databyte, command + command_index, 2);
+		vendor_extension_data[data_index] = command_strtoul(databyte, NULL, 16);
+	}
+
+}
+#endif//CONFIG_SET_VENDOR_EXTENSION_IE
+
+int android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
+{
+#define PRIVATE_COMMAND_MAX_LEN 8192
+#define PRIVATE_COMMAND_DEF_LEN 4096
+
+	struct rwnx_vif *vif = netdev_priv(net);
+	int ret = 0;
+	char *command = NULL;
+	int bytes_written = 0;
+	android_wifi_priv_cmd priv_cmd;
+	int buf_size = 0;
+	int skip = 0;
+	char *country = NULL;
+	struct ieee80211_regdomain *regdomain;
+	//int index = 0;
+
+	RWNX_DBG(RWNX_FN_ENTRY_STR);
+
+	///todo: add our lock
+	//net_os_wake_lock(net);
+
+
+/*	if (!capable(CAP_NET_ADMIN)) {
+		ret = -EPERM;
+		goto exit;
+	}*/
+	if (!ifr->ifr_data) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+#ifdef CONFIG_COMPAT
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0))
+	if (in_compat_syscall())
+#else
+	if (is_compat_task())
+#endif
+	{
+		compat_android_wifi_priv_cmd compat_priv_cmd;
+		if (copy_from_user(&compat_priv_cmd, ifr->ifr_data, sizeof(compat_android_wifi_priv_cmd))) {
+		ret = -EFAULT;
+			goto exit;
+		}
+		priv_cmd.buf = compat_ptr(compat_priv_cmd.buf);
+		priv_cmd.used_len = compat_priv_cmd.used_len;
+		priv_cmd.total_len = compat_priv_cmd.total_len;
+	} else
+#endif /* CONFIG_COMPAT */
+	{
+		if (copy_from_user(&priv_cmd, ifr->ifr_data, sizeof(android_wifi_priv_cmd))) {
+			ret = -EFAULT;
+			goto exit;
+		}
+	}
+	if ((priv_cmd.total_len > PRIVATE_COMMAND_MAX_LEN) || (priv_cmd.total_len < 0)) {
+		AICWFDBG(LOGERROR, "%s: buf length invalid:%d\n", __FUNCTION__, priv_cmd.total_len);
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	buf_size = max(priv_cmd.total_len, PRIVATE_COMMAND_DEF_LEN);
+	command = kmalloc((buf_size + 1), GFP_KERNEL);
+
+	if (!command)
+	{
+		AICWFDBG(LOGERROR, "%s: failed to allocate memory\n", __FUNCTION__);
+		ret = -ENOMEM;
+		goto exit;
+	}
+	if (copy_from_user(command, priv_cmd.buf, priv_cmd.total_len)) {
+		ret = -EFAULT;
+		goto exit;
+	}
+	command[priv_cmd.total_len] = '\0';
+
+	/* outputs */
+	AICWFDBG(LOGINFO, "%s: Android private cmd \"%s\" on %s\n", __FUNCTION__, command, ifr->ifr_name);
+	AICWFDBG(LOGINFO, "cmd = %d\n", cmd);
+	AICWFDBG(LOGINFO, "buf_size=%d\n", buf_size);
+
+
+#if 1//Handle Android command
+	if(!strncasecmp(command, CMD_SET_COUNTRY, strlen(CMD_SET_COUNTRY))) {
+		skip = strlen(CMD_SET_COUNTRY) + 1;
+		country = command + skip;
+		if (!country || strlen(country) < RWNX_COUNTRY_CODE_LEN) {
+			AICWFDBG(LOGERROR, "%s: invalid country code\n", __func__);
+			ret = -EINVAL;
+			goto exit;
+		}
+#if 0
+		for(index = 0; index < reg_regdb_size; index++){
+			regdomain = getRegdomainFromRwnxDBIndex(vif->rwnx_hw->wiphy, index);
+			if((ret = regulatory_set_wiphy_regd(vif->rwnx_hw->wiphy, regdomain))){
+				AICWFDBG(LOGERROR, "regulatory_set_wiphy_regd fail \r\n");
+			}else{
+				AICWFDBG(LOGINFO, "regulatory_set_wiphy_regd ok \r\n");
+			}
+		}
+#endif
+		AICWFDBG(LOGINFO, "%s country code:%c%c\n", __func__, toupper(country[0]), toupper(country[1]));
+		regdomain = getRegdomainFromRwnxDB(vif->rwnx_hw->wiphy, country);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 0, 0)
+		if((ret = regulatory_set_wiphy_regd(vif->rwnx_hw->wiphy, regdomain))){
+			AICWFDBG(LOGERROR, "regulatory_set_wiphy_regd fail \r\n");
+		}
+#else
+		wiphy_apply_custom_regulatory(vif->rwnx_hw->wiphy, regdomain);
+#endif
+#ifdef CONFIG_POWER_LIMIT
+		if (vif->rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW)
+		    rwnx_plat_powerlimit_load_8800dcdw(vif->rwnx_hw, PRODUCT_ID_AIC8800DW);
+		else if (vif->rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DC)
+		    rwnx_plat_powerlimit_load_8800dcdw(vif->rwnx_hw, PRODUCT_ID_AIC8800DC);
+		else if (vif->rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81)
+		    rwnx_plat_powerlimit_load_8800d80(vif->rwnx_hw);
+		else if (vif->rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81X2 ||
+				vif->rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D89X2)
+		    rwnx_plat_powerlimit_load_8800d80x2(vif->rwnx_hw);
+		if (!testmode){
+		    rwnx_send_me_chan_config_req(vif->rwnx_hw);
+		}
+#endif
+	}
+#ifdef CONFIG_SET_VENDOR_EXTENSION_IE
+	else if(!strncasecmp(command, CMD_SET_VENDOR_EX_IE, strlen(CMD_SET_VENDOR_EX_IE))){
+		set_vendor_extension_ie(command);
+	}
+#endif//CONFIG_SET_VENDOR_EXTENSION_IE
+	else if(!strncasecmp(command, CMD_SET_AP_WPS_P2P_IE, strlen(CMD_SET_AP_WPS_P2P_IE))){
+		ret = 0;
+		goto exit;
+	}else if(!strncasecmp(command, CMD_SET_TESTMODE, strlen(CMD_SET_TESTMODE))){
+		if(g_rwnx_plat && g_rwnx_plat->usbdev->rwnx_hw){
+			if (g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DW ||
+				(g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DC) ||
+				(g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800D81) ||
+				(g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800D81X2) ||
+				(g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800D89X2)){
+				set_testmode(!testmode);
+				rwnx_send_reboot(g_rwnx_plat->usbdev->rwnx_hw);
+			}
+		}
+		ret = 0;
+		goto exit;
+	}else if(!strncasecmp(command, CMD_SET_BLE_WAKE, strlen(CMD_SET_BLE_WAKE))){
+		if(g_rwnx_plat && g_rwnx_plat->usbdev->rwnx_hw){
+			set_testmode(5);
+			rwnx_send_reboot(g_rwnx_plat->usbdev->rwnx_hw);
+		}
+		ret = 0;
+		goto exit;
+	}
+#endif//Handle Android command
+
+
+	bytes_written = handle_private_cmd(net, command, priv_cmd.total_len);
+	if (bytes_written >= 0) {
+		if ((bytes_written == 0) && (priv_cmd.total_len > 0)) {
+			command[0] = '\0';
+		}
+		if (bytes_written >= priv_cmd.total_len) {
+			AICWFDBG(LOGINFO, "%s: err. bytes_written:%d >= buf_size:%d \n",
+				__FUNCTION__, bytes_written, buf_size);
+			goto exit;
+		}
+		bytes_written++;
+		priv_cmd.used_len = bytes_written;
+		if (copy_to_user(priv_cmd.buf, command, bytes_written)) {
+		AICWFDBG(LOGERROR, "%s: failed to copy data to user buffer\n", __FUNCTION__);
+			ret = -EFAULT;
+		}
+	}
+	else {
+		/* Propagate the error */
+		ret = bytes_written;
+	}
+
+exit:
+	///todo: add our unlock
+	//net_os_wake_unlock(net);
+	kfree(command);
+	return ret;
+}
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aic_priv_cmd.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aic_priv_cmd.h
new file mode 100644
index 000000000000..7449190f58ad
--- /dev/null
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aic_priv_cmd.h
@@ -0,0 +1,33 @@
+/**
+ ******************************************************************************
+ *
+ * @file private_cmd.h
+ *
+ * Copyright (C) Aicsemi 2018-2024
+ *
+ ******************************************************************************
+ */
+
+#ifndef _AIC_PRIV_CMD_H_
+#define _AIC_PRIV_CMD_H_
+
+#include "rwnx_defs.h"
+
+typedef struct _android_wifi_priv_cmd {
+    char *buf;
+    int used_len;
+    int total_len;
+} android_wifi_priv_cmd;
+
+#ifdef CONFIG_COMPAT
+typedef struct _compat_android_wifi_priv_cmd {
+    compat_caddr_t buf;
+    int used_len;
+    int total_len;
+} compat_android_wifi_priv_cmd;
+#endif /* CONFIG_COMPAT */
+
+int android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd);
+
+#endif /* _AIC_PRIV_CMD_H_ */
+
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.c
index 4e70583bd770..105a02e8df77 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.c
@@ -27,6 +27,15 @@ static struct wifi_ring_buffer_status ring_buffer[] = {
 static struct wlan_driver_wake_reason_cnt_t wake_reason_cnt = {
 	.total_cmd_event_wake = 10,
 };
+
+enum apf_attributes {
+        APF_ATTRIBUTE_VERSION,
+        APF_ATTRIBUTE_MAX_LEN,
+        APF_ATTRIBUTE_PROGRAM,
+        APF_ATTRIBUTE_PROGRAM_LEN,
+        APF_ATTRIBUTE_MAX
+};
+
 #endif
 
 int aic_dev_start_mkeep_alive(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_vif,
@@ -578,15 +587,115 @@ static int aicwf_vendor_logger_get_wake_reason_stats(struct wiphy *wiphy, struct
 	return -EMSGSIZE;
 }
 
-static int aicwf_vendor_apf_subcmd_get_capabilities(struct wiphy *wiphy, struct wireless_dev *wdev,
+static int aicwf_vendor_logger_get_tx_pkt_fates(struct wiphy *wiphy, struct wireless_dev *wdev,
 	const void *data, int len)
 {
+#if 0
+	int ret = 0, rem, type;
+	const struct nlattr *iter;
+	int fate_num;
+	int fate_data;
+
+	AICWFDBG(LOGDEBUG, "%s Enter\r\n", __func__);
+	nla_for_each_attr(iter, data, len, rem) {
+		type = nla_type(iter);
+		switch (type) {
+		case LOGGER_ATTRIBUTE_PKT_FATE_NUM:
+			fate_num = nla_get_u32(iter);
+			break;
+		case LOGGER_ATTRIBUTE_PKT_FATE_DATA:
+			fate_data = nla_get_u64(iter);
+			break;
+		default:
+			AICWFDBG(LOGERROR, "%s(%d), Unknown type: %d\n", __func__, __LINE__, type);
+			return -EINVAL;
+		}
+	}
+#endif
 	/* TODO
 	 * Add handle in the future
 	 */
 	return 0;
 }
 
+static int aicwf_vendor_logger_get_rx_pkt_fates(struct wiphy *wiphy, struct wireless_dev *wdev,
+	const void *data, int len)
+{
+#if 0
+	int ret = 0, rem, type;
+	const struct nlattr *iter;
+	int fate_num;
+	int fate_data;
+
+	AICWFDBG(LOGDEBUG, "%s Enter\r\n", __func__);
+	nla_for_each_attr(iter, data, len, rem) {
+		type = nla_type(iter);
+		switch (type) {
+		case LOGGER_ATTRIBUTE_PKT_FATE_NUM:
+			fate_num = nla_get_u32(iter);
+			break;
+		case LOGGER_ATTRIBUTE_PKT_FATE_DATA:
+			fate_data = nla_get_u64(iter);
+			break;
+		default:
+			AICWFDBG(LOGERROR, "%s(%d), Unknown type: %d\n", __func__, __LINE__, type);
+			return -EINVAL;
+		}
+	}
+#endif
+	/* TODO
+	 * Add handle in the future
+	 */
+	return 0;
+}
+
+static int aicwf_vendor_logger_start_pkt_fate_monitoring(struct wiphy *wiphy, struct wireless_dev *wdev,
+	const void *data, int len)
+{
+	/* TODO
+	 * Add handle in the future
+	 */
+	return 0;
+}
+
+static int aicwf_vendor_apf_subcmd_get_capabilities(struct wiphy *wiphy, struct wireless_dev *wdev,
+	const void *data, int len)
+{
+	int ver, max_len;
+	int ret = 0;
+	struct sk_buff *skb = NULL;
+	
+	/* APF version */
+	ver = 4;
+	/* APF memory size limit */
+    max_len = 2048;
+
+	
+	skb = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, max_len);
+	
+	ret = nla_put_u32(skb, APF_ATTRIBUTE_VERSION, ver);
+	if (ret < 0) {
+			AICWFDBG(LOGERROR, "Failed to put APF_ATTRIBUTE_VERSION, ret:%d\n", ret);
+			goto fail;
+	}
+	ret = nla_put_u32(skb, APF_ATTRIBUTE_MAX_LEN, max_len);
+	if (ret < 0) {
+			AICWFDBG(LOGERROR, "Failed to put APF_ATTRIBUTE_MAX_LEN, ret:%d\n", ret);
+			goto fail;
+	}
+
+	ret = cfg80211_vendor_cmd_reply(skb);
+	if (unlikely(ret)) {
+			AICWFDBG(LOGERROR, "vendor command reply failed, ret=%d\n", ret);
+	}
+
+fail:
+	/* TODO
+	 * Add handle in the future
+	 */
+	return ret;
+}
+
 static int aicwf_vendor_sub_cmd_set_mac(struct wiphy *wiphy, struct wireless_dev *wdev,
 	const void *data, int len)
 {
@@ -594,8 +703,6 @@ static int aicwf_vendor_sub_cmd_set_mac(struct wiphy *wiphy, struct wireless_dev
 	const struct nlattr *iter;
 	u8 mac[ETH_ALEN];
 
-    printk("%s enter \r\n", __func__);
-
 	nla_for_each_attr(iter, data, len, rem) {
 		type = nla_type(iter);
 		switch (type) {
@@ -660,7 +767,8 @@ aicwf_cfg80211_subcmd_set_mac_policy[WIFI_VENDOR_ATTR_DRIVER_MAX + 1] = {
 	[0] = {.type = NLA_UNSPEC },
 	[WIFI_VENDOR_ATTR_DRIVER_MAC_ADDR] = { .type = NLA_MSECS, .len  = ETH_ALEN },
 };
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 static int aicwf_dump_interface(struct wiphy *wiphy,
 				struct wireless_dev *wdev, struct sk_buff *skb,
 				const void *data, int data_len,
@@ -668,6 +776,9 @@ static int aicwf_dump_interface(struct wiphy *wiphy,
 {
 	return 0;
 }
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
 
 const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 	{
@@ -677,7 +788,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = aicwf_vendor_start_mkeep_alive,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = aicwf_cfg80211_mkeep_alive_policy,
 		.maxattr = MKEEP_ALIVE_ATTRIBUTE_MAX
@@ -690,7 +803,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = aicwf_vendor_stop_mkeep_alive,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = aicwf_cfg80211_mkeep_alive_policy,
 		.maxattr = MKEEP_ALIVE_ATTRIBUTE_MAX
@@ -703,7 +818,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = aicwf_vendor_get_ver,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = aicwf_cfg80211_logger_policy,
 		.maxattr = LOGGER_ATTRIBUTE_MAX
@@ -716,7 +833,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = aicwf_vendor_subcmd_get_channel_list,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = aicwf_cfg80211_subcmd_policy,
 		.maxattr = GSCAN_ATTRIBUTE_MAX
@@ -729,7 +848,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = aicwf_vendor_subcmd_set_country_code,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = aicwf_cfg80211_andr_wifi_policy,
 		.maxattr = ANDR_WIFI_ATTRIBUTE_MAX
@@ -742,7 +863,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |  WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = aicwf_vendor_logger_trigger_memory_dump,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = VENDOR_CMD_RAW_DATA,
 #endif
@@ -754,7 +877,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |  WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = aicwf_vendor_subcmd_get_feature_set,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = VENDOR_CMD_RAW_DATA,
 #endif
@@ -766,7 +891,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |  WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = aicwf_vendor_logger_get_feature,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = VENDOR_CMD_RAW_DATA,
 #endif
@@ -778,7 +905,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |  WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = aicwf_vendor_logger_get_ring_status,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = VENDOR_CMD_RAW_DATA,
 #endif
@@ -790,7 +919,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |  WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = aicwf_vendor_logger_start_logging,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = aicwf_cfg80211_logger_policy,
 		.maxattr = LOGGER_ATTRIBUTE_MAX
@@ -803,7 +934,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |  WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = aicwf_vendor_logger_get_ring_data,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = aicwf_cfg80211_logger_policy,
 		.maxattr = LOGGER_ATTRIBUTE_MAX
@@ -816,7 +949,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |  WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = aicwf_vendor_logger_get_wake_reason_stats,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = VENDOR_CMD_RAW_DATA,
 #endif
@@ -828,7 +963,51 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |  WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = aicwf_vendor_apf_subcmd_get_capabilities,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
+	},
+	{
+		{
+			.vendor_id = GOOGLE_OUI,
+			.subcmd = LOGGER_START_PKT_FATE_MONITORING
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |  WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = aicwf_vendor_logger_start_pkt_fate_monitoring,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
+		.dumpit = aicwf_dump_interface,
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
+	},
+	{
+		{
+			.vendor_id = GOOGLE_OUI,
+			.subcmd = LOGGER_GET_TX_PKT_FATES
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |  WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = aicwf_vendor_logger_get_tx_pkt_fates,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
+		.dumpit = aicwf_dump_interface,
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
+	},
+	{
+		{
+			.vendor_id = GOOGLE_OUI,
+			.subcmd = LOGGER_GET_RX_PKT_FATES
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |  WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = aicwf_vendor_logger_get_rx_pkt_fates,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
+		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = VENDOR_CMD_RAW_DATA,
 #endif
@@ -840,7 +1019,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		},
 		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_RUNNING,
 		.doit = aicwf_vendor_sub_cmd_set_mac,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = aicwf_cfg80211_subcmd_set_mac_policy,
 		.maxattr = WIFI_VENDOR_ATTR_DRIVER_MAX,
@@ -853,7 +1034,9 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
         },
         .flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_RUNNING,
         .doit = aicwf_vendor_sub_cmd_set_mac,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
         .dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
         .policy = aicwf_cfg80211_subcmd_set_mac_policy,
         .maxattr = WIFI_VENDOR_ATTR_DRIVER_MAX,
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80.c
index d44ad7ddf790..3a9ca060d3f9 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80.c
@@ -3,6 +3,7 @@
 #include "reg_access.h"
 
 #define FW_USERCONFIG_NAME_8800D80         "aic_userconfig_8800d80.txt"
+#define FW_POWERLIMIT_NAME_8800D80         "aic_powerlimit_8800d80.txt"
 
 extern char aic_fw_path[200];
 
@@ -19,13 +20,14 @@ int aicwf_set_rf_config_8800d80(struct rwnx_hw *rwnx_hw, struct mm_set_rf_calib_
 	if ((ret = rwnx_send_txpwr_lvl_v3_req(rwnx_hw))) {
 		return -1;
 	}
-	if ((ret = rwnx_send_txpwr_ofst_req(rwnx_hw))) {
+	if ((ret = rwnx_send_txpwr_lvl_adj_req(rwnx_hw))) {
 		return -1;
 	}
-	if (testmode == 0) {
-		if ((ret = rwnx_send_rf_calib_req(rwnx_hw, cfm))) {
-			return -1;
-		}
+	if ((ret = rwnx_send_txpwr_ofst2x_req(rwnx_hw))) {
+		return -1;
+	}
+	if ((ret = rwnx_send_rf_calib_req(rwnx_hw, cfm))) {
+		return -1;
 	}
 	return 0 ;
 }
@@ -62,5 +64,33 @@ int	rwnx_plat_userconfig_load_8800d80(struct rwnx_hw *rwnx_hw){
 
 }
 
+#ifdef CONFIG_POWER_LIMIT
+extern char country_code[];
+int rwnx_plat_powerlimit_load_8800d80(struct rwnx_hw *rwnx_hw)
+{
+    int size;
+    u32 *dst=NULL;
+    char *filename = FW_POWERLIMIT_NAME_8800D80;
+
+    AICWFDBG(LOGINFO, "powerlimit file path:%s \r\n", filename);
+
+    /* load file */
+    size = rwnx_request_firmware_common(rwnx_hw, &dst, filename);
+    if (size <= 0) {
+        AICWFDBG(LOGERROR, "wrong size of cfg file\n");
+        dst = NULL;
+        return 0;
+    }
+
+    AICWFDBG(LOGINFO, "### Load file done: %s, size=%d\n", filename, size);
+
+    /* parsing the file */
+    rwnx_plat_powerlimit_parsing((char *)dst, size, country_code);
 
+    rwnx_release_firmware_common(&dst);
+
+    AICWFDBG(LOGINFO, "powerlimit download complete\n\n");
+    return 0;
+}
+#endif
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80.h
index 27565d802e0b..134fd1a534fe 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80.h
@@ -1,6 +1,9 @@
 #include <linux/types.h>
 
 int rwnx_plat_userconfig_load_8800d80(struct rwnx_hw *rwnx_hw);
+#ifdef CONFIG_POWER_LIMIT
+int rwnx_plat_powerlimit_load_8800d80(struct rwnx_hw *rwnx_hw);
+#endif
 int aicwf_set_rf_config_8800d80(struct rwnx_hw *rwnx_hw, struct mm_set_rf_calib_cfm *cfm);
 
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80x2.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80x2.c
new file mode 100644
index 000000000000..d33cb7a436c6
--- /dev/null
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80x2.c
@@ -0,0 +1,96 @@
+#include "rwnx_main.h"
+#include "rwnx_msg_tx.h"
+#include "reg_access.h"
+
+#define FW_USERCONFIG_NAME_8800D80X2         "aic_userconfig_8800d80x2.txt"
+#define FW_POWERLIMIT_NAME_8800D80X2         "aic_powerlimit_8800d80x2.txt"
+
+extern char aic_fw_path[200];
+
+int rwnx_request_firmware_common(struct rwnx_hw *rwnx_hw,
+	u32** buffer, const char *filename);
+void rwnx_plat_userconfig_parsing(char *buffer, int size);
+void rwnx_release_firmware_common(u32** buffer);
+
+
+int aicwf_set_rf_config_8800d80x2(struct rwnx_hw *rwnx_hw, struct mm_set_rf_calib_cfm *cfm)
+{
+	int ret = 0;
+
+	if ((ret = rwnx_send_txpwr_lvl_v3_req(rwnx_hw))) {
+		return -1;
+	}
+	if ((ret = rwnx_send_txpwr_lvl_adj_req(rwnx_hw))) {
+		return -1;
+	}
+	if ((ret = rwnx_send_txpwr_ofst2x_req(rwnx_hw))) {
+		return -1;
+	}
+	if ((ret = rwnx_send_rf_calib_req(rwnx_hw, cfm))) {
+		return -1;
+	}
+	return 0 ;
+}
+
+
+int	rwnx_plat_userconfig_load_8800d80x2(struct rwnx_hw *rwnx_hw){
+    int size;
+    u32 *dst=NULL;
+    char *filename = FW_USERCONFIG_NAME_8800D80X2;
+
+#ifndef ANDROID_PLATFORM
+    sprintf(aic_fw_path, "%s/%s", aic_fw_path, "aic8800D80X2");
+#endif
+
+    AICWFDBG(LOGINFO, "userconfig file path:%s \r\n", filename);
+
+    /* load file */
+    size = rwnx_request_firmware_common(rwnx_hw, &dst, filename);
+    if (size <= 0) {
+            AICWFDBG(LOGERROR, "wrong size of firmware file\n");
+            dst = NULL;
+            return 0;
+    }
+
+    /* Copy the file on the Embedded side */
+    AICWFDBG(LOGINFO, "### Load file done: %s, size=%d\n", filename, size);
+
+    rwnx_plat_userconfig_parsing((char *)dst, size);
+
+    rwnx_release_firmware_common(&dst);
+
+    AICWFDBG(LOGINFO, "userconfig download complete\n\n");
+    return 0;
+
+}
+
+#ifdef CONFIG_POWER_LIMIT
+extern char default_ccode[];
+int rwnx_plat_powerlimit_load_8800d80x2(struct rwnx_hw *rwnx_hw)
+{
+    int size;
+    u32 *dst=NULL;
+    char *filename = FW_POWERLIMIT_NAME_8800D80X2;
+
+    AICWFDBG(LOGINFO, "powerlimit file path:%s \r\n", filename);
+
+    /* load file */
+    size = rwnx_request_firmware_common(rwnx_hw, &dst, filename);
+    if (size <= 0) {
+        AICWFDBG(LOGERROR, "wrong size of cfg file\n");
+        dst = NULL;
+        return 0;
+    }
+
+    AICWFDBG(LOGINFO, "### Load file done: %s, size=%d\n", filename, size);
+
+    /* parsing the file */
+    rwnx_plat_powerlimit_parsing((char *)dst, size, default_ccode);
+
+    rwnx_release_firmware_common(&dst);
+
+    AICWFDBG(LOGINFO, "powerlimit download complete\n\n");
+    return 0;
+}
+#endif
+
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80x2.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80x2.h
new file mode 100644
index 000000000000..dbd4de9a227a
--- /dev/null
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80x2.h
@@ -0,0 +1,9 @@
+#include <linux/types.h>
+
+int rwnx_plat_userconfig_load_8800d80x2(struct rwnx_hw *rwnx_hw);
+#ifdef CONFIG_POWER_LIMIT
+int rwnx_plat_powerlimit_load_8800d80x2(struct rwnx_hw *rwnx_hw);
+#endif
+int aicwf_set_rf_config_8800d80x2(struct rwnx_hw *rwnx_hw, struct mm_set_rf_calib_cfm *cfm);
+
+
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.c
index b4b9eb4bc1fa..f0bad8024058 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.c
@@ -13,10 +13,22 @@
 #endif
 #define RWNX_MAC_PATCH_NAME2_8800DC RWNX_MAC_PATCH_BASE_NAME_8800DC".bin"
 #define RWNX_MAC_PATCH_NAME2_8800DC_U02 RWNX_MAC_PATCH_BASE_NAME_8800DC"_u02.bin"
+#define RWNX_MAC_PATCH_NAME2_8800DC_H_U02 RWNX_MAC_PATCH_BASE_NAME_8800DC"_h_u02.bin"
 
 #define RWNX_MAC_CALIB_BASE_NAME_8800DC        "fmacfw_calib_8800dc"
 #define RWNX_MAC_CALIB_NAME_8800DC_U02          RWNX_MAC_CALIB_BASE_NAME_8800DC"_u02.bin"
-
+#define RWNX_MAC_CALIB_NAME_8800DC_H_U02        RWNX_MAC_CALIB_BASE_NAME_8800DC"_h_u02.bin"
+
+#ifdef CONFIG_LOAD_BT_PATCH_IN_FDRV
+#define FW_8800DC_U02_ADID_ADDR         0x1017d8
+#define FW_RAM_PATCH_BASE_ADDR          0x184000
+#define FW_ADID_BASE_NAME               "fw_adid_8800dc_u02.bin"
+#define FW_PATCH_TABLE_NAME_U02         "fw_patch_table_8800dc_u02.bin"
+#define FW_PATCH_BASE_NAME_U02          "fw_patch_8800dc_u02.bin"
+#define FW_PATCH_TABLE_NAME_U02H        "fw_patch_table_8800dc_u02h.bin"
+#define FW_PATCH_BASE_NAME_U02H         "fw_patch_8800dc_u02h.bin"
+#define AICBT_PT_TAG                    "AICBT_PT_TAG"
+#endif
 #ifdef CONFIG_FOR_IPCAM
 #define RWNX_MAC_PATCH_TABLE_NAME_8800DC "fmacfw_patch_tbl_8800dc_ipc"
 #else
@@ -24,13 +36,112 @@
 #endif
 #define RWNX_MAC_PATCH_TABLE_8800DC RWNX_MAC_PATCH_TABLE_NAME_8800DC ".bin"
 #define RWNX_MAC_PATCH_TABLE_8800DC_U02 RWNX_MAC_PATCH_TABLE_NAME_8800DC "_u02.bin"
+#define RWNX_MAC_PATCH_TABLE_8800DC_H_U02 RWNX_MAC_PATCH_TABLE_NAME_8800DC "_h_u02.bin"
 
 
 #define RWNX_MAC_RF_PATCH_BASE_NAME_8800DC     "fmacfw_rf_patch_8800dc"
 #define RWNX_MAC_RF_PATCH_NAME_8800DC RWNX_MAC_RF_PATCH_BASE_NAME_8800DC".bin"
 #define FW_USERCONFIG_NAME_8800DC         "aic_userconfig_8800dc.txt"
 #define FW_USERCONFIG_NAME_8800DW         "aic_userconfig_8800dw.txt"
+#define FW_POWERLIMIT_NAME_8800DC         "aic_powerlimit_8800dc.txt"
+#define FW_POWERLIMIT_NAME_8800DW         "aic_powerlimit_8800dw.txt"
+
+#ifdef CONFIG_LOAD_BT_PATCH_IN_FDRV
+enum aicbt_patch_table_type {
+    AICBT_PT_NULL = 0x00,
+    AICBT_PT_TRAP,
+    AICBT_PT_B4,
+    AICBT_PT_BTMODE,
+    AICBT_PT_PWRON,
+    AICBT_PT_AF,
+    AICBT_PT_VER,
+    AICBT_PT_MAX,
+};
+
+struct aicbt_patch_table {
+    char     *name;
+    uint32_t type;
+    uint32_t *data;
+    uint32_t len;
+    struct aicbt_patch_table *next;
+};
+
+struct aicbt_info_t {
+    uint32_t btmode;
+    uint32_t btport;
+    uint32_t uart_baud;
+    uint32_t uart_flowctrl;
+    uint32_t lpm_enable;
+    uint32_t txpwr_lvl;
+};
+
+struct aicbsp_info_t {
+    int hwinfo;
+    uint32_t cpmode;
+};
+
+enum aicbsp_cpmode_type {
+    AICBSP_CPMODE_WORK,
+    AICBSP_CPMODE_TEST,
+};
+
+/*  btmode
+ * used for force bt mode,if not AICBSP_MODE_NULL
+ * efuse valid and vendor_info will be invalid, even has beed set valid
+*/
+enum aicbt_btmode_type {
+    AICBT_BTMODE_BT_ONLY_SW = 0x0,    // bt only mode with switch
+    AICBT_BTMODE_BT_WIFI_COMBO,       // wifi/bt combo mode
+    AICBT_BTMODE_BT_ONLY,             // bt only mode without switch
+    AICBT_BTMODE_BT_ONLY_TEST,        // bt only test mode
+    AICBT_BTMODE_BT_WIFI_COMBO_TEST,  // wifi/bt combo test mode
+    AICBT_MODE_NULL = 0xFF,           // invalid value
+};
+
+enum aicbt_btport_type {
+    AICBT_BTPORT_NULL,
+    AICBT_BTPORT_MB,
+    AICBT_BTPORT_UART,
+};
+
+enum aicbt_uart_baud_type {
+    AICBT_UART_BAUD_115200     = 115200,
+    AICBT_UART_BAUD_921600     = 921600,
+    AICBT_UART_BAUD_1_5M       = 1500000,
+    AICBT_UART_BAUD_3_25M      = 3250000,
+};
+
+enum aicbt_uart_flowctrl_type {
+    AICBT_UART_FLOWCTRL_DISABLE = 0x0,    // uart without flow ctrl
+    AICBT_UART_FLOWCTRL_ENABLE,           // uart with flow ctrl
+};
+
+#define AICBSP_HWINFO_DEFAULT       (-1)
+#define AICBSP_CPMODE_DEFAULT       AICBSP_CPMODE_WORK
+#define AICBT_TXPWR_DFT                0x6F2F
+
 
+#define AICBT_BTMODE_DEFAULT        AICBT_BTMODE_BT_WIFI_COMBO
+#define AICBT_BTPORT_DEFAULT        AICBT_BTPORT_MB
+#define AICBT_UART_BAUD_DEFAULT     AICBT_UART_BAUD_1_5M
+#define AICBT_UART_FC_DEFAULT       AICBT_UART_FLOWCTRL_ENABLE
+#define AICBT_LPM_ENABLE_DEFAULT    0
+#define AICBT_TXPWR_LVL_DEFAULT     AICBT_TXPWR_DFT
+
+struct aicbsp_info_t aicbsp_info = {
+    .hwinfo   = AICBSP_HWINFO_DEFAULT,
+    .cpmode   = AICBSP_CPMODE_DEFAULT,
+};
+
+static struct aicbt_info_t aicbt_info = {
+    .btmode        = AICBT_BTMODE_DEFAULT,
+    .btport        = AICBT_BTPORT_DEFAULT,
+    .uart_baud     = AICBT_UART_BAUD_DEFAULT,
+    .uart_flowctrl = AICBT_UART_FC_DEFAULT,
+    .lpm_enable    = AICBT_LPM_ENABLE_DEFAULT,
+    .txpwr_lvl     = AICBT_TXPWR_LVL_DEFAULT,
+};
+#endif
 
 int rwnx_plat_bin_fw_upload_2(struct rwnx_hw *rwnx_hw, u32 fw_addr,
                                char *filename);
@@ -40,6 +151,7 @@ void rwnx_plat_userconfig_parsing(char *buffer, int size);
 void rwnx_release_firmware_common(u32** buffer);
 
 typedef u32 (*array2_tbl_t)[2];
+typedef u32 (*array3_tbl_t)[3];
 
 u32 syscfg_tbl_masked_8800dc[][3] = {
     //#ifdef CONFIG_PMIC_SETTING
@@ -76,11 +188,41 @@ u32 syscfg_tbl_masked_8800dc[][3] = {
     {0x700021D0, ((0x1 << 5) | (0x1 << 6)), ((0x1 << 5) | (0x1 << 6))},
     {0x70001000, ((0x1 << 0) | (0x1 << 20) | (0x1 << 22)),
                  ((0x0 << 0) | (0x1 << 20) | (0x0 << 22))},
+    {0x70001028, (0xf << 2), (0x1 << 2)},
     #endif
     //#endif /* CONFIG_PMIC_SETTING */
     {0x00000000, 0x00000000, 0x00000000}, // last one
 };
 
+u32 syscfg_tbl_masked_8800dc_h[][3] = {
+    {0x7000216C, ((0x3 << 2) | (0x3 << 4)), ((0x2 << 2) | (0x2 << 4))}, // pmic_pmu_init
+    {0x70002138, (0xFF << 0), (0xFF << 0)},
+    {0x7000213C, (0xFF << 0), (0xFF << 0)},
+    {0x70002144, (0xFF << 0), (0xFF << 0)},
+    {0x700021BC, (0x3 << 2), (0x1 << 2)},
+    {0x70002118, ((0x7 << 4) | (0x1 << 7)), ((0x2 << 4) | (0x1 << 7))},
+    {0x70002104, ((0x3F << 0) | (0x1 << 6)), ((0x2 << 0) | (0x1 << 6))},
+    {0x7000210C, ((0x3F << 0) | (0x1 << 6)), ((0x2 << 0) | (0x1 << 6))},
+    {0x70002170, (0xF << 0), (0x1 << 0)},
+    {0x70002190, (0x3F << 0), (24 << 0)},
+    {0x700021CC, ((0x7 << 4) | (0x1 << 7)), ((0x0 << 4) | (0x0 << 7))},
+    {0x700010A0, (0x1 << 11), (0x1 << 11)},
+    //{0x70001034, ((0x1 << 20) | (0x7 << 26)), ((0x0 << 20) | (0x2 << 26))},
+    {0x70001038, (0x1 << 8), (0x1 << 8)},
+    {0x70001094, (0x3 << 2), (0x0 << 2)},
+    {0x700021D0, ((0x1 << 5) | (0x1 << 6)), ((0x1 << 5) | (0x1 << 6))},
+    #if defined(CONFIG_VRF_DCDC_MODE)
+    {0x70001000, ((0x1 << 0) | (0x1 << 20) | (0x1 << 22)),
+                 ((0x1 << 0) | (0x1 << 20) | (0x0 << 22))},
+    #else
+    {0x70001000, ((0x1 << 0) | (0x1 << 20) | (0x1 << 22)),
+                 ((0x0 << 0) | (0x1 << 20) | (0x0 << 22))},
+    #endif
+    {0x70001028, (0xf << 2), (0x1 << 2)},
+
+    {0x00000000, 0x00000000, 0x00000000}, // last one
+};
+
 u32 syscfg_tbl_masked_8800dc_u01[][3] = {
     //#ifdef CONFIG_PMIC_SETTING
     {0x70001000, (0x1 << 16), (0x1 << 16)}, // for low temperature
@@ -1311,6 +1453,7 @@ uint32_t agc_cfg_ram[] = {
     0x00000000
 };
 
+#if !defined(CONFIG_EXT_FEM_8800DCDW)
 uint32_t txgain_map[96] =  {
 #ifdef CONFIG_FPGA_VERIFICATION
     0x20c0c971,
@@ -1448,8 +1591,8 @@ uint32_t txgain_map[96] =  {
     0x00ffc88b,
     0x00ffc979,
     0x00ffc989,
-    0x00ffca7d,
-    0x00ffca88,
+    0x00ffcc4b,
+    0x00ffcc54,
     0x00ffcc5e,
     0x00ffcc69,
     0x00ffcc78,
@@ -1481,18 +1624,18 @@ uint32_t txgain_map[96] =  {
     0x00ffc88b,
     0x00ffc979,
     0x00ffc989,
-    0x00ffca7d,
-    0x00ffca88,
+    0x00ffcc4b,
+    0x00ffcc54,
     0x00ffcc5e,
     0x00ffcc69,
     0x00ffcc78,
     0x00ffcc85,
     0x00ffcd70,
     0x00ffcd80,
-    0x00ffce70,
-    0x00ffce80,
-    0x00ffce93,
-    0x00ffcf90,
+    0x00ffcd90,
+    0x00ffcf68,
+    0x00ffcf75,
+    0x00ffcf83,
     0x00ffc080,
     0x00ffc090,
     0x00ffc180,
@@ -1512,6 +1655,317 @@ uint32_t txgain_map[96] =  {
 #endif
 };
 
+const uint32_t txgain_map_h[96] =
+{
+    //11b
+    0xffd888, //11
+    0xffd979, //12
+    0xffd988, //13
+    0xffda79, //14
+    0xffda88, //15
+    0xffdb79, //16
+    0xffdb88, //17
+    0xffdc72, //18
+    0xffdc80, //19
+    0xffdd80, //20
+    0xffde66, //21
+    0xffde72, //22
+    0xffde80, //23
+    0xffdf79, //24
+    0xffdf88, //25
+    0xffdf98, //26
+    0xffd079, //-5
+    0xffd088, //-4
+    0xffd179, //-3
+    0xffd188, //-2
+    0xffd288, //-1
+    0xffd36c, //0
+    0xffd379, //1
+    0xffd388, //2
+    0xffd479, //3
+    0xffd488, //4
+    0xffd579, //5
+    0xffd588, //6
+    0xffd679, //7
+    0xffd688, //8
+    0xffd779, //9
+    0xffd879, //10
+    //high
+    0xffc879, //8
+    0xffc96b, //9
+    0xffc979, //10
+    0xffcc45, //11
+    0xffcc4d, //12
+    0xffcc56, //13
+    0xffcc60, //14
+    0xffcc6b, //15
+    0xffcc79, //16
+    0xffcd72, //17
+    0xffce60, //18
+    0xffce72, //19
+    0xffcf72, //20
+    0xffcf80, //21
+    0xffcf90, //22
+    0xffcf90, //23
+    0xffc079, //-8
+    0xffc16b, //-7
+    0xffc179, //-6
+    0xffc26b, //-5
+    0xffc279, //-4
+    0xffc36b, //-3
+    0xffc379, //-2
+    0xffc46b, //-1
+    0xffc479, //0
+    0xffc56b, //1
+    0xffc579, //2
+    0xffc66b, //3
+    0xffc679, //4
+    0xffc76b, //5
+    0xffc779, //6
+    0xffc86b, //7
+    //low
+    0xffc879, //8
+    0xffc96b, //9
+    0xffc979, //10
+    0xffcc45, //11
+    0xffcc4d, //12
+    0xffcc56, //13
+    0xffcc60, //14
+    0xffcc6b, //15
+    0xffcc79, //16
+    0xffcd72, //17
+    0xffcf5b, //18
+    0xffcf66, //19
+    0xffcf72, //20
+    0xffcf80, //21
+    0xffcf90, //22
+    0xffcf90, //23
+    0xffc079, //-8
+    0xffc16b, //-7
+    0xffc179, //-6
+    0xffc26b, //-5
+    0xffc279, //-4
+    0xffc36b, //-3
+    0xffc379, //-2
+    0xffc46b, //-1
+    0xffc479, //0
+    0xffc56b, //1
+    0xffc579, //2
+    0xffc66b, //3
+    0xffc679, //4
+    0xffc76b, //5
+    0xffc779, //6
+    0xffc86b, //7
+};
+
+#else /* #ifdef CONFIG_EXT_FEM_8800DCDW */
+const uint32_t txgain_map_femkct[96] =
+{
+    //11b
+    0x00ffd780,//15
+    0x00ffd872,//16
+    0x00ffd880,//17
+    0x00ffd972,//18
+    0x00ffd980,//19
+    0x00ffda72,//20
+    0x00ffda80,//21
+    0x00ffdb72,//22
+    0x00ffdb80,//23
+    0x00ffdc72,//24
+    0x00ffdc80,//25
+    0x00ffdd72,//26
+    0x00ffdd80,//27
+    0x00ffde72,//28
+    0x00ffde80,//29
+    0x00ffdf72,//30
+    0x00ffd072,//-1
+    0x00ffd072,//0
+    0x00ffd080,//1
+    0x00ffd172,//2
+    0x00ffd180,//3
+    0x00ffd272,//4
+    0x00ffd280,//5
+    0x00ffd36d,//6
+    0x00ffd379,//7
+    0x00ffd46d,//8
+    0x00ffd479,//9
+    0x00ffd572,//10
+    0x00ffd580,//11
+    0x00ffd672,//12
+    0x00ffd680,//13
+    0x00ffd772,//14
+    //high
+    0x00ffc872,//11
+    0x00ffc880,//12
+    0x00ffc972,//13
+    0x00ffc980,//14
+    0x00ffca72,//15
+    0x00ffca80,//16
+    0x00ffcb72,//17
+    0x00ffcb80,//18
+    0x00ffcc72,//19
+    0x00ffcc80,//20
+    0x00ffcd72,//21
+    0x00ffcd80,//22
+    0x00ffce72,//23
+    0x00ffce80,//24
+    0x00ffcf72,//25
+    0x00ffcf80,//26
+    0x00ffc072,//-5
+    0x00ffc080,//-4
+    0x00ffc172,//-3
+    0x00ffc180,//-2
+    0x00ffc272,//-1
+    0x00ffc280,//0
+    0x00ffc372,//1
+    0x00ffc380,//2
+    0x00ffc472,//3
+    0x00ffc480,//4
+    0x00ffc572,//5
+    0x00ffc580,//6
+    0x00ffc672,//7
+    0x00ffc680,//8
+    0x00ffc772,//9
+    0x00ffc780,//10
+    //low
+    0x00ffc872,//11
+    0x00ffc880,//12
+    0x00ffc972,//13
+    0x00ffc980,//14
+    0x00ffca72,//15
+    0x00ffca80,//16
+    0x00ffcb72,//17
+    0x00ffcb80,//18
+    0x00ffcc72,//19
+    0x00ffcc80,//20
+    0x00ffcd72,//21
+    0x00ffcd80,//22
+    0x00ffce72,//23
+    0x00ffce80,//24
+    0x00ffcf72,//26
+    0x00ffcf80,//27
+    0x00ffc072,//-5
+    0x00ffc080,//-4
+    0x00ffc172,//-3
+    0x00ffc180,//-2
+    0x00ffc272,//-1
+    0x00ffc280,//0
+    0x00ffc372,//1
+    0x00ffc380,//2
+    0x00ffc472,//3
+    0x00ffc480,//4
+    0x00ffc572,//5
+    0x00ffc580,//6
+    0x00ffc672,//7
+    0x00ffc680,//8
+    0x00ffc772,//9
+    0x00ffc780,//10
+};
+
+const uint32_t txgain_map_femkct_h[96] =
+{
+    //11b
+    0x00ffd872,//15
+    0x00ffd880,//16
+    0x00ffd972,//17
+    0x00ffd980,//18
+    0x00ffd990,//19
+    0x00ffda72,//20
+    0x00ffda80,//21
+    0x00ffdb72,//22
+    0x00ffdb80,//23
+    0x00ffdc72,//24
+    0x00ffdc80,//25
+    0x00ffdd72,//26
+    0x00ffdd80,//27
+    0x00ffde72,//28
+    0x00ffde80,//29
+    0x00ffdf72,//30
+    0x00ffd072,//-1
+    0x00ffd072,//0
+    0x00ffd080,//1
+    0x00ffd172,//2
+    0x00ffd180,//3
+    0x00ffd272,//4
+    0x00ffd280,//5
+    0x00ffd379,//6
+    0x00ffd46d,//7
+    0x00ffd479,//8
+    0x00ffd572,//9
+    0x00ffd580,//10
+    0x00ffd672,//11
+    0x00ffd680,//12
+    0x00ffd772,//13
+    0x00ffd780,//14
+    //high
+    0x00ffc880,//11
+    0x00ffc972,//12
+    0x00ffc980,//13
+    0x00ffca72,//14
+    0x00ffca80,//15
+    0x00ffcb72,//16
+    0x00ffcb80,//17
+    0x00ffcc72,//18
+    0x00ffcc80,//19
+    0x00ffcc90,//20
+    0x00ffcd72,//21
+    0x00ffcd80,//22
+    0x00ffce72,//23
+    0x00ffce80,//24
+    0x00ffcf72,//25
+    0x00ffcf80,//26
+    0x00ffc080,//-5
+    0x00ffc172,//-4
+    0x00ffc180,//-3
+    0x00ffc272,//-2
+    0x00ffc280,//-1
+    0x00ffc372,//0
+    0x00ffc380,//1
+    0x00ffc472,//2
+    0x00ffc480,//3
+    0x00ffc572,//4
+    0x00ffc580,//5
+    0x00ffc672,//6
+    0x00ffc680,//7
+    0x00ffc772,//8
+    0x00ffc780,//9
+    0x00ffc872,//10
+    //low
+    0x00ffc880,//11
+    0x00ffc972,//12
+    0x00ffc980,//13
+    0x00ffca72,//14
+    0x00ffca80,//15
+    0x00ffcb72,//16
+    0x00ffcb80,//17
+    0x00ffcc72,//18
+    0x00ffcc80,//19
+    0x00ffcc90,//20
+    0x00ffcd72,//21
+    0x00ffcd80,//22
+    0x00ffce72,//23
+    0x00ffce80,//24
+    0x00ffcf72,//25
+    0x00ffcf80,//26
+    0x00ffc080,//-5
+    0x00ffc172,//-4
+    0x00ffc180,//-3
+    0x00ffc272,//-2
+    0x00ffc280,//-1
+    0x00ffc372,//0
+    0x00ffc380,//1
+    0x00ffc472,//2
+    0x00ffc480,//3
+    0x00ffc572,//4
+    0x00ffc580,//5
+    0x00ffc672,//6
+    0x00ffc680,//7
+    0x00ffc772,//8
+    0x00ffc780,//9
+    0x00ffc872,//10
+};
+#endif
+
 u32 patch_tbl_func[][2] =
 {
     {0x00110054, 0x0018186D}, // same as jump_tbl idx 168
@@ -1525,6 +1979,7 @@ u32 patch_tbl_rf_func[][2] =
 };
 
 
+#if !defined(CONFIG_EXT_FEM_8800DCDW)
 u32 wifi_txgain_table_24g_8800dcdw[32] =
 {
     0xA4B22189, //index 0
@@ -1563,40 +2018,186 @@ u32 wifi_txgain_table_24g_8800dcdw[32] =
 
 u32 wifi_txgain_table_24g_1_8800dcdw[32] =
 {
-    0x090E2011, //index 0
+    0x096E2011, //index 0
     0x00004001,
-    0x090E2015, //index 1
+    0x096E2015, //index 1
     0x00004001,
-    0x090E201B, //index 2
+    0x096E201B, //index 2
     0x00004001,
-    0x110E2018, //index 3
+    0x116E2018, //index 3
     0x00004001,
-    0x110E201E, //index 4
+    0x116E201E, //index 4
     0x00004001,
-    0x110E2023, //index 5
+    0x116E2023, //index 5
     0x00004001,
-    0x190E2021, //index 6
+    0x196E2021, //index 6
     0x00004001,
-    0x190E202B, //index 7
+    0x196E202B, //index 7
     0x00004001,
-    0x210E202B, //index 8
+    0x216E202B, //index 8
     0x00004001,
-    0x230E2027, //index 9
+    0x236E2027, //index 9
     0x00004001,
-    0x230E2031, //index 10
+    0x236E2031, //index 10
     0x00004001,
-    0x240E2039, //index 11
+    0x246E2039, //index 11
     0x00004001,
-    0x260E2039, //index 12
+    0x26922039, //index 12
     0x00004001,
-    0x2E0E203F, //index 13
+    0x2E92203F, //index 13
     0x00004001,
-    0x368E203F, //index 14
+    0x3692203F, //index 14
     0x00004001,
-    0x3EF2203F, //index 15
-    0x00004001
+    0x3FF2203F, //index 15
+    0x00004001,
+};
+
+u32 wifi_txgain_table_24g_8800dcdw_h[32] =
+{
+    0xA55629C9, //index 0
+    0x00005825,
+    0xAE5629C9, //index 1
+    0x00005825,
+    0xAD5629CD, //index 2
+    0x00005825,
+    0xAD5629D1, //index 3
+    0x00005825,
+    0xAD5629D7, //index 4
+    0x00005825,
+    0xAD5629DE, //index 5
+    0x00005825,
+    0xAD5629E6, //index 6
+    0x00005825,
+    0xBD5629E6, //index 7
+    0x00005825,
+    0xBD5629F0, //index 8
+    0x00005825,
+    0xCD5629F0, //index 9
+    0x00005825,
+    0xE55629F0, //index 10
+    0x00005825,
+    0xE55629FF, //index 11
+    0x00005825,
+    0xE55629FF, //index 12
+    0x00002825,
+    0xE75629FF, //index 13
+    0x00002825,
+    0xFF5629FF, //index 14
+    0x00001825,
+    0xFF5628FF, //index 15
+    0x00001025,
+};
+
+u32 wifi_txgain_table_24g_1_8800dcdw_h[32] =
+{
+    0x941A2048, //index 0
+    0x00001825,
+    0x961A2048, //index 1
+    0x00001825,
+    0x9D1A2048, //index 2
+    0x00001825,
+    0x9A1A204F, //index 3
+    0x00001825,
+    0x961A204F, //index 4
+    0x00001825,
+    0x9A1A2057, //index 5
+    0x00001825,
+    0x9C1A2057, //index 6
+    0x00001825,
+    0xA31A205B, //index 7
+    0x00001825,
+    0xAB1A205B, //index 8
+    0x00001825,
+    0xAD1A205B, //index 9
+    0x00001825,
+    0xA71A2064, //index 10
+    0x00001825,
+    0xAD1A2070, //index 11
+    0x00001825,
+    0xAD72207F, //index 12
+    0x00001825,
+    0xBCAE207F, //index 13
+    0x00001825,
+    0xBFB2207F, //index 14
+    0x00001825,
+    0xD73A207F, //index 15
+    0x00001825,
 };
 
+#else /* #ifdef CONFIG_EXT_FEM_8800DCDW */
+// ofdm
+uint32_t wifi_txgain_table_24g_8800dcdw_femkct[32] = {
+    0x919221C2, //index 0
+    0x00007825,
+    0x899221C3, //index 1
+    0x00007825,
+    0x8B9221C3, //index 2
+    0x00007825,
+    0x929221C3, //index 3
+    0x00007825,
+    0x949221C4, //index 4
+    0x00007825,
+    0x969221C4, //index 5
+    0x00007825,
+    0x949221C6, //index 6
+    0x00007825,
+    0x949221C8, //index 7
+    0x00007825,
+    0x9C9221C8, //index 8
+    0x00007825,
+    0x9C9221CA, //index 9
+    0x00007825,
+    0x9C9221CB, //index 10
+    0x00007825,
+    0x939221D5, //index 11
+    0x00007825,
+    0x9B9221D7, //index 12
+    0x00007825,
+    0xA49221D7, //index 13
+    0x00007825,
+    0xA79221D7, //index 14
+    0x00007825,
+    0xBD9221D7, //index 15
+    0x00007825,
+};
+
+// 11b
+uint32_t wifi_txgain_table_24g_1_8800dcdw_femkct[32] = {
+    0x836E20C2, //index 0
+    0x00003024,
+    0x856E20C2, //index 1
+    0x00003024,
+    0x826E20C3, //index 2
+    0x00003024,
+    0x836E20C3, //index 3
+    0x00003024,
+    0x856E20C3, //index 4
+    0x00003024,
+    0x876E20C3, //index 5
+    0x00003024,
+    0x8B6E20C3, //index 6
+    0x00003024,
+    0x926E20C4, //index 7
+    0x00003024,
+    0x9A6E20C4, //index 8
+    0x00003024,
+    0x936E20C5, //index 9
+    0x00003024,
+    0x936E20C7, //index 10
+    0x00003024,
+    0xA16E20C8, //index 11
+    0x00003024,
+    0xA16E20CA, //index 12
+    0x00003024,
+    0xA26E20CB, //index 13
+    0x00003024,
+    0xAA6E20CD, //index 14
+    0x00003024,
+    0xAC7220CF, //index 15
+    0x00003024,
+};
+#endif
+
 u32 wifi_rxgain_table_24g_20m_8800dcdw[64] = {
     0x82f282d1,//index 0
     0x9591a324,
@@ -1659,7 +2260,7 @@ u32 wifi_rxgain_table_24g_20m_8800dcdw[64] = {
     0x80808419,
     0x000000f0,
     0x0ef29ae6,//index 15
-    0x959f592c,//////0x959f5924,           //loft [35:34]=3
+    0x959f5924,           //loft [35:34]=3
     0x80808419,
     0x000000f0
 };
@@ -1739,6 +2340,231 @@ u32 adaptivity_patch_tbl[][2] = {
 };
 //adap test
 
+#ifdef CONFIG_LOAD_BT_PATCH_IN_FDRV
+int rwnx_get_patch_addr_from_patch_table(struct rwnx_hw *rwnx_hw, char *filename, uint32_t *fw_patch_base_addr)
+{
+    int size;
+    int ret = 0;
+    uint8_t *rawdata=NULL;
+    uint8_t *p = NULL;
+    uint32_t *data = NULL;
+    uint32_t type = 0, len = 0;
+    int j;
+
+    /* load aic firmware */
+    size = rwnx_request_firmware_common(rwnx_hw, (u32 **)&rawdata, filename);
+
+    /* Copy the file on the Embedded side */
+    printk("### Upload %s fw_patch_table, size=%d\n", filename, size);
+
+    if (size <= 0) {
+        printk("wrong size of firmware file\n");
+        ret = -1;
+        goto err;
+    }
+
+    p = rawdata;
+
+    if (memcmp(p, AICBT_PT_TAG, sizeof(AICBT_PT_TAG) < 16 ? sizeof(AICBT_PT_TAG) : 16)) {
+        printk("TAG err\n");
+        ret = -1;
+        goto err;
+    }
+    p += 16;
+
+    while (p - rawdata < size) {
+        printk("size = %d  p - rawdata = 0x%0lx \r\n", size, p - rawdata);
+        p += 16;
+
+        type = *(uint32_t *)p;
+        p += 4;
+
+        len = *(uint32_t *)p;
+        p += 4;
+        printk("cur->type %x, len %d\n", type, len);
+
+        if(type >= 1000 ) {//Temp Workaround
+            len = 0;
+        }else{
+            data = (uint32_t *)p;
+            if (type == AICBT_PT_NULL) {
+                *(fw_patch_base_addr) = *(data + 3);
+                printk("addr found %x\n", *(fw_patch_base_addr));
+                for (j = 0; j < len; j++) {
+                    printk("addr %x\n", *(data+j));
+                }
+                break;
+            }
+            p += len * 8;
+        }
+    }
+
+    vfree(rawdata);
+    return ret;
+err:
+    //aicbt_patch_table_free(&head);
+
+    if (rawdata){
+        vfree(rawdata);
+    }
+    return ret;
+}
+
+int rwnx_patch_table_free(struct aicbt_patch_table **head)
+{
+	struct aicbt_patch_table *p = *head, *n = NULL;
+	while (p) {
+		n = p->next;
+		vfree(p->name);
+		vfree(p->data);
+		vfree(p);
+		p = n;
+	}
+	*head = NULL;
+	return 0;
+}
+
+int rwnx_patch_table_load(struct rwnx_hw *rwnx_hw, struct aicbt_patch_table *_head)
+{
+	struct aicbt_patch_table *head, *p;
+	int ret = 0, i;
+	uint32_t *data = NULL;
+
+	head = _head;
+	for (p = head; p != NULL; p = p->next) {
+		data = p->data;
+		if(AICBT_PT_BTMODE == p->type){
+			*(data + 1)  = aicbsp_info.hwinfo < 0;
+			*(data + 3) = aicbsp_info.hwinfo;
+			*(data + 5)  = aicbsp_info.cpmode;
+
+			*(data + 7) = aicbt_info.btmode;
+			*(data + 9) = aicbt_info.btport;
+			*(data + 11) = aicbt_info.uart_baud;
+			*(data + 13) = aicbt_info.uart_flowctrl;
+			*(data + 15) = aicbt_info.lpm_enable;
+			*(data + 17) = aicbt_info.txpwr_lvl;
+
+		}
+		if (p->type == AICBT_PT_NULL || p->type == AICBT_PT_PWRON) {
+            continue;
+        }
+
+
+        if (p->type == AICBT_PT_VER) {
+            char *data_s = (char *)p->data;
+            printk("patch version %s\n", data_s);
+            continue;
+        }
+
+        if (p->len == 0) {
+            printk("len is 0\n");
+            continue;
+        }
+
+		for (i = 0; i < p->len; i++) {
+			ret = rwnx_send_dbg_mem_write_req(rwnx_hw, *data, *(data + 1));
+			if (ret != 0)
+				return ret;
+			data += 2;
+		}
+
+	}
+	rwnx_patch_table_free(&head);
+	return 0;
+}
+
+
+
+
+int rwnx_patch_table_download(struct rwnx_hw *rwnx_hw, char *filename)
+{
+    struct aicbt_patch_table *head = NULL;
+    struct aicbt_patch_table *new = NULL;
+    struct aicbt_patch_table *cur = NULL;
+        int size;
+    int ret = 0;
+    uint8_t *rawdata=NULL;
+    uint8_t *p = NULL;
+
+    /* load aic firmware */
+    size = rwnx_request_firmware_common(rwnx_hw, (u32 **)&rawdata, filename);
+
+    /* Copy the file on the Embedded side */
+    printk("### Upload %s fw_patch_table, size=%d\n", filename, size);
+
+    if (size <= 0) {
+        printk("wrong size of firmware file\n");
+        ret = -1;
+        goto err;
+    }
+
+    p = rawdata;
+
+    if (memcmp(p, AICBT_PT_TAG, sizeof(AICBT_PT_TAG) < 16 ? sizeof(AICBT_PT_TAG) : 16)) {
+        printk("TAG err\n");
+        ret = -1;
+        goto err;
+    }
+    p += 16;
+
+    while (p - rawdata < size) {
+        printk("size = %d  p - rawdata = 0x%0lx \r\n", size, p - rawdata);
+        new = (struct aicbt_patch_table *)vmalloc(sizeof(struct aicbt_patch_table));
+        memset(new, 0, sizeof(struct aicbt_patch_table));
+        if (head == NULL) {
+            head = new;
+            cur  = new;
+        } else {
+            cur->next = new;
+            cur = cur->next;
+        }
+
+        cur->name = (char *)vmalloc(sizeof(char) * 16);
+        memset(cur->name, 0, sizeof(char) * 16);
+        memcpy(cur->name, p, 16);
+        p += 16;
+
+        cur->type = *(uint32_t *)p;
+        p += 4;
+
+        cur->len = *(uint32_t *)p;
+        p += 4;
+        printk("cur->type %x, len %d\n", cur->type, cur->len);
+
+        if((cur->type )  >= 1000 ) {//Temp Workaround
+            cur->len = 0;
+        }else{
+            cur->data = (uint32_t *)vmalloc(sizeof(uint8_t) * cur->len * 8);
+            memset(cur->data, 0, sizeof(uint8_t) * cur->len * 8);
+            memcpy(cur->data, p, cur->len * 8);
+            p += cur->len * 8;
+        }
+    }
+
+    vfree(rawdata);
+    rwnx_patch_table_load(rwnx_hw, head);
+    printk("fw_patch_table download complete\n\n");
+
+    return ret;
+err:
+    //aicbt_patch_table_free(&head);
+
+    if (rawdata){
+        vfree(rawdata);
+    }
+    return ret;
+}
+#endif
+
+#ifdef CONFIG_DPD
+rf_misc_ram_lite_t dpd_res;
+#endif
+
+#ifdef CONFIG_LOFT_CALIB
+rf_misc_ram_lite_t loft_res_local;
+#endif
+
 int aicwf_patch_table_load(struct rwnx_hw *rwnx_hw, char *filename)
 {
     int err = 0;
@@ -1798,6 +2624,53 @@ int aicwf_patch_table_load(struct rwnx_hw *rwnx_hw, char *filename)
 
 }
 
+#define PATCH_VARGRP_MAGIC_NUM          0x47564150
+#define USER_CHAN_MAX_TXPWR_EN_FLAG     (0x01U << 1)
+
+int aicwf_patch_var_config_8800dc(struct rwnx_hw *rwnx_hw)
+{
+    int ret = 0;
+    uint32_t rd_patch_addr, rd_var_magic_addr, rd_ext_flags_addr;
+    uint32_t rd_ext_flags_val, wr_ext_flags_val;
+    struct dbg_mem_read_cfm cfm;
+    if (chip_sub_id != 2) {
+        AICWFDBG(LOGERROR, "unsupport sub_id: %d\r\n", chip_sub_id);
+        return 0;
+    }
+    rd_patch_addr = ROM_FMAC_PATCH_ADDR;
+    rd_var_magic_addr = rd_patch_addr;
+    ret = rwnx_send_dbg_mem_read_req(rwnx_hw, rd_var_magic_addr, &cfm);
+    if (ret) {
+        AICWFDBG(LOGERROR, "var_magic rd fail: %d\r\n", ret);
+        return ret;
+    }
+    if (cfm.memdata != PATCH_VARGRP_MAGIC_NUM) {
+        AICWFDBG(LOGINFO, "old patch file: %s\r\n", RWNX_MAC_PATCH_NAME2_8800DC_H_U02);
+        return 0;
+    }
+    rd_ext_flags_addr = rd_patch_addr + 4;
+    ret = rwnx_send_dbg_mem_read_req(rwnx_hw, rd_ext_flags_addr, &cfm);
+    if (ret) {
+        AICWFDBG(LOGERROR, "ext_flags rd fail: %d\r\n", ret);
+        return ret;
+    }
+    rd_ext_flags_val = cfm.memdata;
+    wr_ext_flags_val = cfm.memdata;
+    AICWFDBG(LOGINFO, "rd ext_flags: 0x%x\r\n", rd_ext_flags_val);
+    #ifdef CONFIG_POWER_LIMIT
+    wr_ext_flags_val = rd_ext_flags_val | USER_CHAN_MAX_TXPWR_EN_FLAG;
+    #endif
+    if (wr_ext_flags_val != rd_ext_flags_val) {
+        ret = rwnx_send_dbg_mem_write_req(rwnx_hw, rd_ext_flags_addr, wr_ext_flags_val);
+        if (ret) {
+            AICWFDBG(LOGERROR, "ext_flags wr fail: %d\r\n", ret);
+            return ret;
+        }
+        AICWFDBG(LOGINFO, "wr ext_flags: 0x%x\r\n", wr_ext_flags_val);
+    }
+    return ret;
+}
+
 //adap test
 extern int get_adap_test(void);
 //adap test
@@ -1828,7 +2701,7 @@ void aicwf_patch_config_8800dc(struct rwnx_hw *rwnx_hw)
         u32 patch_tbl_wifisetting_num = sizeof(patch_tbl_wifisetting)/sizeof(u32)/2;
         u32 ldpc_cfg_size = sizeof(ldpc_cfg_ram);
         u32 agc_cfg_size = sizeof(agc_cfg_ram);
-        u32 txgain_cfg_size = sizeof(txgain_map);
+        u32 txgain_cfg_size, *txgain_cfg_array;
 		u32 jump_tbl_size = 0;
 		u32 patch_tbl_func_num = 0;
 
@@ -1927,7 +2800,24 @@ void aicwf_patch_config_8800dc(struct rwnx_hw *rwnx_hw)
         }
 
         #if !defined(CONFIG_FPGA_VERIFICATION)
-        ret = rwnx_send_dbg_mem_block_write_req(rwnx_hw, txgain_cfg_addr, txgain_cfg_size, txgain_map);
+        if ((IS_CHIP_ID_H())) {
+            #if defined(CONFIG_EXT_FEM_8800DCDW)
+            txgain_cfg_size = sizeof(txgain_map_femkct_h);
+            txgain_cfg_array = (u32 *)txgain_map_femkct_h;
+            #else
+            txgain_cfg_size = sizeof(txgain_map_h);
+            txgain_cfg_array = (u32 *)txgain_map_h;
+            #endif
+        } else {
+            #if defined(CONFIG_EXT_FEM_8800DCDW)
+            txgain_cfg_size = sizeof(txgain_map_femkct);
+            txgain_cfg_array = (u32 *)txgain_map_femkct;
+            #else
+            txgain_cfg_size = sizeof(txgain_map);
+            txgain_cfg_array = (u32 *)txgain_map;
+            #endif
+        }
+        ret = rwnx_send_dbg_mem_block_write_req(rwnx_hw, txgain_cfg_addr, txgain_cfg_size, txgain_cfg_array);
         if (ret) {
             AICWFDBG(LOGERROR, "txgain upload fail: %x, err:%d\r\n", txgain_cfg_addr, ret);
         }
@@ -1944,18 +2834,28 @@ void aicwf_patch_config_8800dc(struct rwnx_hw *rwnx_hw)
 	                AICWFDBG(LOGERROR, "patch_tbl_func %x write fail\n", patch_tbl_func_base[cnt][0]);
 	            }
 	        }
-		}
-		else{
-			ret = aicwf_patch_table_load(rwnx_hw, RWNX_MAC_PATCH_TABLE_8800DC_U02);
-			if(ret){
-				printk("patch_tbl upload fail: err:%d\r\n", ret);
-			}
+        } else if (chip_sub_id == 1) {
+            ret = aicwf_patch_table_load(rwnx_hw, RWNX_MAC_PATCH_TABLE_8800DC_U02);
+            if(ret){
+                printk("patch_tbl upload fail: err:%d\r\n", ret);
+            }
 #ifdef CONFIG_FOR_IPCAM
             if ((ret = rwnx_send_dbg_mem_write_req(rwnx_hw, 0x00111944, 0x00000101))) {
                 AICWFDBG(LOGERROR, "patch_tbl_func %x write fail\n", patch_tbl_func_base[cnt][0]);
             }
 #endif
-		}
+        } else if (chip_sub_id == 2) {
+            ret = aicwf_patch_table_load(rwnx_hw, RWNX_MAC_PATCH_TABLE_8800DC_H_U02);
+            if(ret){
+                printk("patch_tbl upload fail: err:%d\r\n", ret);
+            }
+            ret = aicwf_patch_var_config_8800dc(rwnx_hw);
+            if (ret) {
+                printk("patch_var cfg fail: err:%d\r\n", ret);
+            }
+        } else {
+            printk("unsupported id: %d\n", chip_sub_id);
+        }
 
         #endif
     } else {
@@ -1986,11 +2886,30 @@ int aicwf_set_rf_config_8800dc(struct rwnx_hw *rwnx_hw, struct mm_set_rf_calib_c
 
 
 	if (testmode == FW_NORMAL_MODE) {
-		if ((ret = rwnx_send_rf_config_req(rwnx_hw, 0,	1, (u8_l *)wifi_txgain_table_24g_8800dcdw, 128)))
-			return -1;
-
-        if ((ret = rwnx_send_rf_config_req(rwnx_hw, 16,	1, (u8_l *)wifi_txgain_table_24g_1_8800dcdw, 128)))
-			return -1;
+        #if !defined(CONFIG_EXT_FEM_8800DCDW)
+        if (IS_CHIP_ID_H()) {
+            if ((ret = rwnx_send_rf_config_req(rwnx_hw, 0,    1, (u8_l *)wifi_txgain_table_24g_8800dcdw_h, 128)))
+                return -1;
+            if ((ret = rwnx_send_rf_config_req(rwnx_hw, 16,    1, (u8_l *)wifi_txgain_table_24g_1_8800dcdw_h, 128)))
+                return -1;
+        } else {
+            if ((ret = rwnx_send_rf_config_req(rwnx_hw, 0,    1, (u8_l *)wifi_txgain_table_24g_8800dcdw, 128)))
+                return -1;
+            if ((ret = rwnx_send_rf_config_req(rwnx_hw, 16,    1, (u8_l *)wifi_txgain_table_24g_1_8800dcdw, 128)))
+                return -1;
+        }
+        #else /* #ifdef CONFIG_EXT_FEM_8800DCDW */
+        {
+            ret = rwnx_send_rf_config_req(rwnx_hw, 0,    1, (u8_l *)wifi_txgain_table_24g_8800dcdw_femkct, 128);
+            if (ret) {
+                return -1;
+            }
+            ret = rwnx_send_rf_config_req(rwnx_hw, 16,    1, (u8_l *)wifi_txgain_table_24g_1_8800dcdw_femkct, 128);
+            if (ret) {
+                return -1;
+            }
+        }
+        #endif
 
 		if ((ret = rwnx_send_rf_config_req(rwnx_hw, 0,	0, (u8_l *)wifi_rxgain_table_24g_20m_8800dcdw, 256)))
 			return -1;
@@ -2002,21 +2921,48 @@ int aicwf_set_rf_config_8800dc(struct rwnx_hw *rwnx_hw, struct mm_set_rf_calib_c
 			return -1;
 		}
 	} else if (testmode == FW_RFTEST_MODE) {
-#ifdef CONFIG_DPD
-		if (is_file_exist(FW_DPDRESULT_NAME_8800DC) == 1) {
-			AICWFDBG(LOGINFO, "%s load dpd bin\n", __func__);
-			ret = aicwf_dpd_result_load_8800dc(rwnx_hw);
-			if (ret) {
-				AICWFDBG(LOGINFO, "load dpd bin fail: %d\n", ret);
-				return ret;
-			}
-			ret = rwnx_send_rf_calib_req(rwnx_hw, cfm);
-			if (ret) {
-				AICWFDBG(LOGINFO, "rf calib req fail: %d\n", ret);
-				return ret;
-			}
-		}
-#endif
+        if (chip_sub_id >= 1) {
+            #ifdef CONFIG_DPD
+            #ifndef CONFIG_FORCE_DPD_CALIB
+            if (is_file_exist(FW_DPDRESULT_NAME_8800DC) == 1) {
+                AICWFDBG(LOGINFO, "%s load dpd bin\n", __func__);
+                ret = aicwf_dpd_result_load_8800dc(rwnx_hw, &dpd_res);
+                if (ret) {
+                    AICWFDBG(LOGINFO, "load dpd bin fail: %d\n", ret);
+                    return ret;
+                }
+            }
+            #endif
+            if (dpd_res.bit_mask[1]) {
+                ret = aicwf_dpd_result_apply_8800dc(rwnx_hw, &dpd_res);
+                if (ret) {
+                    AICWFDBG(LOGINFO, "apply dpd bin fail: %d\n", ret);
+                    return ret;
+                }
+            }
+            #elif defined(CONFIG_LOFT_CALIB)
+            if (loft_res_local.bit_mask[1]) {
+                ret = aicwf_loft_result_apply_8800dc(rwnx_hw, &loft_res_local);
+                if (ret) {
+                    AICWFDBG(LOGINFO, "apply loft res fail: %d\n", ret);
+                    return ret;
+                }
+            }
+            #else
+            {
+                ret = aicwf_misc_ram_init_8800dc(rwnx_hw);
+                if (ret) {
+                    AICWFDBG(LOGINFO, "misc ram init fail: %d\n", ret);
+                    return ret;
+                }
+            }
+            #endif
+            ret = rwnx_send_rf_calib_req(rwnx_hw, cfm);
+            if (ret) {
+                AICWFDBG(LOGINFO, "rf calib req fail: %d\n", ret);
+                return ret;
+            }
+        }
 	}
 
 	return 0 ;
@@ -2024,39 +2970,158 @@ int aicwf_set_rf_config_8800dc(struct rwnx_hw *rwnx_hw, struct mm_set_rf_calib_c
 
 extern char aic_fw_path[200];
 
-int aicwf_plat_patch_load_8800dc(struct rwnx_hw *rwnx_hw){
+int aicwf_plat_patch_load_8800dc(struct rwnx_hw *rwnx_hw)
+{
     int ret = 0;
-
-    if (testmode == 0 || testmode == 4) {
 #if !defined(CONFIG_FPGA_VERIFICATION)
-        if (chip_sub_id == 0) {
-            ret = rwnx_plat_bin_fw_upload_2(rwnx_hw, ROM_FMAC_PATCH_ADDR, RWNX_MAC_PATCH_NAME2_8800DC);
-        } else if (chip_sub_id == 1) {
-            ret = rwnx_plat_bin_fw_upload_2(rwnx_hw, ROM_FMAC_PATCH_ADDR, RWNX_MAC_PATCH_NAME2_8800DC_U02);
-        } else {
-            printk("unsupported id: %d\n", chip_sub_id);
-        }
+    if (chip_sub_id == 0) {
+        ret = rwnx_plat_bin_fw_upload_2(rwnx_hw, ROM_FMAC_PATCH_ADDR, RWNX_MAC_PATCH_NAME2_8800DC);
+    } else if (chip_sub_id == 1) {
+#ifdef CONFIG_LOAD_BT_PATCH_IN_FDRV
+		uint32_t fw_ram_patch_base_addr = FW_RAM_PATCH_BASE_ADDR;
+		ret = rwnx_get_patch_addr_from_patch_table(rwnx_hw, FW_PATCH_TABLE_NAME_U02, &fw_ram_patch_base_addr);
+		//bt patch
+		printk("%s %x\n", __func__, fw_ram_patch_base_addr);
+		ret = rwnx_plat_bin_fw_upload_2(rwnx_hw, FW_8800DC_U02_ADID_ADDR, FW_ADID_BASE_NAME);
+		//fw_ram_patch_base_addr, FW_PATCH_BASE_NAME_U02
+		ret = rwnx_plat_bin_fw_upload_2(rwnx_hw, fw_ram_patch_base_addr, FW_PATCH_BASE_NAME_U02);
+		//bt patch table
+		ret = rwnx_patch_table_download(rwnx_hw, FW_PATCH_TABLE_NAME_U02);
+#endif
+		//wifi patch
+        ret = rwnx_plat_bin_fw_upload_2(rwnx_hw, ROM_FMAC_PATCH_ADDR, RWNX_MAC_PATCH_NAME2_8800DC_U02);
+    } else if (chip_sub_id == 2) {
+#ifdef CONFIG_LOAD_BT_PATCH_IN_FDRV
+		uint32_t fw_ram_patch_base_addr = FW_RAM_PATCH_BASE_ADDR;
+		ret = rwnx_get_patch_addr_from_patch_table(rwnx_hw, FW_PATCH_TABLE_NAME_U02, &fw_ram_patch_base_addr);
+		//bt patch
+		printk("%s %x\n", __func__, fw_ram_patch_base_addr);
+		ret = rwnx_plat_bin_fw_upload_2(rwnx_hw, FW_8800DC_U02_ADID_ADDR, FW_ADID_BASE_NAME);
+		//fw_ram_patch_base_addr, FW_PATCH_BASE_NAME_U02
+		ret = rwnx_plat_bin_fw_upload_2(rwnx_hw, fw_ram_patch_base_addr, FW_PATCH_BASE_NAME_U02H);
+		//bt patch table
+		ret = rwnx_patch_table_download(rwnx_hw, FW_PATCH_TABLE_NAME_U02H);
 #endif
+		//wifi patch
+        ret = rwnx_plat_bin_fw_upload_2(rwnx_hw, ROM_FMAC_PATCH_ADDR, RWNX_MAC_PATCH_NAME2_8800DC_H_U02);
     } else {
-        if (chip_sub_id == 0) {
-            ret = rwnx_plat_bin_fw_upload_2(rwnx_hw, ROM_FMAC_PATCH_ADDR, RWNX_MAC_RF_PATCH_NAME_8800DC);
+        printk("unsupported id: %d\n", chip_sub_id);
+    }
+#endif
+    return ret;
+}
+
+int aicwf_plat_rftest_load_8800dc(struct rwnx_hw *rwnx_hw)
+{
+    int ret = 0;
+    ret = rwnx_plat_bin_fw_upload_2(rwnx_hw, RAM_LMAC_FW_ADDR, RWNX_MAC_FW_RF_BASE_NAME_8800DC);
+    if (ret) {
+        AICWFDBG(LOGINFO, "load rftest bin fail: %d\n", ret);
+        return ret;
+    }
+    return ret;
+}
+
+#if defined(CONFIG_DPD) || defined(CONFIG_LOFT_CALIB)
+int aicwf_misc_ram_valid_check_8800dc(struct rwnx_hw *rwnx_hw, int *valid_out)
+{
+    int ret = 0;
+    uint32_t cfg_base = 0x10164;
+    struct dbg_mem_read_cfm cfm;
+    uint32_t misc_ram_addr;
+    uint32_t ram_base_addr, ram_word_cnt;
+    uint32_t bit_mask[4];
+    int i;
+    if (valid_out) {
+        *valid_out = 0;
+    }
+    if (testmode == FW_RFTEST_MODE) {
+	    uint32_t vect1 = 0;
+	    uint32_t vect2 = 0;
+	    cfg_base = RAM_LMAC_FW_ADDR + 0x0004;
+	    ret = rwnx_send_dbg_mem_read_req(rwnx_hw, cfg_base, &cfm);
+	    if (ret) {
+		    AICWFDBG(LOGERROR, "cfg_base:%x vcet1 rd fail: %d\n", cfg_base, ret);
+		    return ret;
+	    }
+	    vect1 = cfm.memdata;
+	    if ((vect1 & 0xFFFF0000) != (RAM_LMAC_FW_ADDR & 0xFFFF0000)) {
+		    AICWFDBG(LOGERROR, "vect1 invalid: %x\n", vect1);
+		    return ret;
+	    }
+	    cfg_base = RAM_LMAC_FW_ADDR + 0x0008;
+	    ret = rwnx_send_dbg_mem_read_req(rwnx_hw, cfg_base, &cfm);
+	    if (ret) {
+		    AICWFDBG(LOGERROR, "cfg_base:%x vcet2 rd fail: %d\n", cfg_base, ret);
+		    return ret;
+	    }
+	    vect2 = cfm.memdata;
+	    if ((vect2 & 0xFFFF0000) != (RAM_LMAC_FW_ADDR & 0xFFFF0000)) {
+		    AICWFDBG(LOGERROR, "vect2 invalid: %x\n", vect2);
+		    return ret;
+	    }
+	    cfg_base = RAM_LMAC_FW_ADDR + 0x0164;
+    }
+    // init misc ram
+    ret = rwnx_send_dbg_mem_read_req(rwnx_hw, cfg_base + 0x14, &cfm);
+    if (ret) {
+        AICWFDBG(LOGERROR, "rf misc ram[0x%x] rd fail: %d\n", cfg_base + 0x14, ret);
+        return ret;
+    }
+    misc_ram_addr = cfm.memdata;
+    AICWFDBG(LOGERROR, "misc_ram_addr=%x\n", misc_ram_addr);
+    // bit_mask
+    ram_base_addr = misc_ram_addr + offsetof(rf_misc_ram_t, bit_mask);
+    ram_word_cnt = (MEMBER_SIZE(rf_misc_ram_t, bit_mask) + MEMBER_SIZE(rf_misc_ram_t, reserved)) / 4;
+    for (i = 0; i < ram_word_cnt; i++) {
+        ret = rwnx_send_dbg_mem_read_req(rwnx_hw, ram_base_addr + i * 4, &cfm);
+        if (ret) {
+            AICWFDBG(LOGERROR, "bit_mask[0x%x] rd fail: %d\n",  ram_base_addr + i * 4, ret);
+            return ret;
         }
-        if (!ret) {
-            ret = rwnx_plat_bin_fw_upload_2(rwnx_hw, RAM_LMAC_FW_ADDR, RWNX_MAC_FW_RF_BASE_NAME_8800DC);
+        bit_mask[i] = cfm.memdata;
+    }
+    AICWFDBG(LOGTRACE, "bit_mask:%x,%x,%x,%x\n",bit_mask[0],bit_mask[1],bit_mask[2],bit_mask[3]);
+    if ((bit_mask[0] == 0) && ((bit_mask[1] & 0xFFF00000) == 0x80000000) &&
+        (bit_mask[2] == 0) && ((bit_mask[3] & 0xFFFFFF00) == 0x00000000)) {
+        if (valid_out) {
+            *valid_out = 1;
         }
     }
+    return ret;
+}
 
+int aicwf_plat_calib_load_8800dc(struct rwnx_hw *rwnx_hw)
+{
+    int ret = 0;
+    if (chip_sub_id == 1) {
+        ret = rwnx_plat_bin_fw_upload_2(rwnx_hw, ROM_FMAC_CALIB_ADDR, RWNX_MAC_CALIB_NAME_8800DC_U02);
+        if (ret) {
+            AICWFDBG(LOGINFO, "load calib bin fail: %d\n", ret);
+            return ret;
+        }
+    } else if (chip_sub_id == 2) {
+        ret = rwnx_plat_bin_fw_upload_2(rwnx_hw, ROM_FMAC_CALIB_ADDR, RWNX_MAC_CALIB_NAME_8800DC_H_U02);
+        if (ret) {
+            AICWFDBG(LOGINFO, "load calib bin fail: %d\n", ret);
+            return ret;
+        }
+    }
     return ret;
 }
+#endif
 
 int aicwf_misc_ram_init_8800dc(struct rwnx_hw *rwnx_hw)
 {
     int ret = 0;
-    const uint32_t cfg_base = 0x10164;
+    uint32_t cfg_base = 0x10164;
     struct dbg_mem_read_cfm cfm;
     uint32_t misc_ram_addr;
     uint32_t misc_ram_size = 12;
     int i;
+    if (testmode == FW_RFTEST_MODE) {
+        cfg_base = RAM_LMAC_FW_ADDR + 0x0164;
+    }
     // init misc ram
     ret = rwnx_send_dbg_mem_read_req(rwnx_hw, cfg_base + 0x14, &cfm);
     if (ret) {
@@ -2076,16 +3141,21 @@ int aicwf_misc_ram_init_8800dc(struct rwnx_hw *rwnx_hw)
 }
 
 #ifdef CONFIG_DPD
-int aicwf_dpd_calib_8800dc(struct rwnx_hw *rwnx_hw, uint32_t *dpd_res)
+int aicwf_dpd_calib_8800dc(struct rwnx_hw *rwnx_hw, rf_misc_ram_lite_t *dpd_res)
 {
     int ret = 0;
     uint32_t fw_addr, boot_type;
-    ret = aicwf_plat_patch_load_8800dc(rwnx_hw);
+    int valid_flag;
+    ret = aicwf_misc_ram_valid_check_8800dc(rwnx_hw, &valid_flag);
     if (ret) {
-        AICWFDBG(LOGINFO, "load patch bin fail: %d\n", ret);
+        AICWFDBG(LOGINFO, "misc ram check fail: %d\n", ret);
         return ret;
     }
-    ret = rwnx_plat_bin_fw_upload_2(rwnx_hw, ROM_FMAC_CALIB_ADDR, RWNX_MAC_CALIB_NAME_8800DC_U02);
+    if (valid_flag) {
+        AICWFDBG(LOGINFO, "misc ram valid, skip calib process\n");
+        return ret;
+    }
+    ret = aicwf_plat_calib_load_8800dc(rwnx_hw);
     if (ret) {
         AICWFDBG(LOGINFO, "load calib bin fail: %d\n", ret);
         return ret;
@@ -2103,7 +3173,7 @@ int aicwf_dpd_calib_8800dc(struct rwnx_hw *rwnx_hw, uint32_t *dpd_res)
         const uint32_t cfg_base = 0x10164;
         struct dbg_mem_read_cfm cfm;
         uint32_t misc_ram_addr;
-        uint32_t misc_ram_size = DPD_RESULT_SIZE_8800DC;
+        uint32_t ram_base_addr, ram_word_cnt;
         int i;
         ret = rwnx_send_dbg_mem_read_req(rwnx_hw, cfg_base + 0x14, &cfm);
         if (ret) {
@@ -2111,52 +3181,130 @@ int aicwf_dpd_calib_8800dc(struct rwnx_hw *rwnx_hw, uint32_t *dpd_res)
             return ret;
         }
         misc_ram_addr = cfm.memdata;
-        for (i = 0; i < (misc_ram_size / 4); i++) {
-            ret = rwnx_send_dbg_mem_read_req(rwnx_hw, misc_ram_addr + i * 4, &cfm);
+        // bit_mask
+        ram_base_addr = misc_ram_addr + offsetof(rf_misc_ram_t, bit_mask);
+        ram_word_cnt = (MEMBER_SIZE(rf_misc_ram_t, bit_mask) + MEMBER_SIZE(rf_misc_ram_t, reserved)) / 4;
+        for (i = 0; i < ram_word_cnt; i++) {
+            ret = rwnx_send_dbg_mem_read_req(rwnx_hw, ram_base_addr + i * 4, &cfm);
             if (ret) {
-                AICWFDBG(LOGERROR, "rf misc ram[0x%x] rd fail: %d\n",  misc_ram_addr + i * 4, ret);
+                AICWFDBG(LOGERROR, "bit_mask[0x%x] rd fail: %d\n",  ram_base_addr + i * 4, ret);
                 return ret;
             }
-            dpd_res[i] = cfm.memdata;
+            dpd_res->bit_mask[i] = cfm.memdata;
+        }
+        // dpd_high
+        ram_base_addr = misc_ram_addr + offsetof(rf_misc_ram_t, dpd_high);
+        ram_word_cnt = MEMBER_SIZE(rf_misc_ram_t, dpd_high) / 4;
+        for (i = 0; i < ram_word_cnt; i++) {
+            ret = rwnx_send_dbg_mem_read_req(rwnx_hw, ram_base_addr + i * 4, &cfm);
+            if (ret) {
+                AICWFDBG(LOGERROR, "dpd_high[0x%x] rd fail: %d\n",  ram_base_addr + i * 4, ret);
+                return ret;
+            }
+            dpd_res->dpd_high[i] = cfm.memdata;
+        }
+        // loft_res
+        ram_base_addr = misc_ram_addr + offsetof(rf_misc_ram_t, loft_res);
+        ram_word_cnt = MEMBER_SIZE(rf_misc_ram_t, loft_res) / 4;
+        for (i = 0; i < ram_word_cnt; i++) {
+            ret = rwnx_send_dbg_mem_read_req(rwnx_hw, ram_base_addr + i * 4, &cfm);
+            if (ret) {
+                AICWFDBG(LOGERROR, "loft_res[0x%x] rd fail: %d\n",  ram_base_addr + i * 4, ret);
+                return ret;
+            }
+            dpd_res->loft_res[i] = cfm.memdata;
         }
     }
     return ret;
 }
 
-int aicwf_dpd_result_load_8800dc(struct rwnx_hw *rwnx_hw)
+int aicwf_dpd_result_apply_8800dc(struct rwnx_hw *rwnx_hw, rf_misc_ram_lite_t *dpd_res)
 {
     int ret = 0;
     uint32_t cfg_base = 0x10164;
     struct dbg_mem_read_cfm cfm;
     uint32_t misc_ram_addr;
-	if (testmode == FW_RFTEST_MODE) {
-		cfg_base = RAM_LMAC_FW_ADDR + 0x0164;
-	}
+    uint32_t ram_base_addr, ram_byte_cnt;
+    AICWFDBG(LOGINFO, "bit_mask[1]=%x\n", dpd_res->bit_mask[1]);
+    if (dpd_res->bit_mask[1] == 0) {
+        AICWFDBG(LOGERROR, "void dpd_res, bypass it.\n");
+        return 0;
+    }
+    if (testmode == FW_RFTEST_MODE) {
+        cfg_base = RAM_LMAC_FW_ADDR + 0x0164;
+    }
     if ((ret = rwnx_send_dbg_mem_read_req(rwnx_hw, cfg_base + 0x14, &cfm))) {
         AICWFDBG(LOGERROR, "rf misc ram[0x%x] rd fail: %d\n", cfg_base + 0x14, ret);
         return ret;
     }
     misc_ram_addr = cfm.memdata;
-    ret = rwnx_plat_bin_fw_upload_2(rwnx_hw, misc_ram_addr, FW_DPDRESULT_NAME_8800DC);
+    AICWFDBG(LOGINFO, "misc_ram_addr: %x\n", misc_ram_addr);
+    /* Copy dpd_res on the Embedded side */
+    // bit_mask
+    AICWFDBG(LOGINFO, "bit_mask[0]=%x\n", dpd_res->bit_mask[0]);
+    ram_base_addr = misc_ram_addr + offsetof(rf_misc_ram_t, bit_mask);
+    ram_byte_cnt = MEMBER_SIZE(rf_misc_ram_t, bit_mask) + MEMBER_SIZE(rf_misc_ram_t, reserved);
+    ret = rwnx_send_dbg_mem_block_write_req(rwnx_hw, ram_base_addr, ram_byte_cnt, (u32 *)&dpd_res->bit_mask[0]);
     if (ret) {
-        AICWFDBG(LOGINFO, "load calib bin fail: %d\n", ret);
+        AICWFDBG(LOGERROR, "bit_mask wr fail: %x, ret:%d\r\n", ram_base_addr, ret);
+        return ret;
+    }
+    // dpd_high
+    AICWFDBG(LOGINFO, "dpd_high[0]=%x\n", dpd_res->dpd_high[0]);
+    ram_base_addr = misc_ram_addr + offsetof(rf_misc_ram_t, dpd_high);
+    ram_byte_cnt = MEMBER_SIZE(rf_misc_ram_t, dpd_high);
+    ret = rwnx_send_dbg_mem_block_write_req(rwnx_hw, ram_base_addr, ram_byte_cnt, (u32 *)&dpd_res->dpd_high[0]);
+    if (ret) {
+        AICWFDBG(LOGERROR, "dpd_high wr fail: %x, ret:%d\r\n", ram_base_addr, ret);
+        return ret;
+    }
+    // loft_res
+    AICWFDBG(LOGINFO, "loft_res[0]=%x\n", dpd_res->loft_res[0]);
+    ram_base_addr = misc_ram_addr + offsetof(rf_misc_ram_t, loft_res);
+    ram_byte_cnt = MEMBER_SIZE(rf_misc_ram_t, loft_res);
+    ret = rwnx_send_dbg_mem_block_write_req(rwnx_hw, ram_base_addr, ram_byte_cnt, (u32 *)&dpd_res->loft_res[0]);
+    if (ret) {
+        AICWFDBG(LOGERROR, "loft_res wr fail: %x, ret:%d\r\n", ram_base_addr, ret);
         return ret;
     }
     return ret;
 }
 
+#ifndef CONFIG_FORCE_DPD_CALIB
+int aicwf_dpd_result_load_8800dc(struct rwnx_hw *rwnx_hw, rf_misc_ram_lite_t *dpd_res)
+{
+    int ret = 0;
+    int size;
+    u32 *dst=NULL;
+    char *filename = FW_DPDRESULT_NAME_8800DC;
+    AICWFDBG(LOGINFO, "dpd_res file path:%s \r\n", filename);
+    /* load file */
+    size = rwnx_request_firmware_common(rwnx_hw, &dst, filename);
+    if (size <= 0) {
+        AICWFDBG(LOGERROR, "wrong size of dpd_res file\n");
+        dst = NULL;
+        return -1;
+    }
+    AICWFDBG(LOGINFO, "### Load file done: %s, size=%d, dst[0]=%x\n", filename, size, dst[0]);
+    memcpy((u8 *)dpd_res, (u8 *)dst, sizeof(rf_misc_ram_lite_t));
+    if (dst) {
+        rwnx_release_firmware_common(&dst);
+    }
+    return ret;
+}
+
 #define FW_PATH_MAX_LEN 200
 extern char aic_fw_path[FW_PATH_MAX_LEN];
 
 int aicwf_dpd_result_write_8800dc(void *buf, int buf_len)
 {
-	AICWFDBG(LOGINFO, "%s\n", __func__);
     int sum = 0, len = 0;
     char *path = NULL;
     struct file *fp = NULL;
     loff_t pos = 0;
     mm_segment_t fs;
 
+	AICWFDBG(LOGINFO, "%s\n", __func__);
     path = __getname();
     if (!path) {
         AICWFDBG(LOGINFO, "get path fail\n");
@@ -2166,7 +3314,7 @@ int aicwf_dpd_result_write_8800dc(void *buf, int buf_len)
     len = snprintf(path, FW_PATH_MAX_LEN, "%s/%s", aic_fw_path, FW_DPDRESULT_NAME_8800DC);
     //AICWFDBG(LOGINFO, "%s\n", path);
 
-    fp = filp_open(path, O_RDWR | O_APPEND | O_CREAT, 0644);
+    fp = filp_open(path, O_RDWR | O_CREAT, 0644);
     if (IS_ERR(fp)) {
         AICWFDBG(LOGINFO, "fp open fial\n");
 		__putname(path);
@@ -2191,6 +3339,118 @@ int aicwf_dpd_result_write_8800dc(void *buf, int buf_len)
 
     return 0;
 }
+#endif /* !CONFIG_FORCE_DPD_CALIB */
+#endif
+
+#ifdef CONFIG_LOFT_CALIB
+int aicwf_loft_calib_8800dc(struct rwnx_hw *rwnx_hw, rf_misc_ram_lite_t *loft_res)
+{
+    int ret = 0;
+    uint32_t fw_addr, boot_type;
+    int valid_flag;
+    ret = aicwf_misc_ram_valid_check_8800dc(rwnx_hw, &valid_flag);
+    if (ret) {
+        AICWFDBG(LOGINFO, "misc ram check fail: %d\n", ret);
+        return ret;
+    }
+    if (valid_flag) {
+        AICWFDBG(LOGINFO, "misc ram valid, skip calib process\n");
+        return ret;
+    }
+    ret = aicwf_plat_calib_load_8800dc(rwnx_hw);
+    if (ret) {
+        AICWFDBG(LOGINFO, "load calib bin fail: %d\n", ret);
+        return ret;
+    }
+    /* fw start */
+    fw_addr = 0x00130009;
+    boot_type = HOST_START_APP_FNCALL;
+    AICWFDBG(LOGINFO, "Start app: %08x, %d\n", fw_addr, boot_type);
+    ret = rwnx_send_dbg_start_app_req(rwnx_hw, fw_addr, boot_type);
+    if (ret) {
+        AICWFDBG(LOGINFO, "start app fail: %d\n", ret);
+        return ret;
+    }
+    { // read loft res
+        const uint32_t cfg_base = 0x10164;
+        struct dbg_mem_read_cfm cfm;
+        uint32_t misc_ram_addr;
+        uint32_t ram_base_addr, ram_word_cnt;
+        int i;
+        ret = rwnx_send_dbg_mem_read_req(rwnx_hw, cfg_base + 0x14, &cfm);
+        if (ret) {
+            AICWFDBG(LOGERROR, "rf misc ram[0x%x] rd fail: %d\n", cfg_base + 0x14, ret);
+            return ret;
+        }
+        misc_ram_addr = cfm.memdata;
+        // bit_mask
+        ram_base_addr = misc_ram_addr + offsetof(rf_misc_ram_t, bit_mask);
+        ram_word_cnt = (MEMBER_SIZE(rf_misc_ram_t, bit_mask) + MEMBER_SIZE(rf_misc_ram_t, reserved)) / 4;
+        for (i = 0; i < ram_word_cnt; i++) {
+            ret = rwnx_send_dbg_mem_read_req(rwnx_hw, ram_base_addr + i * 4, &cfm);
+            if (ret) {
+                AICWFDBG(LOGERROR, "bit_mask[0x%x] rd fail: %d\n",  ram_base_addr + i * 4, ret);
+                return ret;
+            }
+            loft_res->bit_mask[i] = cfm.memdata;
+        }
+        // loft_res
+        ram_base_addr = misc_ram_addr + offsetof(rf_misc_ram_t, loft_res);
+        ram_word_cnt = MEMBER_SIZE(rf_misc_ram_t, loft_res) / 4;
+        for (i = 0; i < ram_word_cnt; i++) {
+            ret = rwnx_send_dbg_mem_read_req(rwnx_hw, ram_base_addr + i * 4, &cfm);
+            if (ret) {
+                AICWFDBG(LOGERROR, "loft_res[0x%x] rd fail: %d\n",  ram_base_addr + i * 4, ret);
+                return ret;
+            }
+            loft_res->loft_res[i] = cfm.memdata;
+        }
+    }
+    return ret;
+}
+
+int aicwf_loft_result_apply_8800dc(struct rwnx_hw *rwnx_hw, rf_misc_ram_lite_t *loft_res)
+{
+    int ret = 0;
+    uint32_t cfg_base = 0x10164;
+    struct dbg_mem_read_cfm cfm;
+    uint32_t misc_ram_addr;
+    uint32_t ram_base_addr, ram_byte_cnt;
+    AICWFDBG(LOGINFO, "bit_mask[1]=%x\n", loft_res->bit_mask[1]);
+    if (loft_res->bit_mask[1] == 0) {
+        AICWFDBG(LOGERROR, "void loft_res, bypass it.\n");
+        return 0;
+    }
+    if (testmode == FW_RFTEST_MODE) {
+        cfg_base = RAM_LMAC_FW_ADDR + 0x0164;
+    }
+    if ((ret = rwnx_send_dbg_mem_read_req(rwnx_hw, cfg_base + 0x14, &cfm))) {
+        AICWFDBG(LOGERROR, "rf misc ram[0x%x] rd fail: %d\n", cfg_base + 0x14, ret);
+        return ret;
+    }
+    misc_ram_addr = cfm.memdata;
+    AICWFDBG(LOGINFO, "misc_ram_addr: %x\n", misc_ram_addr);
+    /* Copy loft_res on the Embedded side */
+    // bit_mask
+    AICWFDBG(LOGINFO, "bit_mask[0]=%x\n", loft_res->bit_mask[0]);
+    ram_base_addr = misc_ram_addr + offsetof(rf_misc_ram_t, bit_mask);
+    ram_byte_cnt = MEMBER_SIZE(rf_misc_ram_t, bit_mask) + MEMBER_SIZE(rf_misc_ram_t, reserved);
+    ret = rwnx_send_dbg_mem_block_write_req(rwnx_hw, ram_base_addr, ram_byte_cnt, (u32 *)&loft_res->bit_mask[0]);
+    if (ret) {
+        AICWFDBG(LOGERROR, "bit_mask wr fail: %x, ret:%d\r\n", ram_base_addr, ret);
+        return ret;
+    }
+    // loft_res
+    AICWFDBG(LOGINFO, "loft_res[0]=%x\n", loft_res->loft_res[0]);
+    ram_base_addr = misc_ram_addr + offsetof(rf_misc_ram_t, loft_res);
+    ram_byte_cnt = MEMBER_SIZE(rf_misc_ram_t, loft_res);
+    ret = rwnx_send_dbg_mem_block_write_req(rwnx_hw, ram_base_addr, ram_byte_cnt, (u32 *)&loft_res->loft_res[0]);
+    if (ret) {
+        AICWFDBG(LOGERROR, "loft_res wr fail: %x, ret:%d\r\n", ram_base_addr, ret);
+        return ret;
+    }
+    return ret;
+}
 #endif
 
 int	rwnx_plat_userconfig_load_8800dc(struct rwnx_hw *rwnx_hw){
@@ -2247,9 +3507,89 @@ int	rwnx_plat_userconfig_load_8800dw(struct rwnx_hw *rwnx_hw){
 
 }
 
+#ifdef CONFIG_POWER_LIMIT
+extern char country_code[];
+
+int rwnx_plat_powerlimit_load_8800dcdw(struct rwnx_hw *rwnx_hw, uint16_t chip_id)
+{
+    int size;
+    u32 *dst = NULL;
+    char *filename;
+    if (chip_id == PRODUCT_ID_AIC8800DC) {
+        filename = FW_POWERLIMIT_NAME_8800DC;
+    } else if (chip_id == PRODUCT_ID_AIC8800DW) {
+        filename = FW_POWERLIMIT_NAME_8800DW;
+    } else {
+        AICWFDBG(LOGERROR, "invalid chip_id: %d\n", chip_id);
+        return 0;
+    }
+
+    AICWFDBG(LOGINFO, "powerlimit file path:%s \r\n", filename);
+
+    /* load file */
+    size = rwnx_request_firmware_common(rwnx_hw, &dst, filename);
+    if (size <= 0) {
+        AICWFDBG(LOGERROR, "wrong size of cfg file\n");
+        dst = NULL;
+        return 0;
+    }
+
+    /* Copy the file on the Embedded side */
+    AICWFDBG(LOGINFO, "### Load file done: %s, size=%d\n", filename, size);
+
+    rwnx_plat_powerlimit_parsing((char *)dst, size, country_code);
+
+    rwnx_release_firmware_common(&dst);
+
+    AICWFDBG(LOGINFO, "powerlimit download complete\n\n");
+    return 0;
+}
+#endif
+
+//Crystal provided by CPU (start)
+int set_bbpll_config(struct rwnx_hw *rwnx_hw){
+//    {0x40505010, 0x7C301010},//bbpll
+	int ret = 0;
+	struct dbg_mem_read_cfm rd_mem_addr_cfm;
+
+	//Read crystal provided by CPU or not.
+    ret = rwnx_send_dbg_mem_read_req(rwnx_hw, 0x40500148, &rd_mem_addr_cfm);
+    if (ret) {
+		AICWFDBG(LOGERROR, "%x rd fail: %d\n", 0x40500148, ret);
+        return -1;
+    }
+
+	AICWFDBG(LOGDEBUG, "%s rd_mem_addr_cfm.memdata:%x \r\n", __func__, rd_mem_addr_cfm.memdata);
+
+	if(!(rd_mem_addr_cfm.memdata & 0x01)){
+		AICWFDBG(LOGINFO, "%s Crystal not provided by CPU \r\n", __func__);
+		return 0;
+	}else{
+		AICWFDBG(LOGINFO, "%s Crystal provided by CPU \r\n", __func__);
+		//Read 0x40505010 value to check bbpll set or not.
+		ret = rwnx_send_dbg_mem_read_req(rwnx_hw, 0x40505010, &rd_mem_addr_cfm);
+		if(ret < 0){
+			AICWFDBG(LOGERROR, "%s error ret_val:%d\r\n", __func__, ret);
+			return -1;
+		}
+
+		if((rd_mem_addr_cfm.memdata >> 29) == 3){
+			AICWFDBG(LOGERROR, "%s Not need to set \r\n", __func__);
+			return 0;
+		}else{
+			rd_mem_addr_cfm.memdata |= ((0x1 << 29) | (0x1 << 30));
+			rd_mem_addr_cfm.memdata &= (~(0x1 << 31));
+			rwnx_send_dbg_mem_write_req(rwnx_hw, 0x40505010, rd_mem_addr_cfm.memdata);
+		}
+	}
+	return 0;
+}
+//Crystal provided by CPU (end)
+
 
 void system_config_8800dc(struct rwnx_hw *rwnx_hw){
     int syscfg_num;
+    array3_tbl_t p_syscfg_msk_tbl;
     int ret, cnt;
     const u32 mem_addr = 0x40500000;
     struct dbg_mem_read_cfm rd_mem_addr_cfm;
@@ -2275,6 +3615,14 @@ void system_config_8800dc(struct rwnx_hw *rwnx_hw){
 	AICWFDBG(LOGINFO, "chip_id=%x, chip_sub_id=%x\n", chip_id, chip_sub_id);
 
 
+	//Crystal provided by CPU (start)
+	ret = set_bbpll_config(rwnx_hw);
+    if (ret) {
+		AICWFDBG(LOGERROR, "set_bbpll_config fail: %d\n", ret);
+        return;
+    }
+	//Crystal provided by CPU (end)
+
 	ret = rwnx_send_dbg_mem_read_req(rwnx_hw, 0x40500010, &rd_mem_addr_cfm);
 	printk("[0x40500010]=%x\n", rd_mem_addr_cfm.memdata);
 	if (ret) {
@@ -2292,23 +3640,28 @@ void system_config_8800dc(struct rwnx_hw *rwnx_hw){
         }
     }
 
-	syscfg_num = sizeof(syscfg_tbl_masked_8800dc) / sizeof(u32) / 3;
-
+    if (IS_CHIP_ID_H()) {
+        syscfg_num = sizeof(syscfg_tbl_masked_8800dc_h) / sizeof(u32) / 3;
+        p_syscfg_msk_tbl = syscfg_tbl_masked_8800dc_h;
+    } else {
+        syscfg_num = sizeof(syscfg_tbl_masked_8800dc) / sizeof(u32) / 3;
+        p_syscfg_msk_tbl = syscfg_tbl_masked_8800dc;
+    }
 
     for (cnt = 0; cnt < syscfg_num; cnt++) {
-	    if (syscfg_tbl_masked_8800dc[cnt][0] == 0x00000000) {
+        if (p_syscfg_msk_tbl[cnt][0] == 0x00000000) {
             break;
-        } else if (syscfg_tbl_masked_8800dc[cnt][0] == 0x70001000) {
+        } else if (p_syscfg_msk_tbl[cnt][0] == 0x70001000) {
             if (chip_mcu_id == 0) {
-                syscfg_tbl_masked_8800dc[cnt][1] |= ((0x1 << 8) | (0x1 << 15)); // mask
-                syscfg_tbl_masked_8800dc[cnt][2] |= ((0x1 << 8) | (0x1 << 15));
+                p_syscfg_msk_tbl[cnt][1] |= ((0x1 << 8) | (0x1 << 15)); // mask
+                p_syscfg_msk_tbl[cnt][2] |= ((0x1 << 8) | (0x1 << 15));
             }
         }
 
         ret = rwnx_send_dbg_mem_mask_write_req(rwnx_hw,
-            syscfg_tbl_masked_8800dc[cnt][0], syscfg_tbl_masked_8800dc[cnt][1], syscfg_tbl_masked_8800dc[cnt][2]);
+            p_syscfg_msk_tbl[cnt][0], p_syscfg_msk_tbl[cnt][1], p_syscfg_msk_tbl[cnt][2]);
         if (ret) {
-			AICWFDBG(LOGERROR, "%x mask write fail: %d\n", syscfg_tbl_masked_8800dc[cnt][0], ret);
+            AICWFDBG(LOGERROR, "%x mask write fail: %d\n", p_syscfg_msk_tbl[cnt][0], ret);
             return;
         }
     }
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.h
index 8a9184f750d1..c0e53cb95faf 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.h
@@ -1,16 +1,62 @@
 #include <linux/types.h>
 
-#define DPD_RESULT_SIZE_8800DC 1880
+#if defined(CONFIG_DPD) || defined(CONFIG_LOFT_CALIB)
+typedef struct {
+    uint32_t bit_mask[3];
+    uint32_t reserved;
+    uint32_t dpd_high[96];
+    uint32_t dpd_11b[96];
+    uint32_t dpd_low[96];
+    uint32_t idac_11b[48];
+    uint32_t idac_high[48];
+    uint32_t idac_low[48];
+    uint32_t loft_res[18];
+    uint32_t rx_iqim_res[16];
+} rf_misc_ram_t;
+
+typedef struct {
+    uint32_t bit_mask[4];
+    uint32_t dpd_high[96];
+    uint32_t loft_res[18];
+} rf_misc_ram_lite_t;
+
+#define MEMBER_SIZE(type, member)   sizeof(((type *)0)->member)
+#define DPD_RESULT_SIZE_8800DC      sizeof(rf_misc_ram_lite_t)
+#endif
+
+#ifdef CONFIG_DPD
+extern rf_misc_ram_lite_t dpd_res;
+#endif
+
+#ifdef CONFIG_LOFT_CALIB
+extern rf_misc_ram_lite_t loft_res_local;
+#endif
+
 int aicwf_patch_table_load(struct rwnx_hw *rwnx_hw, char *filename);
 void aicwf_patch_config_8800dc(struct rwnx_hw *rwnx_hw);
 int aicwf_set_rf_config_8800dc(struct rwnx_hw *rwnx_hw, struct mm_set_rf_calib_cfm *cfm);
 int aicwf_misc_ram_init_8800dc(struct rwnx_hw *rwnx_hw);
+#if defined(CONFIG_DPD) || defined(CONFIG_LOFT_CALIB)
+int aicwf_misc_ram_valid_check_8800dc(struct rwnx_hw *rwnx_hw, int *valid_out);
+int aicwf_plat_calib_load_8800dc(struct rwnx_hw *rwnx_hw);
+#endif
 #ifdef CONFIG_DPD
-int aicwf_dpd_calib_8800dc(struct rwnx_hw *rwnx_hw, uint32_t *dpd_res);
-int aicwf_dpd_result_load_8800dc(struct rwnx_hw *rwnx_hw);
+int aicwf_dpd_calib_8800dc(struct rwnx_hw *rwnx_hw, rf_misc_ram_lite_t *dpd_res);
+int aicwf_dpd_result_apply_8800dc(struct rwnx_hw *rwnx_hw, rf_misc_ram_lite_t *dpd_res);
+#ifndef CONFIG_FORCE_DPD_CALIB
+int aicwf_dpd_result_load_8800dc(struct rwnx_hw *rwnx_hw, rf_misc_ram_lite_t *dpd_res);
 int aicwf_dpd_result_write_8800dc(void *buf, int buf_len);
 #endif
+#endif
+#ifdef CONFIG_LOFT_CALIB
+int aicwf_loft_calib_8800dc(struct rwnx_hw *rwnx_hw, rf_misc_ram_lite_t *loft_res);
+int aicwf_loft_result_apply_8800dc(struct rwnx_hw *rwnx_hw, rf_misc_ram_lite_t *loft_res);
+#endif
 int aicwf_plat_patch_load_8800dc(struct rwnx_hw *rwnx_hw);
+int aicwf_plat_rftest_load_8800dc(struct rwnx_hw *rwnx_hw);
 int	rwnx_plat_userconfig_load_8800dc(struct rwnx_hw *rwnx_hw);
 int	rwnx_plat_userconfig_load_8800dw(struct rwnx_hw *rwnx_hw);
+#ifdef CONFIG_POWER_LIMIT
+int rwnx_plat_powerlimit_load_8800dcdw(struct rwnx_hw *rwnx_hw, uint16_t chip_id);
+#endif
 void system_config_8800dc(struct rwnx_hw *rwnx_hw);
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_debug.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_debug.h
index 12fdca688b18..be72268e1a04 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_debug.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_debug.h
@@ -1,52 +1,52 @@
-
-
-#define RWNX_FN_ENTRY_STR ">>> %s()\n", __func__
-
-
-
-/* message levels */
-#define LOGERROR		0x0001
-#define LOGINFO			0x0002
-#define LOGTRACE		0x0004
-#define LOGDEBUG		0x0008
-#define LOGDATA			0x0010
-
-extern int aicwf_dbg_level;
-void rwnx_data_dump(char* tag, void* data, unsigned long len);
-
-#define AICWF_LOG		"AICWFDBG("
-
-#define AICWFDBG(level, args, arg...)	\
-do {	\
-	if (aicwf_dbg_level & level) {	\
-		printk(AICWF_LOG#level")\t" args, ##arg); \
-	}	\
-} while (0)
-
-#define RWNX_DBG(fmt, ...)	\
-do {	\
-	if (aicwf_dbg_level & LOGTRACE) {	\
-		printk(AICWF_LOG"LOGTRACE)\t"fmt , ##__VA_ARGS__); 	\
-	}	\
-} while (0)
-
-
-
-#if 0
-#define RWNX_DBG(fmt, ...)	\
-	do {	\
-		if (aicwf_dbg_level & LOGTRACE) {	\
-			printk(AICWF_LOG"LOGTRACE"")\t" fmt, ##__VA_ARGS__); \
-		}	\
-	} while (0)
-#define AICWFDBG(args, level)	\
-do {	\
-	if (aicwf_dbg_level & level) {	\
-		printk(AICWF_LOG"(%s)\t" ,#level);	\
-		printf args;	\
-	}	\
-} while (0)
-#endif
-
-
-
+
+
+#define RWNX_FN_ENTRY_STR ">>> %s()\n", __func__
+
+
+
+/* message levels */
+#define LOGERROR		0x0001
+#define LOGINFO			0x0002
+#define LOGTRACE		0x0004
+#define LOGDEBUG		0x0008
+#define LOGDATA			0x0010
+
+extern int aicwf_dbg_level;
+void rwnx_data_dump(char* tag, void* data, unsigned long len);
+
+#define AICWF_LOG		"AICWFDBG("
+
+#define AICWFDBG(level, args, arg...)	\
+do {	\
+	if (aicwf_dbg_level & level) {	\
+		printk(AICWF_LOG#level")\t" args, ##arg); \
+	}	\
+} while (0)
+
+#define RWNX_DBG(fmt, ...)	\
+do {	\
+	if (aicwf_dbg_level & LOGTRACE) {	\
+		printk(AICWF_LOG"LOGTRACE)\t"fmt , ##__VA_ARGS__); 	\
+	}	\
+} while (0)
+
+
+
+#if 0
+#define RWNX_DBG(fmt, ...)	\
+	do {	\
+		if (aicwf_dbg_level & LOGTRACE) {	\
+			printk(AICWF_LOG"LOGTRACE"")\t" fmt, ##__VA_ARGS__); \
+		}	\
+	} while (0)
+#define AICWFDBG(args, level)	\
+do {	\
+	if (aicwf_dbg_level & level) {	\
+		printk(AICWF_LOG"(%s)\t" ,#level);	\
+		printf args;	\
+	}	\
+} while (0)
+#endif
+
+
+
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_rx_prealloc.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_rx_prealloc.h
index a19bbe9a4578..a08927fe648e 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_rx_prealloc.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_rx_prealloc.h
@@ -1,27 +1,27 @@
-
-#ifndef _AICWF_RX_PREALLOC_H_
-#define _AICWF_RX_PREALLOC_H_
-
-#ifdef CONFIG_PREALLOC_RX_SKB
-
-struct rx_buff {
-    struct list_head queue;
-    unsigned char *data;
-    u32 len;
-    uint8_t *start;
-    uint8_t *end;
-    uint8_t *read;
-};
-
-struct aicwf_rx_buff_list {
-    struct list_head rxbuff_list;
-    atomic_t rxbuff_list_len;
-};
-
-extern struct rx_buff *aicwf_prealloc_rxbuff_alloc(spinlock_t *lock);
-extern void aicwf_prealloc_rxbuff_free(struct rx_buff *rxbuff, spinlock_t *lock);
-extern int aicwf_prealloc_init(void);
-extern void aicwf_prealloc_exit(void);
-extern int aicwf_rxbuff_size_get(void);
-#endif
-#endif /* _AICWF_RX_PREALLOC_H_ */
\ No newline at end of file
+
+#ifndef _AICWF_RX_PREALLOC_H_
+#define _AICWF_RX_PREALLOC_H_
+
+#ifdef CONFIG_PREALLOC_RX_SKB
+
+struct rx_buff {
+    struct list_head queue;
+    unsigned char *data;
+    u32 len;
+    uint8_t *start;
+    uint8_t *end;
+    uint8_t *read;
+};
+
+struct aicwf_rx_buff_list {
+    struct list_head rxbuff_list;
+    atomic_t rxbuff_list_len;
+};
+
+extern struct rx_buff *aicwf_prealloc_rxbuff_alloc(spinlock_t *lock);
+extern void aicwf_prealloc_rxbuff_free(struct rx_buff *rxbuff, spinlock_t *lock);
+extern int aicwf_prealloc_init(void);
+extern void aicwf_prealloc_exit(void);
+extern int aicwf_rxbuff_size_get(void);
+#endif
+#endif /* _AICWF_RX_PREALLOC_H_ */
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_sdio.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_sdio.c
index 1a96f4523f36..f8e79cc24e48 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_sdio.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_sdio.c
@@ -23,7 +23,6 @@
 #ifdef CONFIG_INGENIC_T20
 #include "mach/jzmmc.h"
 #endif /* CONFIG_INGENIC_T20 */
-extern uint8_t scanning;
 
 #ifdef CONFIG_PLATFORM_ALLWINNER
 void platform_wifi_power_off(void);
@@ -433,8 +432,8 @@ int aicwf_sdio_sleep_allow(struct aic_sdio_dev *sdiodev)
         }
     }
 
-    sdio_info("sleep: %d, %d\n", sdiodev->state, scanning);
-    if (sdiodev->state == SDIO_ACTIVE_ST  && !scanning && !rwnx_hw->is_p2p_alive \
+    sdio_info("sleep: %d, %d\n", sdiodev->state, rwnx_hw->scanning);
+    if (sdiodev->state == SDIO_ACTIVE_ST  && !rwnx_hw->scanning && !rwnx_hw->is_p2p_alive \
                 && !rwnx_hw->is_p2p_connected && dhcped) {
         down(&sdiodev->pwrctl_wakeup_sema);
         if (rwnx_hw->vif_started) {
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.c
new file mode 100644
index 000000000000..480fd0768266
--- /dev/null
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.c
@@ -0,0 +1,630 @@
+#include"aicwf_tcp_ack.h"
+//#include"rwnx_tx.h"
+//#include "aicwf_tcp_ack.h"
+#include"rwnx_defs.h"
+extern int intf_tx(struct rwnx_hw *priv,struct msg_buf *msg);
+struct msg_buf *intf_tcp_alloc_msg(struct msg_buf *msg)
+{
+	//printk("%s \n",__func__);
+	int len=sizeof(struct msg_buf) ;
+	msg = kzalloc(len , GFP_ATOMIC);
+	if(!msg)
+		printk("%s: alloc failed \n", __func__);
+	memset(msg,0,len);
+	return msg;
+}
+						
+void intf_tcp_drop_msg(struct rwnx_hw *priv,
+					    struct msg_buf *msg)
+{
+	//printk("%s \n",__func__);
+	if (msg->skb)
+		dev_kfree_skb_any(msg->skb);
+
+	kfree(msg);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0) 
+void tcp_ack_timeout(unsigned long data)
+#else
+void tcp_ack_timeout(struct timer_list *t)
+#endif
+{
+	//printk("%s \n",__func__);
+	struct tcp_ack_info *ack_info;
+	struct msg_buf *msg;
+	struct tcp_ack_manage *ack_m = NULL;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0) 
+	ack_info = (struct tcp_ack_info *)data;
+#else
+	ack_info = container_of(t,struct tcp_ack_info,timer);
+#endif
+
+	ack_m = container_of(ack_info, struct tcp_ack_manage,
+			     ack_info[ack_info->ack_info_num]);
+
+	write_seqlock_bh(&ack_info->seqlock);
+	msg = ack_info->msgbuf;
+	if (ack_info->busy && msg && !ack_info->in_send_msg) {
+		ack_info->msgbuf = NULL;
+		ack_info->drop_cnt = 0;
+		ack_info->in_send_msg = msg;
+		write_sequnlock_bh(&ack_info->seqlock);
+		intf_tx(ack_m->priv, msg);//send skb
+		//ack_info->in_send_msg = NULL;//add by dwx
+		//write_sequnlock_bh(&ack_info->seqlock);
+		//intf_tx(ack_m->priv, msg);
+		return;
+	}
+	write_sequnlock_bh(&ack_info->seqlock);
+}
+
+void tcp_ack_init(struct rwnx_hw *priv)
+{
+	int i;
+	struct tcp_ack_info *ack_info;
+	struct tcp_ack_manage *ack_m = &priv->ack_m;
+
+	printk("========== tcp ack debug %s \n",__func__);
+	memset(ack_m, 0, sizeof(struct tcp_ack_manage));
+	ack_m->priv = priv;
+	spin_lock_init(&ack_m->lock);
+	atomic_set(&ack_m->max_drop_cnt, TCP_ACK_DROP_CNT);
+	ack_m->last_time = jiffies;
+	ack_m->timeout = msecs_to_jiffies(ACK_OLD_TIME);
+
+	for (i = 0; i < TCP_ACK_NUM; i++) {
+		ack_info = &ack_m->ack_info[i];
+		ack_info->ack_info_num = i;
+		seqlock_init(&ack_info->seqlock);
+		ack_info->last_time = jiffies;
+		ack_info->timeout = msecs_to_jiffies(ACK_OLD_TIME);
+
+		#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0) 
+			setup_timer(&ack_info->timer, tcp_ack_timeout,
+				    (unsigned long)ack_info);
+		#else
+			timer_setup(&ack_info->timer,tcp_ack_timeout,0);
+		#endif
+	}
+
+	atomic_set(&ack_m->enable, 1);
+	ack_m->ack_winsize = MIN_WIN;
+}
+
+void tcp_ack_deinit(struct rwnx_hw *priv)
+{
+	int i;
+	struct tcp_ack_manage *ack_m = &priv->ack_m;
+	struct msg_buf *drop_msg = NULL;
+
+	printk("%s \n",__func__);
+	atomic_set(&ack_m->enable, 0);
+
+	for (i = 0; i < TCP_ACK_NUM; i++) {
+		drop_msg = NULL;
+
+		write_seqlock_bh(&ack_m->ack_info[i].seqlock);
+		del_timer(&ack_m->ack_info[i].timer);
+		drop_msg = ack_m->ack_info[i].msgbuf;
+		ack_m->ack_info[i].msgbuf = NULL;
+		write_sequnlock_bh(&ack_m->ack_info[i].seqlock);
+
+		if (drop_msg)
+			intf_tcp_drop_msg(priv, drop_msg);//drop skb
+	}
+}
+
+int tcp_check_quick_ack(unsigned char *buf,
+				      struct tcp_ack_msg *msg)
+{
+	int ip_hdr_len;
+	unsigned char *temp;
+	struct ethhdr *ethhdr;
+	struct iphdr *iphdr;
+	struct tcphdr *tcphdr;
+
+	ethhdr = (struct ethhdr *)buf;
+	if (ethhdr->h_proto != htons(ETH_P_IP))
+		return 0;
+	iphdr = (struct iphdr *)(ethhdr + 1);
+	if (iphdr->version != 4 || iphdr->protocol != IPPROTO_TCP)
+		return 0;
+	ip_hdr_len = iphdr->ihl * 4;
+	temp = (unsigned char *)(iphdr) + ip_hdr_len;
+	tcphdr = (struct tcphdr *)temp;
+	/* TCP_FLAG_ACK */
+	if (!(temp[13] & 0x10))
+		return 0;
+
+	if (temp[13] & 0x8) {
+		msg->saddr = iphdr->daddr;
+		msg->daddr = iphdr->saddr;
+		msg->source = tcphdr->dest;
+		msg->dest = tcphdr->source;
+		msg->seq = ntohl(tcphdr->seq);
+		return 1;
+	}
+
+	return 0;
+}
+
+int is_drop_tcp_ack(struct tcphdr *tcphdr, int tcp_tot_len,
+				unsigned short *win_scale)
+{
+	//printk("%s \n",__func__);
+	int drop = 1;
+	int len = tcphdr->doff * 4;
+	unsigned char *ptr;
+
+	if(tcp_tot_len > len) {
+		drop = 0;
+	} else {
+		len -= sizeof(struct tcphdr);
+		ptr = (unsigned char *)(tcphdr + 1);
+
+		while ((len > 0) && drop) {
+			int opcode = *ptr++;
+			int opsize;
+
+			switch (opcode) {
+			case TCPOPT_EOL:
+				break;
+			case TCPOPT_NOP:
+				len--;
+				continue;
+			default:
+				opsize = *ptr++;
+				if (opsize < 2)
+					break;
+				if (opsize > len)
+					break;
+
+				switch (opcode) {
+				/* TODO: Add other ignore opt */
+				case TCPOPT_TIMESTAMP:
+					break;
+				case TCPOPT_WINDOW:
+					if (*ptr < 15)
+						*win_scale = (1 << (*ptr));
+					//printk("%d\n",*win_scale);
+					break;
+				default:
+					drop = 2;
+				}
+
+				ptr += opsize - 2;
+				len -= opsize;
+			}
+		}
+	}
+
+	return drop;
+}
+
+
+/* flag:0 for not tcp ack
+ *	1 for ack which can be drop
+ *	2 for other ack whith more info
+ */
+
+int tcp_check_ack(unsigned char *buf,
+				struct tcp_ack_msg *msg,
+				unsigned short *win_scale)
+{
+	int ret;
+	int ip_hdr_len;
+	int tcp_tot_len;
+	unsigned char *temp;
+	struct ethhdr *ethhdr;
+	struct iphdr *iphdr;
+	struct tcphdr *tcphdr;
+
+	ethhdr =(struct ethhdr *)buf;
+	if (ethhdr->h_proto != htons(ETH_P_IP))
+		return 0;
+
+	iphdr = (struct iphdr *)(ethhdr + 1);
+	if (iphdr->version != 4 || iphdr->protocol != IPPROTO_TCP)
+		return 0;
+
+	ip_hdr_len = iphdr->ihl * 4;
+	temp = (unsigned char *)(iphdr) + ip_hdr_len;
+	tcphdr = (struct tcphdr *)temp;
+	/* TCP_FLAG_ACK */
+	if (!(temp[13] & 0x10))
+		return 0;
+
+	tcp_tot_len = ntohs(iphdr->tot_len) - ip_hdr_len;// tcp total len
+	ret = is_drop_tcp_ack(tcphdr, tcp_tot_len, win_scale);
+	//printk("is drop:%d \n",ret);
+
+	if (ret > 0) {
+		msg->saddr = iphdr->saddr;
+		msg->daddr = iphdr->daddr;
+		msg->source = tcphdr->source;
+		msg->dest = tcphdr->dest;
+		msg->seq = ntohl(tcphdr->ack_seq);
+		msg->win = ntohs(tcphdr->window);
+	}
+	
+	return ret;
+}
+
+/* return val: -1 for not match, others for match */
+int tcp_ack_match(struct tcp_ack_manage *ack_m,
+				struct tcp_ack_msg *ack_msg)
+{
+	int i, ret = -1;
+	unsigned start;
+	struct tcp_ack_info *ack_info;
+	struct tcp_ack_msg *ack;
+
+	for (i = 0; ((ret < 0) && (i < TCP_ACK_NUM)); i++) {
+		ack_info = &ack_m->ack_info[i];
+		do {
+			start = read_seqbegin(&ack_info->seqlock);
+			ret = -1;
+
+			ack = &ack_info->ack_msg;
+			if (ack_info->busy &&
+			    ack->dest == ack_msg->dest &&
+			    ack->source == ack_msg->source &&
+			    ack->saddr == ack_msg->saddr &&
+			    ack->daddr == ack_msg->daddr)
+				ret = i;
+		} while(read_seqretry(&ack_info->seqlock, start));
+	}
+
+	return ret;
+}
+
+
+void tcp_ack_update(struct tcp_ack_manage *ack_m)
+{
+	int i;
+	struct tcp_ack_info *ack_info;
+
+	if (time_after(jiffies, ack_m->last_time + ack_m->timeout)) {
+		spin_lock_bh(&ack_m->lock);
+		ack_m->last_time = jiffies;
+		for (i = TCP_ACK_NUM - 1; i >= 0; i--) {
+			ack_info = &ack_m->ack_info[i];
+			write_seqlock_bh(&ack_info->seqlock);
+			if (ack_info->busy &&
+			    time_after(jiffies, ack_info->last_time +
+				       ack_info->timeout)) {
+				ack_m->free_index = i;
+				ack_m->max_num--;
+				ack_info->busy = 0;
+			}
+			write_sequnlock_bh(&ack_info->seqlock);
+		}
+		spin_unlock_bh(&ack_m->lock);
+	}
+}
+
+/* return val: -1 for no index, others for index */
+int tcp_ack_alloc_index(struct tcp_ack_manage *ack_m)
+{
+	int i, ret = -1;
+	struct tcp_ack_info *ack_info;
+	unsigned start;
+
+	spin_lock_bh(&ack_m->lock);
+	if (ack_m->max_num == TCP_ACK_NUM) {
+		spin_unlock_bh(&ack_m->lock);
+		return -1;
+	}
+
+	if (ack_m->free_index >= 0) {
+		i = ack_m->free_index;
+		ack_m->free_index = -1;
+		ack_m->max_num++;
+		spin_unlock_bh(&ack_m->lock);
+		return i;
+	}
+
+	for (i = 0; ((ret < 0) && (i < TCP_ACK_NUM)); i++) {
+		ack_info = &ack_m->ack_info[i];
+		do {
+			start = read_seqbegin(&ack_info->seqlock);
+			ret = -1;
+			if (!ack_info->busy) {
+				ack_m->free_index = -1;
+				ack_m->max_num++;
+				ret = i;
+			}
+		} while(read_seqretry(&ack_info->seqlock, start));
+	}
+	spin_unlock_bh(&ack_m->lock);
+
+	return ret;
+}
+
+
+/* return val: 0 for not handle tx, 1 for handle tx */
+int tcp_ack_handle(struct msg_buf *new_msgbuf,
+			  struct tcp_ack_manage *ack_m,
+			  struct tcp_ack_info *ack_info,
+			  struct tcp_ack_msg *ack_msg,
+			  int type)
+{
+	int quick_ack = 0;
+	struct tcp_ack_msg *ack;
+	int ret = 0;
+	struct msg_buf *drop_msg = NULL;
+
+	//printk("%s %d",__func__,type);
+	write_seqlock_bh(&ack_info->seqlock);
+
+	ack_info->last_time = jiffies;
+	ack = &ack_info->ack_msg;
+
+	if (type == 2) {
+		if (U32_BEFORE(ack->seq, ack_msg->seq)) {
+			ack->seq = ack_msg->seq;
+			if (ack_info->psh_flag &&
+			    !U32_BEFORE(ack_msg->seq,
+					       ack_info->psh_seq)) {
+				ack_info->psh_flag = 0;
+			}
+
+			if (ack_info->msgbuf) {
+				//printk("%lx \n",ack_info->msgbuf);
+				drop_msg = ack_info->msgbuf;
+				ack_info->msgbuf = NULL;
+				del_timer(&ack_info->timer);
+			}else{
+				//printk("msgbuf is NULL \n");
+			}
+
+			ack_info->in_send_msg = NULL;
+			ack_info->drop_cnt = atomic_read(&ack_m->max_drop_cnt);
+		} else {
+			printk("%s before abnormal ack: %d, %d\n",
+			       __func__, ack->seq, ack_msg->seq);
+			drop_msg = new_msgbuf;
+			ret = 1;
+		}
+	} else if (U32_BEFORE(ack->seq, ack_msg->seq)) {
+		if (ack_info->msgbuf) {
+			drop_msg = ack_info->msgbuf;
+			ack_info->msgbuf = NULL;
+		}
+
+		if (ack_info->psh_flag &&
+		    !U32_BEFORE(ack_msg->seq, ack_info->psh_seq)) {
+			ack_info->psh_flag = 0;
+			quick_ack = 1;
+		} else {
+			ack_info->drop_cnt++;
+		}
+
+		ack->seq = ack_msg->seq;
+
+		if (quick_ack || (!ack_info->in_send_msg &&
+				  (ack_info->drop_cnt >=
+				   atomic_read(&ack_m->max_drop_cnt)))) {
+			ack_info->drop_cnt = 0;
+			ack_info->in_send_msg = new_msgbuf;
+			del_timer(&ack_info->timer);
+		} else {
+			ret = 1;
+			ack_info->msgbuf = new_msgbuf;
+			if (!timer_pending(&ack_info->timer))
+				mod_timer(&ack_info->timer,
+					  (jiffies + msecs_to_jiffies(5)));
+		}
+	} else {
+		printk("%s before ack: %d, %d\n",
+		       __func__, ack->seq, ack_msg->seq);
+		drop_msg = new_msgbuf;
+		ret = 1;
+	}
+
+	write_sequnlock_bh(&ack_info->seqlock);
+
+	if (drop_msg)
+		intf_tcp_drop_msg(ack_m->priv, drop_msg);// drop skb
+
+	return ret;
+}
+
+int tcp_ack_handle_new(struct msg_buf *new_msgbuf,
+			  struct tcp_ack_manage *ack_m,
+			  struct tcp_ack_info *ack_info,
+			  struct tcp_ack_msg *ack_msg,
+			  int type)
+{
+	int quick_ack = 0;
+	struct tcp_ack_msg *ack;
+	int ret = 0;
+	struct msg_buf *drop_msg = NULL;
+	//struct msg_buf * send_msg = NULL;
+	//printk("",);
+	write_seqlock_bh(&ack_info->seqlock);
+
+        ack_info->last_time = jiffies;
+        ack = &ack_info->ack_msg;
+
+	if(U32_BEFORE(ack->seq, ack_msg->seq)){
+		if (ack_info->msgbuf) {
+			drop_msg = ack_info->msgbuf;
+			ack_info->msgbuf = NULL;
+			//ack_info->drop_cnt++;
+		}
+
+		if (ack_info->psh_flag &&
+		    !U32_BEFORE(ack_msg->seq, ack_info->psh_seq)) {
+			ack_info->psh_flag = 0;
+			quick_ack = 1;
+		} else {
+			ack_info->drop_cnt++;
+		}
+
+		ack->seq = ack_msg->seq;
+
+		if(quick_ack || (!ack_info->in_send_msg &&
+				  (ack_info->drop_cnt >=
+				   atomic_read(&ack_m->max_drop_cnt)))){
+			ack_info->drop_cnt = 0;
+			//send_msg = new_msgbuf;
+			ack_info->in_send_msg = new_msgbuf;
+			del_timer(&ack_info->timer);
+		}else{
+			ret = 1;
+			ack_info->msgbuf = new_msgbuf;
+			if (!timer_pending(&ack_info->timer))
+				mod_timer(&ack_info->timer,
+					  (jiffies + msecs_to_jiffies(5)));
+		}
+		
+		//ret = 1;
+	}else {
+		printk("%s before ack: %d, %d\n",
+		       __func__, ack->seq, ack_msg->seq);
+		drop_msg = new_msgbuf;
+		ret = 1;
+	}
+
+	/*if(send_msg){
+		intf_tx(ack_m->priv,send_msg);
+		ack_info->in_send_msg=NULL;
+	}*/
+
+	//ack_info->in_send_msg=NULL;
+	
+	write_sequnlock_bh(&ack_info->seqlock);
+
+    	/*if(send_msg){
+            intf_tx(ack_m->priv,send_msg);
+            //ack_info->in_send_msg=NULL;
+    	}*/
+
+	if (drop_msg)
+		intf_tcp_drop_msg(ack_m->priv, drop_msg);// drop skb
+
+	return ret;
+
+}
+
+void filter_rx_tcp_ack(struct rwnx_hw *priv,
+			      unsigned char *buf, unsigned plen)
+{
+	int index;
+	struct tcp_ack_msg ack_msg;
+	struct tcp_ack_info *ack_info;
+	struct tcp_ack_manage *ack_m = &priv->ack_m;
+
+	if (!atomic_read(&ack_m->enable))
+		return;
+
+	if ((plen > MAX_TCP_ACK) ||
+	    !tcp_check_quick_ack(buf, &ack_msg))
+		return;
+
+	index = tcp_ack_match(ack_m, &ack_msg);
+	if (index >= 0) {
+		ack_info = ack_m->ack_info + index;
+		write_seqlock_bh(&ack_info->seqlock);
+		ack_info->psh_flag = 1;
+		ack_info->psh_seq = ack_msg.seq;
+		write_sequnlock_bh(&ack_info->seqlock);
+	}
+}
+
+/* return val: 0 for not filter, 1 for filter */
+int filter_send_tcp_ack(struct rwnx_hw *priv,
+			       struct msg_buf *msgbuf,
+			       unsigned char *buf, unsigned int plen)
+{
+//	printk("%s \n",__func__);
+	int ret = 0;
+	int index, drop;
+	unsigned short win_scale = 0;
+	unsigned int win = 0;
+	struct tcp_ack_msg ack_msg;
+	struct tcp_ack_msg *ack;
+	struct tcp_ack_info *ack_info;
+	struct tcp_ack_manage *ack_m = &priv->ack_m;
+
+	tcp_ack_update(ack_m);
+	drop = tcp_check_ack(buf, &ack_msg, &win_scale);
+//	printk("drop:%d win_scale:%d",drop,win_scale);
+	if (!drop && (0 == win_scale))
+		return 0;
+
+	index = tcp_ack_match(ack_m, &ack_msg);
+	if (index >= 0) {
+		ack_info = ack_m->ack_info + index;
+		if ((0 != win_scale) &&
+			(ack_info->win_scale != win_scale)) {
+			write_seqlock_bh(&ack_info->seqlock);
+			ack_info->win_scale = win_scale;
+			write_sequnlock_bh(&ack_info->seqlock);
+		}
+
+		if (drop > 0 && atomic_read(&ack_m->enable)) {
+			win = ack_info->win_scale * ack_msg.win;
+			if ((win_scale!=0) && (win < (ack_m->ack_winsize * SIZE_KB)))
+			{	
+				drop = 2;
+				printk("%d %d %d",win_scale,win,(ack_m->ack_winsize * SIZE_KB));
+			}
+			ret = tcp_ack_handle_new(msgbuf, ack_m, ack_info,
+						&ack_msg, drop);
+		}
+
+		goto out;
+	}
+
+	index = tcp_ack_alloc_index(ack_m);
+	if (index >= 0) {
+		write_seqlock_bh(&ack_m->ack_info[index].seqlock);
+		ack_m->ack_info[index].busy = 1;
+		ack_m->ack_info[index].psh_flag = 0;
+		ack_m->ack_info[index].last_time = jiffies;
+		ack_m->ack_info[index].drop_cnt =
+			atomic_read(&ack_m->max_drop_cnt);
+		ack_m->ack_info[index].win_scale =
+			(win_scale != 0) ? win_scale : 1;
+		
+		//ack_m->ack_info[index].msgbuf = NULL;
+		//ack_m->ack_info[index].in_send_msg = NULL;
+		ack = &ack_m->ack_info[index].ack_msg;
+		ack->dest = ack_msg.dest;
+		ack->source = ack_msg.source;
+		ack->saddr = ack_msg.saddr;
+		ack->daddr = ack_msg.daddr;
+		ack->seq = ack_msg.seq;
+		write_sequnlock_bh(&ack_m->ack_info[index].seqlock);
+	}
+
+out:
+	return ret;
+}
+
+void move_tcpack_msg(struct rwnx_hw *priv,
+			    struct msg_buf *msg)
+{
+	struct tcp_ack_info *ack_info;
+	struct tcp_ack_manage *ack_m = &priv->ack_m;
+	int i = 0;
+
+	if (!atomic_read(&ack_m->enable))
+		return;
+
+	//if (msg->len > MAX_TCP_ACK)
+	//	return;
+
+	for (i = 0; i < TCP_ACK_NUM; i++) {
+		ack_info = &ack_m->ack_info[i];
+		write_seqlock_bh(&ack_info->seqlock);
+		if (ack_info->busy && (ack_info->in_send_msg == msg))
+			ack_info->in_send_msg = NULL;
+		write_sequnlock_bh(&ack_info->seqlock);
+	}
+}
+
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.h
new file mode 100644
index 000000000000..d872e635cf02
--- /dev/null
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.h
@@ -0,0 +1,111 @@
+#ifndef _AICWF_TCP_ACK_H_
+#define _AICWF_TCP_ACK_H_
+
+#include <uapi/linux/if_ether.h>
+#include <uapi/linux/tcp.h>
+#include <uapi/linux/ip.h>
+#include <uapi/linux/in.h>
+#include <linux/moduleparam.h>
+#include <net/tcp.h>
+#include <linux/timer.h>
+
+
+#define TCP_ACK_NUM  32
+#define TCP_ACK_EXIT_VAL		0x800
+#define TCP_ACK_DROP_CNT		10
+
+#define ACK_OLD_TIME	4000
+#define U32_BEFORE(a, b)	((__s32)((__u32)a - (__u32)b) <= 0)
+
+#define MAX_TCP_ACK 200
+/*min window size in KB, it's 256KB*/
+#define MIN_WIN 256
+#define SIZE_KB 1024
+
+
+struct msg_buf {
+	//struct list_head list;
+	struct sk_buff *skb;
+	struct rwnx_vif *rwnx_vif;
+
+	/* data just tx cmd use,not include the head */
+	/*void *data;
+	void *tran_data;
+	unsigned long pcie_addr;
+	u8 type;
+	u8 mode;
+	u16 len;
+	unsigned long timeout;*/
+
+	/*unsigned int fifo_id;
+	struct sprdwl_msg_list *msglist;*/
+
+	/*unsigned char buffer_type;
+	struct sprdwl_xmit_msg_list *xmit_msg_list;
+	unsigned char msg_type;
+
+	unsigned long last_time;
+	u8 ctxt_id;*/
+
+};
+
+struct tcp_ack_msg {
+	u16 source;
+	u16 dest;
+	s32 saddr;
+	s32 daddr;
+	u32 seq;
+	u16 win;
+};
+
+
+struct tcp_ack_info {
+	int ack_info_num;
+	int busy;
+	int drop_cnt;
+	int psh_flag;
+	u32 psh_seq;
+	u16 win_scale;
+	/* seqlock for ack info */
+	seqlock_t seqlock;
+	unsigned long last_time;
+	unsigned long timeout;
+	struct timer_list timer;
+	struct msg_buf *msgbuf;
+	struct msg_buf *in_send_msg;
+	struct tcp_ack_msg ack_msg;
+};
+
+struct tcp_ack_manage {
+	/* 1 filter */
+	atomic_t enable;
+	int max_num;
+	int free_index;
+	unsigned long last_time;
+	unsigned long timeout;
+	atomic_t max_drop_cnt;
+	/* lock for tcp ack alloc and free */
+	spinlock_t lock;
+	struct rwnx_hw *priv;
+	struct tcp_ack_info ack_info[TCP_ACK_NUM];
+	/*size in KB*/
+	unsigned int ack_winsize;
+};
+
+struct msg_buf *intf_tcp_alloc_msg(struct msg_buf *msg);
+
+void tcp_ack_init(struct rwnx_hw *priv);
+
+void tcp_ack_deinit(struct rwnx_hw *priv);
+
+
+int is_drop_tcp_ack(struct tcphdr *tcphdr, int tcp_tot_len, unsigned short *win_scale);
+
+int is_tcp_ack(struct sk_buff *skb, unsigned short *win_scale);
+
+int filter_send_tcp_ack(struct rwnx_hw *priv, struct msg_buf *msgbuf,unsigned char *buf, unsigned int plen);
+
+void filter_rx_tcp_ack(struct rwnx_hw *priv,unsigned char *buf, unsigned plen);
+
+void move_tcpack_msg(struct rwnx_hw *priv, struct msg_buf * msg);
+#endif
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.c
index 34b91d596717..c27d2d07d009 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.c
@@ -108,8 +108,7 @@ int aicwf_bus_init(uint bus_hdrlen, struct device *dev)
     init_completion(&bus_if->bustx_trgg);
     init_completion(&bus_if->busrx_trgg);
 #ifdef CONFIG_USB_MSG_IN_EP
-	if(bus_if->bus_priv.usb->chipid != PRODUCT_ID_AIC8801 &&
-        bus_if->bus_priv.usb->chipid != PRODUCT_ID_AIC8800D81){
+	if(bus_if->bus_priv.usb->msg_in_pipe) {
 		init_completion(&bus_if->msg_busrx_trgg);
 	}
 #endif
@@ -139,8 +138,8 @@ int aicwf_bus_init(uint bus_hdrlen, struct device *dev)
 #endif
 	
 #ifdef CONFIG_USB_MSG_IN_EP
-	if(bus_if->bus_priv.usb->chipid != PRODUCT_ID_AIC8801 &&
-        bus_if->bus_priv.usb->chipid != PRODUCT_ID_AIC8800D81){
+	if(bus_if->bus_priv.usb->msg_in_pipe)
+	{
 		bus_if->msg_busrx_thread = kthread_run(usb_msg_busrx_thread, (void *)bus_if->bus_priv.usb->rx_priv, "aicwf_msg_busrx_thread");
 	}
 #endif
@@ -175,8 +174,7 @@ int aicwf_bus_init(uint bus_hdrlen, struct device *dev)
     }
 
 #ifdef CONFIG_USB_MSG_IN_EP
-	if(bus_if->bus_priv.usb->chipid != PRODUCT_ID_AIC8801 &&
-        bus_if->bus_priv.usb->chipid != PRODUCT_ID_AIC8800D81){
+	if(bus_if->bus_priv.usb->msg_in_pipe){
 		if (IS_ERR(bus_if->msg_busrx_thread)) {
 			bus_if->msg_busrx_thread  = NULL;
 			txrx_err("aicwf_msg_busrx_thread run fail\n");
@@ -253,6 +251,11 @@ void aicwf_bus_deinit(struct device *dev)
         bus_if->bustx_thread = NULL;
     }
 
+    if (usb->rx_priv)
+        aicwf_rx_deinit(usb->rx_priv);
+
+    rwnx_cmd_mgr_deinit(&usb->cmd_mgr);
+
 #ifdef CONFIG_TX_TASKLET//AIDEN tasklet
 		tasklet_kill(&usb->xmit_tasklet);
 #endif
@@ -320,22 +323,42 @@ void aicwf_tx_deinit(struct aicwf_tx_priv* tx_priv)
     kfree(tx_priv);
 }
 
-static bool aicwf_another_ptk(struct sk_buff *skb)
+#ifdef CONFIG_PREALLOC_RX_SKB
+static bool aicwf_another_ptk_1(struct rx_buff *buffer)
 {
-    u8 *data;
+    u8 *read = buffer->read;
     u16 aggr_len = 0;
 
-    if(skb->data == NULL || skb->len == 0) {
+    if(read == NULL || read >= buffer->end) {
         return false;
     }
-    data = skb->data;
-    aggr_len = (*skb->data | (*(skb->data + 1) << 8));
+
+    aggr_len = (*read | (*(read + 1) << 8));
     if(aggr_len == 0) {
         return false;
     }
 
     return true;
 }
+#else
+static bool aicwf_another_ptk(struct sk_buff *skb)
+{
+	u8 *data;
+	u16 aggr_len = 0;
+
+	if (skb->data == NULL || skb->len == 0) {
+		return false;
+	}
+	data = skb->data;
+	aggr_len = (*skb->data | (*(skb->data + 1) << 8));
+	if (aggr_len == 0) {
+		return false;
+	}
+
+	return true;
+}
+#endif
+
 
 #if 0//AIDEN
 void rwnx_frame_parser(char* tag, char* data, unsigned long len);
@@ -371,12 +394,13 @@ int aicwf_tasklet_rxframes(struct aicwf_rx_priv *rx_priv)
 			data = skb->data;
 			pkt_len = (*skb->data | (*(skb->data + 1) << 8));
 			//printk("p:%d, s:%d , %x\n", pkt_len, skb->len, data[2]);
+#ifndef CONFIG_USB_RX_REASSEMBLE
 			if (pkt_len > 1600) {
 				dev_kfree_skb(skb);
 				atomic_dec(&rx_priv->rx_cnt);
 					continue;
 			}
-	
+#endif
 			if((skb->data[2] & USB_TYPE_CFG) != USB_TYPE_CFG) { // type : data
 #if 0
 			aggr_len = pkt_len + RX_HWHRD_LEN;
@@ -434,6 +458,7 @@ int aicwf_tasklet_rxframes(struct aicwf_rx_priv *rx_priv)
 	}
 #endif
 
+extern bool rx_urb_sched;
 int aicwf_process_rxframes(struct aicwf_rx_priv *rx_priv)
 {
 #ifdef AICWF_SDIO_SUPPORT
@@ -520,87 +545,175 @@ int aicwf_process_rxframes(struct aicwf_rx_priv *rx_priv)
     unsigned long flags = 0;
 #ifndef CONFIG_PREALLOC_RX_SKB
     struct sk_buff *skb = NULL;/* Packet for event or data frames */
-#else
-    struct sk_buff *skb_inblock = NULL;
 #endif
+    struct sk_buff *skb_inblock = NULL;
+
     u16 pkt_len = 0;
     u16 aggr_len = 0, adjust_len = 0;
     u8 *data = NULL;
     u8_l *msg = NULL;
 //#ifdef CONFIG_USB_RX_AGGR
-    struct sk_buff *skb_inblock = NULL;
+//    struct sk_buff *skb_inblock = NULL;
     u8 cnt = 0 ;
 //#endif
 #ifdef CONFIG_PREALLOC_RX_SKB
     struct rx_buff *buffer = NULL;
-    while (1) {
-        spin_lock_irqsave(&rx_priv->rxqlock, flags);
-        if (!rx_priv->rxq.qcnt) {
-            usb_info("no more rxdata\n");
-            spin_unlock_irqrestore(&rx_priv->rxqlock,flags);
-            break;
-        }
-        buffer = rxbuff_dequeue(&rx_priv->rxq);
-        spin_unlock_irqrestore(&rx_priv->rxqlock, flags);
-		
-        if (buffer == NULL) {
-            txrx_err("skb_error\r\n");
-            ASSERT_ERR(1);
-            break;
-        }
-        data = buffer->data;
-        pkt_len = (*data | (*(data + 1) << 8));
-        //printk("p:%d, s:%d , %x\n", pkt_len, skb->len, data[2]);
-        if (pkt_len > 1600) {
+    if(aicwf_usb_rx_aggr){
+        while (1) {
+            spin_lock_irqsave(&rx_priv->rxqlock, flags);
+            if (!rx_priv->rxq.qcnt) {
+                usb_info("no more rxdata\n");
+                spin_unlock_irqrestore(&rx_priv->rxqlock,flags);
+                break;
+            }
+            buffer = rxbuff_dequeue(&rx_priv->rxq);
+            spin_unlock_irqrestore(&rx_priv->rxqlock, flags);
+            
+            if (buffer == NULL) {
+                txrx_err("skb_error\r\n");
+                ASSERT_ERR(1);
+                break;
+            }
+
+            while(aicwf_another_ptk_1(buffer)) {
+                cnt++;
+                data = buffer->read;
+                pkt_len = (*data | (*(data + 1) << 8));
+                //printk("%s cnt:%d pkt_len:%d \r\n", __func__, cnt, pkt_len);
+#ifndef CONFIG_USB_RX_REASSEMBLE
+                if (pkt_len > 1600) {
+                    AICWFDBG(LOGERROR, "%s pkt_len > 1600 \r\n", __func__);
+                    aicwf_prealloc_rxbuff_free(buffer, &rx_priv->rxbuff_lock);
+                    atomic_dec(&rx_priv->rx_cnt);
+                    return -EBADE;
+                }
+#endif
+               
+                if((data[2] & USB_TYPE_CFG) != USB_TYPE_CFG) { // type : data
+                	aggr_len = pkt_len + RX_HWHRD_LEN;
+                    
+                    skb_inblock = __dev_alloc_skb(aggr_len + CCMP_OR_WEP_INFO, GFP_KERNEL);
+                    if (skb_inblock == NULL) {
+                        txrx_err("no more space! skip\n");
+                        aicwf_prealloc_rxbuff_free(buffer, &rx_priv->rxbuff_lock);
+                        atomic_dec(&rx_priv->rx_cnt);
+                        return -EBADE;
+                    }
+                    
+                    skb_put(skb_inblock, aggr_len);
+                    memcpy(skb_inblock->data, data, aggr_len);
+                    rwnx_rxdataind_aicwf(rx_priv->usbdev->rwnx_hw, skb_inblock, (void *)rx_priv);
+                    buffer->read = buffer->read + aggr_len;
+                }
+                else { //  type : config
+                    aggr_len = pkt_len;
+                    if (aggr_len & (RX_ALIGNMENT - 1))
+                        adjust_len = roundup(aggr_len, RX_ALIGNMENT);
+                    else
+                        adjust_len = aggr_len;
+
+                    msg = kmalloc(aggr_len+4, GFP_KERNEL);
+                    if(msg == NULL){
+                        txrx_err("no more space for msg!\n");
+                        aicwf_prealloc_rxbuff_free(buffer, &rx_priv->rxbuff_lock);
+                        return -EBADE;
+                    }
+                    memcpy(msg, data, aggr_len + 4);
+            
+                    if(((*(msg + 2) & 0x7f) == USB_TYPE_CFG_CMD_RSP) && (rx_priv->usbdev->bus_if->state != (int)USB_DOWN_ST))
+                        rwnx_rx_handle_msg(rx_priv->usbdev->rwnx_hw, (struct ipc_e2a_msg *)(msg + 4));
+            
+                    if((*(msg + 2) & 0x7f) == USB_TYPE_CFG_DATA_CFM)
+                        aicwf_usb_host_tx_cfm_handler(&(rx_priv->usbdev->rwnx_hw->usb_env), (u32 *)(msg + 4));
+            
+                    if ((*(msg + 2) & 0x7f) == USB_TYPE_CFG_PRINT)
+                        rwnx_rx_handle_print(rx_priv->usbdev->rwnx_hw, msg + 4, aggr_len);
+
+                    buffer->read = buffer->read + (adjust_len + 4);
+                    kfree(msg);
+                }
+            }
             aicwf_prealloc_rxbuff_free(buffer, &rx_priv->rxbuff_lock);
+            if (rx_urb_sched) {
+		schedule_work(&rx_priv->usbdev->rx_urb_work);
+		rx_urb_sched = false;
+            }
             atomic_dec(&rx_priv->rx_cnt);
-            continue;
         }
-
-        if((data[2] & USB_TYPE_CFG) != USB_TYPE_CFG) { // type : data
-            skb_inblock = __dev_alloc_skb(pkt_len + RX_HWHRD_LEN + CCMP_OR_WEP_INFO, GFP_KERNEL);
-            if (skb_inblock == NULL) {
-                txrx_err("no more space! skip\n");
+    }else{
+        while (1) {
+            spin_lock_irqsave(&rx_priv->rxqlock, flags);
+            if (!rx_priv->rxq.qcnt) {
+                usb_info("no more rxdata\n");
+                spin_unlock_irqrestore(&rx_priv->rxqlock,flags);
+                break;
+            }
+            buffer = rxbuff_dequeue(&rx_priv->rxq);
+            spin_unlock_irqrestore(&rx_priv->rxqlock, flags);
+            
+            if (buffer == NULL) {
+                txrx_err("skb_error\r\n");
+                ASSERT_ERR(1);
+                break;
+            }
+            data = buffer->data;
+            pkt_len = (*data | (*(data + 1) << 8));
+            //printk("p:%d, s:%d , %x\n", pkt_len, skb->len, data[2]);
+#ifndef CONFIG_USB_RX_REASSEMBLE
+            if (pkt_len > 1600) {
                 aicwf_prealloc_rxbuff_free(buffer, &rx_priv->rxbuff_lock);
                 atomic_dec(&rx_priv->rx_cnt);
                 continue;
             }
+#endif
+            if((data[2] & USB_TYPE_CFG) != USB_TYPE_CFG) { // type : data
+                skb_inblock = __dev_alloc_skb(pkt_len + RX_HWHRD_LEN + CCMP_OR_WEP_INFO, GFP_KERNEL);
+                if (skb_inblock == NULL) {
+                    txrx_err("no more space! skip\n");
+                    aicwf_prealloc_rxbuff_free(buffer, &rx_priv->rxbuff_lock);
+                    atomic_dec(&rx_priv->rx_cnt);
+                    continue;
+                }
+                
+                skb_put(skb_inblock, pkt_len + RX_HWHRD_LEN);
+                memcpy(skb_inblock->data, data, pkt_len + RX_HWHRD_LEN);
+                rwnx_rxdataind_aicwf(rx_priv->usbdev->rwnx_hw, skb_inblock, (void *)rx_priv);
+            }
+            else { //  type : config
+                aggr_len = pkt_len;
+                if (aggr_len & (RX_ALIGNMENT - 1))
+                    adjust_len = roundup(aggr_len, RX_ALIGNMENT);
+                else
+                    adjust_len = aggr_len;
+        
+                msg = kmalloc(aggr_len+4, GFP_KERNEL);
+                if(msg == NULL){
+                    txrx_err("no more space for msg!\n");
+                    aicwf_prealloc_rxbuff_free(buffer, &rx_priv->rxbuff_lock);
+                    return -EBADE;
+                }
+                memcpy(msg, data, aggr_len + 4);
+        
+                if(((*(msg + 2) & 0x7f) == USB_TYPE_CFG_CMD_RSP) && (rx_priv->usbdev->bus_if->state != (int)USB_DOWN_ST))
+                    rwnx_rx_handle_msg(rx_priv->usbdev->rwnx_hw, (struct ipc_e2a_msg *)(msg + 4));
+        
+                if((*(msg + 2) & 0x7f) == USB_TYPE_CFG_DATA_CFM)
+                    aicwf_usb_host_tx_cfm_handler(&(rx_priv->usbdev->rwnx_hw->usb_env), (u32 *)(msg + 4));
+        
+                if ((*(msg + 2) & 0x7f) == USB_TYPE_CFG_PRINT)
+                    rwnx_rx_handle_print(rx_priv->usbdev->rwnx_hw, msg + 4, aggr_len);
+        
+                kfree(msg);
+            }
             
-            skb_put(skb_inblock, pkt_len + RX_HWHRD_LEN);
-            memcpy(skb_inblock->data, data, pkt_len + RX_HWHRD_LEN);
-			rwnx_rxdataind_aicwf(rx_priv->usbdev->rwnx_hw, skb_inblock, (void *)rx_priv);
-        }
-        else { //  type : config
-            aggr_len = pkt_len;
-            if (aggr_len & (RX_ALIGNMENT - 1))
-                adjust_len = roundup(aggr_len, RX_ALIGNMENT);
-            else
-                adjust_len = aggr_len;
-
-            msg = kmalloc(aggr_len+4, GFP_KERNEL);
-            if(msg == NULL){
-                txrx_err("no more space for msg!\n");
-                aicwf_prealloc_rxbuff_free(buffer, &rx_priv->rxbuff_lock);
-                return -EBADE;
+            aicwf_prealloc_rxbuff_free(buffer, &rx_priv->rxbuff_lock);
+            if (rx_urb_sched) {
+                schedule_work(&rx_priv->usbdev->rx_urb_work);
+                rx_urb_sched = false;
             }
-            memcpy(msg, data, aggr_len + 4);
-
-            if(((*(msg + 2) & 0x7f) == USB_TYPE_CFG_CMD_RSP) && (rx_priv->usbdev->bus_if->state != (int)USB_DOWN_ST))
-                rwnx_rx_handle_msg(rx_priv->usbdev->rwnx_hw, (struct ipc_e2a_msg *)(msg + 4));
-
-            if((*(msg + 2) & 0x7f) == USB_TYPE_CFG_DATA_CFM)
-                aicwf_usb_host_tx_cfm_handler(&(rx_priv->usbdev->rwnx_hw->usb_env), (u32 *)(msg + 4));
-
-            if ((*(msg + 2) & 0x7f) == USB_TYPE_CFG_PRINT)
-                rwnx_rx_handle_print(rx_priv->usbdev->rwnx_hw, msg + 4, aggr_len);
-
-            kfree(msg);
+            atomic_dec(&rx_priv->rx_cnt);
         }
-        
-		aicwf_prealloc_rxbuff_free(buffer, &rx_priv->rxbuff_lock);
-        atomic_dec(&rx_priv->rx_cnt);
     }
-
 #else
 	if(aicwf_usb_rx_aggr){
 	    while (1) {
@@ -627,12 +740,15 @@ int aicwf_process_rxframes(struct aicwf_rx_priv *rx_priv)
 	        data = skb->data;
 	        pkt_len = (*skb->data | (*(skb->data + 1) << 8));
 	        //printk("p:%d, s:%d , %x\n", pkt_len, skb->len, data[2]);
+#ifndef CONFIG_USB_RX_REASSEMBLE
 	        if (pkt_len > 1600) {
-	            dev_kfree_skb(skb);
-	            atomic_dec(&rx_priv->rx_cnt);
-	                continue;
+                AICWFDBG(LOGERROR, "%s pkt_len > 1600 \r\n", __func__);
+	            //dev_kfree_skb(skb);
+	            //atomic_dec(&rx_priv->rx_cnt);
+	            //continue;
+	            break;
 	        }
-
+#endif
 	        if((skb->data[2] & USB_TYPE_CFG) != USB_TYPE_CFG) { // type : data
 				aggr_len = pkt_len + RX_HWHRD_LEN;
 				adjust_len = aggr_len;
@@ -659,7 +775,7 @@ int aicwf_process_rxframes(struct aicwf_rx_priv *rx_priv)
 	            else
 	                adjust_len = aggr_len;
 
-	            msg = kmalloc(aggr_len+4, GFP_KERNEL);
+	            msg = kmalloc(aggr_len+4, GFP_KERNEL);//hdr(4)+config(aggrlen)
 	            if(msg == NULL){
 	                txrx_err("no more space for msg!\n");
 	                aicwf_dev_skb_free(skb);
@@ -704,11 +820,13 @@ int aicwf_process_rxframes(struct aicwf_rx_priv *rx_priv)
 	        data = skb->data;
 	        pkt_len = (*skb->data | (*(skb->data + 1) << 8));
 	        //printk("p:%d, s:%d , %x\n", pkt_len, skb->len, data[2]);
+#ifndef CONFIG_USB_RX_REASSEMBLE
 	        if (pkt_len > 1600) {
 	            dev_kfree_skb(skb);
 	            atomic_dec(&rx_priv->rx_cnt);
 	                continue;
 	        }
+#endif
 
 	        if((skb->data[2] & USB_TYPE_CFG) != USB_TYPE_CFG) { // type : data
 				rwnx_rxdataind_aicwf(rx_priv->usbdev->rwnx_hw, skb, (void *)rx_priv);
@@ -896,8 +1014,7 @@ struct aicwf_rx_priv *aicwf_rx_init(void *arg)
     atomic_set(&rx_priv->rx_cnt, 0);
 
 #ifdef CONFIG_USB_MSG_IN_EP
-	if(rx_priv->usbdev->chipid != PRODUCT_ID_AIC8801 &&
-        rx_priv->usbdev->chipid != PRODUCT_ID_AIC8800D81){
+	if(rx_priv->usbdev->msg_in_pipe){
     	aicwf_frame_queue_init(&rx_priv->msg_rxq, 1, MAX_RXQLEN);
     	spin_lock_init(&rx_priv->msg_rxqlock);
     	atomic_set(&rx_priv->msg_rx_cnt, 0);
@@ -963,21 +1080,27 @@ void aicwf_rx_deinit(struct aicwf_rx_priv* rx_priv)
         rx_priv->usbdev->bus_if->busrx_thread = NULL;
     }
 #ifdef CONFIG_USB_MSG_IN_EP
-	if(rx_priv->usbdev->chipid != PRODUCT_ID_AIC8801 &&
-        rx_priv->usbdev->chipid != PRODUCT_ID_AIC8800D81){
+	if(rx_priv->usbdev->msg_in_pipe){
 		if (rx_priv->usbdev->bus_if->msg_busrx_thread) {
-			complete(&rx_priv->usbdev->bus_if->msg_busrx_trgg);
+			complete_all(&rx_priv->usbdev->bus_if->msg_busrx_trgg);
 			kthread_stop(rx_priv->usbdev->bus_if->msg_busrx_thread);
 			rx_priv->usbdev->bus_if->msg_busrx_thread = NULL;
 		}
 	}
 #endif
+#ifdef CONFIG_USB_RX_REASSEMBLE
+    if (rx_priv->rx_reassemble_skb) {
+        aicwf_dev_skb_free(rx_priv->rx_reassemble_skb);
+    }
+    if (rx_priv->rx_msg_reassemble_skb) {
+        aicwf_dev_skb_free(rx_priv->rx_msg_reassemble_skb);
+    }
+#endif
 
 #endif
 
 #ifdef CONFIG_USB_MSG_IN_EP
-	if(rx_priv->usbdev->chipid != PRODUCT_ID_AIC8801 &&
-        rx_priv->usbdev->chipid != PRODUCT_ID_AIC8800D81){
+	if(rx_priv->usbdev->msg_in_pipe){
 		aicwf_frame_queue_flush(&rx_priv->msg_rxq);
 	}
 #endif
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.h
index 5523988068bc..29971f9e6a9d 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.h
@@ -209,6 +209,19 @@ struct aicwf_rx_priv {
 #else
 	struct frame_queue rxq;
 #endif
+#ifdef CONFIG_USB_RX_REASSEMBLE
+    struct sk_buff *rx_reassemble_skb;
+    u32 rx_reassemble_total_len;
+    u32 rx_reassemble_cur_len;
+    u32 rx_reassemble_total_frags;
+    u32 rx_reassemble_cur_frags;
+
+    struct sk_buff *rx_msg_reassemble_skb;
+    u32 rx_msg_reassemble_total_len;
+    u32 rx_msg_reassemble_cur_len;
+    u32 rx_msg_reassemble_total_frags;
+    u32 rx_msg_reassemble_cur_frags;
+#endif
 
 #ifdef CONFIG_USB_MSG_IN_EP
 	atomic_t msg_rx_cnt;
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.c
index 607ff0ec4734..85f06557bbdf 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.c
@@ -8,6 +8,7 @@
 
 #include <linux/usb.h>
 #include <linux/kthread.h>
+#include <linux/vmalloc.h>
 #include "aicwf_txrxif.h"
 #include "aicwf_usb.h"
 #include "rwnx_tx.h"
@@ -35,7 +36,7 @@ extern atomic_t aicwf_deinit_atomic;
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0))
 #include "uapi/linux/sched/types.h"
-#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0))
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 15, 0))
 #include "linux/sched/types.h"
 #else
 #include "linux/sched/rt.h"
@@ -53,6 +54,7 @@ bool aicwf_usb_rx_aggr = true;
 bool aicwf_usb_rx_aggr = false;
 #endif
 atomic_t rx_urb_cnt;
+bool rx_urb_sched = false;
 
 void aicwf_usb_tx_flowctrl(struct rwnx_hw *rwnx_hw, bool state)
 {
@@ -295,7 +297,6 @@ static void aicwf_usb_rx_complete(struct urb *urb)
                     g_rwnx_plat->wait_disconnect_cb = true;
                     if(atomic_read(&aicwf_deinit_atomic) > 0){
                         atomic_set(&aicwf_deinit_atomic, 0);
-			AICWFDBG(LOGERROR, "%s in_interrupt:%d in_softirq:%d in_atomic:%d\r\n", __func__, (int)in_interrupt(), (int)in_softirq(), (int)in_atomic());
                         down(&aicwf_deinit_sem);
                         AICWFDBG(LOGINFO, "%s need to wait for disconnect callback \r\n", __func__);
                     }else{
@@ -313,7 +314,11 @@ static void aicwf_usb_rx_complete(struct urb *urb)
     
     if (usb_dev->state == USB_UP_ST) {
         spin_lock_irqsave(&rx_priv->rxqlock, flags);
-
+        if (aicwf_usb_rx_aggr) {
+	        rx_buff->len = urb->actual_length;
+            //printk("%s rx_buff->len:%d \r\n", __func__, rx_buff->len);
+        }
+        
         if(!aicwf_rxbuff_enqueue(usb_dev->dev, &rx_priv->rxq, rx_buff)){
             spin_unlock_irqrestore(&rx_priv->rxqlock, flags);
             usb_err("rx_priv->rxq is over flow!!!\n");
@@ -363,6 +368,7 @@ static void aicwf_usb_rx_complete(struct urb *urb)
 	}
 
     if (urb->actual_length > urb->transfer_buffer_length) {
+        usb_err("urb_rx len error %u/%u\n", urb->actual_length, urb->transfer_buffer_length);
         aicwf_dev_skb_free(skb);
         aicwf_usb_rx_buf_put(usb_dev, usb_buf);
         aicwf_usb_rx_submit_all_urb_(usb_dev);
@@ -379,7 +385,6 @@ static void aicwf_usb_rx_complete(struct urb *urb)
 				g_rwnx_plat->wait_disconnect_cb = true;
 				if(atomic_read(&aicwf_deinit_atomic) > 0){
 					atomic_set(&aicwf_deinit_atomic, 0);
-					AICWFDBG(LOGERROR, "%s in_interrupt:%d in_softirq:%d in_atomic:%d\r\n", __func__, (int)in_interrupt(), (int)in_softirq(), (int)in_atomic());
 					down(&aicwf_deinit_sem);
 					AICWFDBG(LOGINFO, "%s need to wait for disconnect callback \r\n", __func__);
 				}else{
@@ -395,18 +400,146 @@ static void aicwf_usb_rx_complete(struct urb *urb)
 		}
     }
 
+#if 0
     if ((urb->actual_length > 1600 * 30) && (aicwf_usb_rx_aggr)) {
 	printk("r%d\n", urb->actual_length);
     }
+#endif
 
     if (usb_dev->state == USB_UP_ST) {
 
         skb_put(skb, urb->actual_length);
 
-        spin_lock_irqsave(&rx_priv->rxqlock, flags);
         if (aicwf_usb_rx_aggr) {
-	    skb->len = urb->actual_length;
+            skb->len = urb->actual_length;
+        } else {
+#ifdef CONFIG_USB_RX_REASSEMBLE
+            bool pkt_check = false;
+            if (rx_priv->rx_reassemble_skb) {
+                u32 frag_len = skb->len;
+                struct sk_buff *reassemble_skb = rx_priv->rx_reassemble_skb;
+                bool reassemble_valid = false;
+                bool reassemble_done = false;
+                if ((rx_priv->rx_reassemble_cur_frags + 1) == rx_priv->rx_reassemble_total_frags) {
+                    if ((rx_priv->rx_reassemble_cur_len + frag_len) == rx_priv->rx_reassemble_total_len) {
+                        reassemble_valid = true;
+                        reassemble_done = true;
+                    }
+                } else {
+                    if (frag_len == AICWF_USB_MAX_PKT_SIZE) {
+                        reassemble_valid = true;
+                    }
+                }
+
+                if (reassemble_valid) {
+                    memcpy((reassemble_skb->data + reassemble_skb->len), skb->data, frag_len);
+                    skb_put(reassemble_skb, skb->len);
+                    rx_priv->rx_reassemble_cur_len += frag_len;
+                    rx_priv->rx_reassemble_cur_frags++;
+                    aicwf_dev_skb_free(skb);
+                    if (reassemble_done) {
+                        skb = reassemble_skb;
+                        rx_priv->rx_reassemble_skb = NULL;
+                        rx_priv->rx_reassemble_total_len = 0;
+                        rx_priv->rx_reassemble_cur_len = 0;
+                        rx_priv->rx_reassemble_total_frags = 0;
+                        rx_priv->rx_reassemble_cur_frags = 0;
+                    } else {
+                        aicwf_usb_rx_buf_put(usb_dev, usb_buf);
+                        aicwf_usb_rx_submit_all_urb_(usb_dev);
+                        return;
+                    }
+                } else {
+                    usb_err("invalid frag pkt, len=%u/%u/%u, frags=%u/%u\n", frag_len,
+                        rx_priv->rx_reassemble_cur_len, rx_priv->rx_reassemble_cur_len,
+                        rx_priv->rx_reassemble_cur_frags, rx_priv->rx_reassemble_total_frags);
+                    aicwf_dev_skb_free(reassemble_skb);
+                    rx_priv->rx_reassemble_skb = NULL;
+                    rx_priv->rx_reassemble_total_len = 0;
+                    rx_priv->rx_reassemble_cur_len = 0;
+                    rx_priv->rx_reassemble_total_frags = 0;
+                    rx_priv->rx_reassemble_cur_frags = 0;
+                    pkt_check = true;
+                }
+            } else {
+                pkt_check = true;
+            }
+
+            if (pkt_check) {
+                bool pkt_drop = false;
+                u8 type = skb->data[2];
+                u32 pkt_len = skb->data[0] | (skb->data[1] << 8);
+                if ((type & USB_TYPE_CFG) != USB_TYPE_CFG) {
+                    u32 pkt_total_len = pkt_len + RX_HWHRD_LEN;
+                    if ((pkt_total_len > AICWF_USB_MAX_PKT_SIZE) && (skb->len == AICWF_USB_MAX_PKT_SIZE)) {
+                        AICWFDBG(LOGINFO, "reassemble pkt, len=%u\n", pkt_total_len);
+                        struct sk_buff *reassemble_skb = __dev_alloc_skb(pkt_total_len, GFP_ATOMIC/*GFP_KERNEL*/);
+                        if (reassemble_skb) {
+                            memcpy(reassemble_skb->data, skb->data, skb->len);
+                            skb_put(reassemble_skb, skb->len);
+                            rx_priv->rx_reassemble_skb = reassemble_skb;
+                            rx_priv->rx_reassemble_total_len = pkt_total_len;
+                            rx_priv->rx_reassemble_cur_len = skb->len;
+                            rx_priv->rx_reassemble_total_frags = ALIGN(pkt_total_len, AICWF_USB_MAX_PKT_SIZE) / AICWF_USB_MAX_PKT_SIZE;
+                            rx_priv->rx_reassemble_cur_frags = 1;
+                        } else {
+                            usb_err("reassemble pkt alloc fail, len=%u\n", pkt_total_len);
+                        }
+                        aicwf_dev_skb_free(skb);
+                        aicwf_usb_rx_buf_put(usb_dev, usb_buf);
+                        aicwf_usb_rx_submit_all_urb_(usb_dev);
+                        return;
+                    } else if (pkt_total_len != skb->len) {
+                        usb_err("invalid DATA, len=%u/%u\n", pkt_len, skb->len);
+                        pkt_drop = true;
+                    }
+                } else {
+                    if (type == USB_TYPE_CFG_CMD_RSP) {
+                        u32 pkt_total_len = ALIGN((pkt_len + 4), 4);
+                        if ((pkt_total_len > AICWF_USB_MAX_PKT_SIZE) && (skb->len == AICWF_USB_MAX_PKT_SIZE)) {
+                            AICWFDBG(LOGINFO, "reassemble pkt, len=%u\n", pkt_total_len);
+                            struct sk_buff *reassemble_skb = __dev_alloc_skb(pkt_total_len, GFP_ATOMIC/*GFP_KERNEL*/);
+                            if (reassemble_skb) {
+                                memcpy(reassemble_skb->data, skb->data, skb->len);
+                                skb_put(reassemble_skb, skb->len);
+                                rx_priv->rx_reassemble_skb = reassemble_skb;
+                                rx_priv->rx_reassemble_total_len = pkt_total_len;
+                                rx_priv->rx_reassemble_cur_len = skb->len;
+                                rx_priv->rx_reassemble_total_frags = ALIGN(pkt_total_len, AICWF_USB_MAX_PKT_SIZE) / AICWF_USB_MAX_PKT_SIZE;
+                                rx_priv->rx_reassemble_cur_frags = 1;
+                            } else {
+                                usb_err("reassemble pkt alloc fail, len=%u\n", pkt_total_len);
+                            }
+                            aicwf_dev_skb_free(skb);
+                            aicwf_usb_rx_buf_put(usb_dev, usb_buf);
+                            aicwf_usb_rx_submit_all_urb_(usb_dev);
+                            return;
+                        } else if (pkt_total_len != skb->len) {
+                            usb_err("invalid CMD_RSP, len=%u/%u\n", pkt_len, skb->len);
+                            pkt_drop = true;
+                        }
+                    } else if (type == USB_TYPE_CFG_DATA_CFM) {
+                        if (!((pkt_len == 8) && (skb->len == 12))) {
+                            usb_err("invalid DATA_CFM, len=%u/%u\n", pkt_len, skb->len);
+                            pkt_drop = true;
+                        }
+                    } else {
+                        usb_err("invalid pkt, type=0x%x, len=%u/%u\n", type, pkt_len, skb->len);
+                        pkt_drop = true;
+                    }
+                }
+
+                if (pkt_drop) {
+                    aicwf_dev_skb_free(skb);
+                    aicwf_usb_rx_buf_put(usb_dev, usb_buf);
+                    aicwf_usb_rx_submit_all_urb_(usb_dev);
+                    return;
+                }
+            }
+#endif
         }
+
+        spin_lock_irqsave(&rx_priv->rxqlock, flags);
         if(!aicwf_rxframe_enqueue(usb_dev->dev, &rx_priv->rxq, skb)){
             spin_unlock_irqrestore(&rx_priv->rxqlock, flags);
             usb_err("rx_priv->rxq is over flow!!!\n");
@@ -452,6 +585,7 @@ static void aicwf_usb_msg_rx_complete(struct urb *urb)
     usb_buf->skb = NULL;
 
     if (urb->actual_length > urb->transfer_buffer_length) {
+        usb_err("usb_msg_rx len error %u/%u\n", urb->actual_length, urb->transfer_buffer_length);
         aicwf_dev_skb_free(skb);
         aicwf_usb_msg_rx_buf_put(usb_dev, usb_buf);
 		aicwf_usb_msg_rx_submit_all_urb_(usb_dev);
@@ -476,6 +610,109 @@ static void aicwf_usb_msg_rx_complete(struct urb *urb)
     if (usb_dev->state == USB_UP_ST) {
         skb_put(skb, urb->actual_length);
 
+#ifdef CONFIG_USB_RX_REASSEMBLE
+        bool pkt_check = false;
+        if (rx_priv->rx_msg_reassemble_skb) {
+            u32 frag_len = skb->len;
+            struct sk_buff *reassemble_skb = rx_priv->rx_msg_reassemble_skb;
+            bool reassemble_valid = false;
+            bool reassemble_done = false;
+            if ((rx_priv->rx_msg_reassemble_cur_frags + 1) == rx_priv->rx_msg_reassemble_total_frags) {
+                if ((rx_priv->rx_msg_reassemble_cur_len + frag_len) == rx_priv->rx_msg_reassemble_total_len) {
+                    reassemble_valid = true;
+                    reassemble_done = true;
+                }
+            } else {
+                if (frag_len == AICWF_USB_MSG_MAX_PKT_SIZE) {
+                    reassemble_valid = true;
+                }
+            }
+
+            if (reassemble_valid) {
+                memcpy((reassemble_skb->data + reassemble_skb->len), skb->data, frag_len);
+                skb_put(reassemble_skb, skb->len);
+                rx_priv->rx_msg_reassemble_cur_len += frag_len;
+                rx_priv->rx_msg_reassemble_cur_frags++;
+                aicwf_dev_skb_free(skb);
+                if (reassemble_done) {
+                    skb = reassemble_skb;
+                    rx_priv->rx_msg_reassemble_skb = NULL;
+                    rx_priv->rx_msg_reassemble_total_len = 0;
+                    rx_priv->rx_msg_reassemble_cur_len = 0;
+                    rx_priv->rx_msg_reassemble_total_frags = 0;
+                    rx_priv->rx_msg_reassemble_cur_frags = 0;
+                } else {
+                    aicwf_usb_msg_rx_buf_put(usb_dev, usb_buf);
+                    aicwf_usb_msg_rx_submit_all_urb_(usb_dev);
+                    return;
+                }
+            } else {
+                usb_err("invalid frag msg pkt, len=%u/%u/%u, frags=%u/%u\n", frag_len,
+                    rx_priv->rx_msg_reassemble_cur_len, rx_priv->rx_msg_reassemble_cur_len,
+                    rx_priv->rx_msg_reassemble_cur_frags, rx_priv->rx_msg_reassemble_total_frags);
+                aicwf_dev_skb_free(reassemble_skb);
+                rx_priv->rx_msg_reassemble_skb = NULL;
+                rx_priv->rx_msg_reassemble_total_len = 0;
+                rx_priv->rx_msg_reassemble_cur_len = 0;
+                rx_priv->rx_msg_reassemble_total_frags = 0;
+                rx_priv->rx_msg_reassemble_cur_frags = 0;
+                pkt_check = true;
+            }
+        } else {
+            pkt_check = true;
+        }
+
+        if (pkt_check) {
+            bool pkt_drop = false;
+            u8 type = skb->data[2];
+            u32 pkt_len = skb->data[0] | (skb->data[1] << 8);
+            if ((type & USB_TYPE_CFG) != USB_TYPE_CFG) {
+                usb_err("invalid msg pkt, type=0x%x, len=%u/%u\n", type, pkt_len, skb->len);;
+                pkt_drop = true;
+            } else {
+                if (type == USB_TYPE_CFG_CMD_RSP) {
+                    u32 pkt_total_len = ALIGN((pkt_len + 4), 4);
+                    if ((pkt_total_len > AICWF_USB_MSG_MAX_PKT_SIZE) && (skb->len == AICWF_USB_MSG_MAX_PKT_SIZE)) {
+                        AICWFDBG(LOGINFO, "reassemble msg pkt, len=%u\n", pkt_total_len);
+                        struct sk_buff *reassemble_skb = __dev_alloc_skb(pkt_total_len, GFP_ATOMIC/*GFP_KERNEL*/);
+                        if (reassemble_skb) {
+                            memcpy(reassemble_skb->data, skb->data, skb->len);
+                            skb_put(reassemble_skb, skb->len);
+                            rx_priv->rx_msg_reassemble_skb = reassemble_skb;
+                            rx_priv->rx_msg_reassemble_total_len = pkt_total_len;
+                            rx_priv->rx_msg_reassemble_cur_len = skb->len;
+                            rx_priv->rx_msg_reassemble_total_frags = ALIGN(pkt_total_len, AICWF_USB_MSG_MAX_PKT_SIZE) / AICWF_USB_MSG_MAX_PKT_SIZE;
+                            rx_priv->rx_msg_reassemble_cur_frags = 1;
+                        } else {
+                            usb_err("reassemble msg pkt alloc fail, len=%u\n", pkt_total_len);
+                        }
+                        aicwf_dev_skb_free(skb);
+                        aicwf_usb_msg_rx_buf_put(usb_dev, usb_buf);
+                        aicwf_usb_msg_rx_submit_all_urb_(usb_dev);
+                        return;
+                    } else if (pkt_total_len != skb->len) {
+                        usb_err("invalid CMD_RSP, len=%u/%u\n", pkt_len, skb->len);
+                        pkt_drop = true;
+                    }
+                } else if (type == USB_TYPE_CFG_DATA_CFM) {
+                    if (!((pkt_len == 8) && (skb->len == 12))) {
+                        usb_err("invalid DATA_CFM, len=%u/%u\n", pkt_len, skb->len);
+                        pkt_drop = true;
+                    }
+                } else {
+                    usb_err("invalid msg pkt, type=0x%x, len=%u/%u\n", type, pkt_len, skb->len);
+                    pkt_drop = true;
+                }
+            }
+            if (pkt_drop) {
+                aicwf_dev_skb_free(skb);
+                aicwf_usb_msg_rx_buf_put(usb_dev, usb_buf);
+                aicwf_usb_msg_rx_submit_all_urb_(usb_dev);
+                return;
+            }
+        }
+#endif
+
         spin_lock_irqsave(&rx_priv->msg_rxqlock, flags);
         if(!aicwf_rxframe_enqueue(usb_dev->dev, &rx_priv->msg_rxq, skb)){
             spin_unlock_irqrestore(&rx_priv->msg_rxqlock, flags);
@@ -515,9 +752,10 @@ static int aicwf_usb_submit_rx_urb(struct aic_usb_dev *usb_dev,
     rx_buff =  aicwf_prealloc_rxbuff_alloc(&usb_dev->rx_priv->rxbuff_lock);
 	if (rx_buff == NULL) {
 		AICWFDBG(LOGERROR, "failed to alloc rxbuff\r\n");
-        aicwf_usb_rx_buf_put(usb_dev, usb_buf);
-        return -1;
-    }
+		aicwf_usb_rx_buf_put(usb_dev, usb_buf);
+		rx_urb_sched = true;
+		return -1;
+	}
 	rx_buff->len = 0;
 	rx_buff->start = rx_buff->data;
 	rx_buff->read = rx_buff->start;
@@ -541,6 +779,7 @@ static int aicwf_usb_submit_rx_urb(struct aic_usb_dev *usb_dev,
         aicwf_usb_rx_buf_put(usb_dev, usb_buf);
 
         msleep(100);
+	    return -1;
     }else{
     	atomic_inc(&rx_urb_cnt);
 	}
@@ -575,10 +814,17 @@ static int aicwf_usb_submit_rx_urb(struct aic_usb_dev *usb_dev,
 
     usb_buf->skb = skb;
 
-    usb_fill_bulk_urb(usb_buf->urb,
-        usb_dev->udev,
-        usb_dev->bulk_in_pipe,
-        skb->data, skb_tailroom(skb), aicwf_usb_rx_complete, usb_buf);
+    if (aicwf_usb_rx_aggr) {
+        usb_fill_bulk_urb(usb_buf->urb,
+            usb_dev->udev,
+            usb_dev->bulk_in_pipe,
+            skb->data, AICWF_USB_AGGR_MAX_PKT_SIZE, aicwf_usb_rx_complete, usb_buf);
+    } else {
+        usb_fill_bulk_urb(usb_buf->urb,
+            usb_dev->udev,
+            usb_dev->bulk_in_pipe,
+            skb->data, AICWF_USB_MAX_PKT_SIZE, aicwf_usb_rx_complete, usb_buf);
+    }
 
     usb_buf->usbdev = usb_dev;
 
@@ -592,6 +838,7 @@ static int aicwf_usb_submit_rx_urb(struct aic_usb_dev *usb_dev,
         aicwf_usb_rx_buf_put(usb_dev, usb_buf);
 
         msleep(100);
+	    return -1;
     }else{
     	atomic_inc(&rx_urb_cnt);
 	}
@@ -611,11 +858,16 @@ static void aicwf_usb_rx_submit_all_urb(struct aic_usb_dev *usb_dev)
 
     while((usb_buf = aicwf_usb_rx_buf_get(usb_dev)) != NULL) {
         if (aicwf_usb_submit_rx_urb(usb_dev, usb_buf)) {
+            AICWFDBG(LOGERROR, "sub rx fail\n");
+		return;
+            #if 0
             AICWFDBG(LOGERROR, "usb rx refill fail\n");
             if (usb_dev->state != USB_UP_ST)
                 return;
+            #endif
         }
     }
+    usb_dev->rx_prepare_ready = true;
 }
 
 #ifdef CONFIG_USB_MSG_IN_EP
@@ -634,7 +886,7 @@ static int aicwf_usb_submit_msg_rx_urb(struct aic_usb_dev *usb_dev,
         return -1;
     }
 
-    skb = __dev_alloc_skb(AICWF_USB_MAX_PKT_SIZE, GFP_ATOMIC);
+    skb = __dev_alloc_skb(AICWF_USB_MSG_MAX_PKT_SIZE, GFP_ATOMIC);
     if (!skb) {
         aicwf_usb_msg_rx_buf_put(usb_dev, usb_buf);
         return -1;
@@ -645,7 +897,7 @@ static int aicwf_usb_submit_msg_rx_urb(struct aic_usb_dev *usb_dev,
     usb_fill_bulk_urb(usb_buf->urb,
         usb_dev->udev,
         usb_dev->msg_in_pipe,
-        skb->data, skb_tailroom(skb), aicwf_usb_msg_rx_complete, usb_buf);
+        skb->data, AICWF_USB_MSG_MAX_PKT_SIZE, aicwf_usb_msg_rx_complete, usb_buf);
 
     usb_buf->usbdev = usb_dev;
 
@@ -991,12 +1243,35 @@ int usb_bustx_thread(void *data)
 {
     struct aicwf_bus *bus = (struct aicwf_bus *)data;
     struct aic_usb_dev *usbdev = bus->bus_priv.usb;
+    int set_cpu_ret = 0;
+
+#ifdef CONFIG_THREAD_INFO_IN_TASK
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 16, 0))
+	AICWFDBG(LOGINFO, "%s the cpu is:%d\n", __func__, current->thread_info.cpu);
+#else
+    AICWFDBG(LOGINFO, "%s the cpu is:%d\n", __func__, current->cpu);
+#endif
+#endif
+    set_cpu_ret = set_cpus_allowed_ptr(current, cpumask_of(1));
+#ifdef CONFIG_THREAD_INFO_IN_TASK
+    AICWFDBG(LOGINFO, "%s set_cpu_ret is:%d\n", __func__, set_cpu_ret);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 16, 0))
+	AICWFDBG(LOGINFO, "%s change cpu to:%d\n", __func__, current->thread_info.cpu);
+#else
+    AICWFDBG(LOGINFO, "%s change cpu to:%d\n", __func__, current->cpu);
+#endif
+#endif
+
 
 #ifdef CONFIG_TXRX_THREAD_PRIO
 	if (bustx_thread_prio > 0) {
-			struct sched_param param;
-			param.sched_priority = (bustx_thread_prio < MAX_RT_PRIO)?bustx_thread_prio:(MAX_RT_PRIO-1);
-			sched_setscheduler(current, SCHED_FIFO, &param);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 9, 0))
+        sched_set_fifo_low(current);
+#else
+        struct sched_param param;
+        param.sched_priority = (bustx_thread_prio < MAX_RT_PRIO)?bustx_thread_prio:(MAX_RT_PRIO-1);
+        sched_setscheduler(current, SCHED_FIFO, &param);
+#endif
 	}
 #endif
 	AICWFDBG(LOGINFO, "%s the policy of current thread is:%d\n", __func__, current->policy);
@@ -1035,12 +1310,34 @@ int usb_busrx_thread(void *data)
 {
     struct aicwf_rx_priv *rx_priv = (struct aicwf_rx_priv *)data;
     struct aicwf_bus *bus_if = rx_priv->usbdev->bus_if;
+    int set_cpu_ret = 0;
+    
+#ifdef CONFIG_THREAD_INFO_IN_TASK
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 16, 0))
+	AICWFDBG(LOGINFO, "%s the cpu is:%d\n", __func__, current->thread_info.cpu);
+#else
+    AICWFDBG(LOGINFO, "%s the cpu is:%d\n", __func__, current->cpu);
+#endif
+#endif
+    set_cpu_ret = set_cpus_allowed_ptr(current, cpumask_of(1));
+#ifdef CONFIG_THREAD_INFO_IN_TASK
+    AICWFDBG(LOGINFO, "%s set_cpu_ret is:%d\n", __func__, set_cpu_ret);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 16, 0))
+	AICWFDBG(LOGINFO, "%s change cpu to:%d\n", __func__, current->thread_info.cpu);
+#else
+    AICWFDBG(LOGINFO, "%s change cpu to:%d\n", __func__, current->cpu);
+#endif
+#endif
 
 #ifdef CONFIG_TXRX_THREAD_PRIO
 	if (busrx_thread_prio > 0) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 9, 0))
+            sched_set_fifo_low(current);
+#else
 			struct sched_param param;
 			param.sched_priority = (busrx_thread_prio < MAX_RT_PRIO)?busrx_thread_prio:(MAX_RT_PRIO-1);
 			sched_setscheduler(current, SCHED_FIFO, &param);
+#endif
 	}
 #endif
 	AICWFDBG(LOGINFO, "%s the policy of current thread is:%d\n", __func__, current->policy);
@@ -1079,9 +1376,13 @@ int usb_msg_busrx_thread(void *data)
 
 #ifdef CONFIG_TXRX_THREAD_PRIO
 			if (busrx_thread_prio > 0) {
-					struct sched_param param;
-					param.sched_priority = (busrx_thread_prio < MAX_RT_PRIO)?busrx_thread_prio:(MAX_RT_PRIO-1);
-					sched_setscheduler(current, SCHED_FIFO, &param);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 9, 0))
+                sched_set_fifo_low(current);
+#else
+                struct sched_param param;
+                param.sched_priority = (busrx_thread_prio < MAX_RT_PRIO)?busrx_thread_prio:(MAX_RT_PRIO-1);
+                sched_setscheduler(current, SCHED_FIFO, &param);
+#endif
 			}
 #endif
 			AICWFDBG(LOGINFO, "%s the policy of current thread is:%d\n", __func__, current->policy);
@@ -1091,17 +1392,24 @@ int usb_msg_busrx_thread(void *data)
 
 
     while (1) {
+#if 0
         if(kthread_should_stop()) {
             usb_err("usb msg busrx thread stop\n");
             break;
         }
+#endif
         if (!wait_for_completion_interruptible(&bus_if->msg_busrx_trgg)) {
-            if(bus_if->state == BUS_DOWN_ST)
+            if(bus_if->state == BUS_DOWN_ST){
+		AICWFDBG(LOGINFO, "usb msg busrx thread will to stop\n");
                 break;
+	    }
             aicwf_process_msg_rxframes(rx_priv);
         }
     }
 
+	aic_thread_wait_stop();
+	AICWFDBG(LOGINFO, "usb msg busrx thread stop\n");
+
     return 0;
 }
 #endif
@@ -1570,16 +1878,21 @@ static int aicwf_usb_bus_start(struct device *dev)
         return 0;
 
     aicwf_usb_state_change(usb_dev, USB_UP_ST);
+
+    usb_dev->rx_prepare_ready = false;
     aicwf_usb_rx_prepare(usb_dev);
     aicwf_usb_tx_prepare(usb_dev);
 #ifdef CONFIG_USB_MSG_IN_EP
-	if(usb_dev->chipid != PRODUCT_ID_AIC8801 &&
-        usb_dev->chipid != PRODUCT_ID_AIC8800D81){
+	if(usb_dev->msg_in_pipe){
 		aicwf_usb_msg_rx_prepare(usb_dev);
 	}
 #endif
-
-    return 0;
+    if(!usb_dev->rx_prepare_ready){
+        AICWFDBG(LOGERROR, "%s rx prepare fail\r\n", __func__);
+        return -1;
+    }else{
+        return 0;
+    }
 }
 
 static void aicwf_usb_cancel_all_urbs_(struct aic_usb_dev *usb_dev)
@@ -1621,8 +1934,7 @@ static void aicwf_usb_cancel_all_urbs_(struct aic_usb_dev *usb_dev)
 
     usb_kill_anchored_urbs(&usb_dev->rx_submitted);
 #ifdef CONFIG_USB_MSG_IN_EP
-	if(usb_dev->chipid != PRODUCT_ID_AIC8801 &&
-        usb_dev->chipid != PRODUCT_ID_AIC8800D81){
+	if(usb_dev->msg_in_pipe){
    		usb_kill_anchored_urbs(&usb_dev->msg_rx_submitted);
 	}
 #endif
@@ -1645,7 +1957,7 @@ static void aicwf_usb_bus_stop(struct device *dev)
     if (usb_dev->state == USB_DOWN_ST)
         return;
 
-    if(g_rwnx_plat->wait_disconnect_cb == true){
+    if(g_rwnx_plat && g_rwnx_plat->wait_disconnect_cb == true){
             atomic_set(&aicwf_deinit_atomic, 1);
             up(&aicwf_deinit_sem);
     }
@@ -1659,8 +1971,7 @@ static void aicwf_usb_deinit(struct aic_usb_dev *usbdev)
     aicwf_usb_free_urb(&usbdev->rx_free_list, &usbdev->rx_free_lock);
     aicwf_usb_free_urb(&usbdev->tx_free_list, &usbdev->tx_free_lock);
 #ifdef CONFIG_USB_MSG_IN_EP
-	if(usbdev->chipid != PRODUCT_ID_AIC8801 &&
-        usbdev->chipid != PRODUCT_ID_AIC8800D81){
+	if(usbdev->msg_in_pipe){
 		cancel_work_sync(&usbdev->msg_rx_urb_work);
 		aicwf_usb_free_urb(&usbdev->msg_rx_free_list, &usbdev->msg_rx_free_lock);
 	}
@@ -1695,8 +2006,7 @@ static int aicwf_usb_init(struct aic_usb_dev *usb_dev)
     init_waitqueue_head(&usb_dev->msg_wait);
     init_usb_anchor(&usb_dev->rx_submitted);
 #ifdef CONFIG_USB_MSG_IN_EP
-	if(usb_dev->chipid != PRODUCT_ID_AIC8801 &&
-        usb_dev->chipid != PRODUCT_ID_AIC8800D81){
+	if(usb_dev->msg_in_pipe){
 		init_usb_anchor(&usb_dev->msg_rx_submitted);
 	}
 #endif
@@ -1706,8 +2016,7 @@ static int aicwf_usb_init(struct aic_usb_dev *usb_dev)
     spin_lock_init(&usb_dev->rx_free_lock);
     spin_lock_init(&usb_dev->tx_flow_lock);
 #ifdef CONFIG_USB_MSG_IN_EP
-	if(usb_dev->chipid != PRODUCT_ID_AIC8801 &&
-        usb_dev->chipid != PRODUCT_ID_AIC8800D81){
+	if(usb_dev->msg_in_pipe){
 		spin_lock_init(&usb_dev->msg_rx_free_lock);
 	}
 #endif
@@ -1716,8 +2025,7 @@ static int aicwf_usb_init(struct aic_usb_dev *usb_dev)
     INIT_LIST_HEAD(&usb_dev->tx_free_list);
     INIT_LIST_HEAD(&usb_dev->tx_post_list);
 #ifdef CONFIG_USB_MSG_IN_EP
-	if(usb_dev->chipid != PRODUCT_ID_AIC8801 &&
-        usb_dev->chipid != PRODUCT_ID_AIC8800D81){
+	if(usb_dev->msg_in_pipe){
 		INIT_LIST_HEAD(&usb_dev->msg_rx_free_list);
 	}
 #endif
@@ -1736,8 +2044,7 @@ static int aicwf_usb_init(struct aic_usb_dev *usb_dev)
         goto error;
     }
 #ifdef CONFIG_USB_MSG_IN_EP
-	if(usb_dev->chipid != PRODUCT_ID_AIC8801 &&
-        usb_dev->chipid != PRODUCT_ID_AIC8800D81){
+	if(usb_dev->msg_in_pipe){
 		ret =  aicwf_usb_alloc_msg_rx_urb(usb_dev);
 		if (ret) {
 			goto error;
@@ -1755,8 +2062,7 @@ static int aicwf_usb_init(struct aic_usb_dev *usb_dev)
 
     INIT_WORK(&usb_dev->rx_urb_work, aicwf_usb_rx_urb_work);
 #ifdef CONFIG_USB_MSG_IN_EP
-	if(usb_dev->chipid != PRODUCT_ID_AIC8801 &&
-        usb_dev->chipid != PRODUCT_ID_AIC8800D81){
+	if(usb_dev->msg_in_pipe){
 		INIT_WORK(&usb_dev->msg_rx_urb_work, aicwf_usb_msg_rx_urb_work);
 	}
 #endif
@@ -1813,16 +2119,20 @@ static int aicwf_parse_usb(struct aic_usb_dev *usb_dev, struct usb_interface *in
 
     /* Check interface number */
 #ifdef CONFIG_USB_BT
-    if (usb->actconfig->desc.bNumInterfaces != 3) {
+    if (usb->actconfig->desc.bNumInterfaces != 3)
 #else
-    if (usb->actconfig->desc.bNumInterfaces != 1) {
+    if (usb->actconfig->desc.bNumInterfaces != 1)
 #endif
+    {
 	   AICWFDBG(LOGERROR, "Number of interfaces: %d not supported\n",
             usb->actconfig->desc.bNumInterfaces);
 		if(usb_dev->chipid == PRODUCT_ID_AIC8800DC){
 			AICWFDBG(LOGERROR, "AIC8800DC change to AIC8800DW\n");
 			usb_dev->chipid = PRODUCT_ID_AIC8800DW;
-		}else{
+		}else if(usb_dev->chipid == PRODUCT_ID_AIC8800D81X2 ||
+                usb_dev->chipid == PRODUCT_ID_AIC8800D89X2){
+            //TODO
+        }else{
 			ret = -ENODEV;
 			goto exit;
 		}
@@ -1849,8 +2159,7 @@ static int aicwf_parse_usb(struct aic_usb_dev *usb_dev, struct usb_interface *in
             }
 #ifdef CONFIG_USB_MSG_IN_EP
             else if (!usb_dev->msg_in_pipe) {
-				if(usb_dev->chipid != PRODUCT_ID_AIC8801 &&
-                    usb_dev->chipid != PRODUCT_ID_AIC8800D81){
+				if(usb_dev->chipid != PRODUCT_ID_AIC8801){
                 	usb_dev->msg_in_pipe = usb_rcvbulkpipe(usb, endpoint_num);
 				}
             }
@@ -1888,10 +2197,9 @@ static int aicwf_parse_usb(struct aic_usb_dev *usb_dev, struct usb_interface *in
     }
 #endif
 #ifdef CONFIG_USB_MSG_IN_EP
-		if(usb_dev->chipid != PRODUCT_ID_AIC8801 &&
-            usb_dev->chipid != PRODUCT_ID_AIC8800D81){
+		if(usb_dev->chipid != PRODUCT_ID_AIC8801){
 			if (usb_dev->msg_in_pipe == 0) {
-				usb_err("No RX Msg (in) Bulk EP found\n");
+				AICWFDBG(LOGINFO, "No RX Msg (in) Bulk EP found\n");
 			}
 		}
 #endif
@@ -1997,10 +2305,18 @@ static int aicwf_usb_chipmatch(struct aic_usb_dev *usb_dev, u16_l vid, u16_l pid
         usb_dev->chipid = PRODUCT_ID_AIC8800DW;
 		AICWFDBG(LOGINFO, "%s USE AIC8800DW\r\n", __func__);
         return 0;
-    }else if(pid == USB_PRODUCT_ID_AIC8800D81){
+    }else if(pid == USB_PRODUCT_ID_AIC8800D81 || pid == USB_PRODUCT_ID_AIC8800D41){
         usb_dev->chipid = PRODUCT_ID_AIC8800D81;
-	aicwf_usb_rx_aggr = true;
-		AICWFDBG(LOGINFO, "%s USE AIC8800D81\r\n", __func__);
+        aicwf_usb_rx_aggr = true;
+        AICWFDBG(LOGINFO, "%s USE AIC8800D81\r\n", __func__);
+        return 0;
+    }else if(pid == USB_PRODUCT_ID_AIC8800D81X2){
+        usb_dev->chipid = PRODUCT_ID_AIC8800D81X2;
+        AICWFDBG(LOGINFO, "%s USE AIC8800D81X2\r\n", __func__);
+        return 0;
+    }else if(pid == USB_PRODUCT_ID_AIC8800D89X2){
+        usb_dev->chipid = PRODUCT_ID_AIC8800D89X2;
+        AICWFDBG(LOGINFO, "%s USE AIC8800D89X2\r\n", __func__);
         return 0;
     }else{
 		return -1;
@@ -2021,10 +2337,47 @@ static int aicwf_usb_probe(struct usb_interface *intf, const struct usb_device_i
     #endif
 
     usb_dev = kzalloc(sizeof(struct aic_usb_dev), GFP_ATOMIC);
+    
+    AICWFDBG(LOGDEBUG, "%s usb_dev:%d usb_tx_buf:%d usb_rx_buf:%d\r\n", 
+        __func__, 
+        (int)sizeof(struct aic_usb_dev),
+        (int)sizeof(struct aicwf_usb_buf) * AICWF_USB_TX_URBS,
+        (int)sizeof(struct aicwf_usb_buf) * AICWF_USB_RX_URBS);
+
+
     if (!usb_dev) {
+        AICWFDBG(LOGERROR, "%s usb_dev kzalloc fail\r\n", __func__);
+        return -ENOMEM;
+    }
+
+    usb_dev->usb_tx_buf = vmalloc(sizeof(struct aicwf_usb_buf) * AICWF_USB_TX_URBS);
+    usb_dev->usb_rx_buf = vmalloc(sizeof(struct aicwf_usb_buf) * AICWF_USB_RX_URBS);
+
+    if(!usb_dev->usb_tx_buf || !usb_dev->usb_rx_buf){
+        if(usb_dev->usb_tx_buf){
+            vfree(usb_dev);
+        }
+        
+        if(usb_dev->usb_tx_buf){
+            vfree(usb_dev);
+        }
+        
+        if(usb_dev){
+            kfree(usb_dev);
+        }
+        AICWFDBG(LOGERROR, "%s usb_tx_buf or usb_rx_buf vmalloc fail\r\n", __func__);
         return -ENOMEM;
     }
 
+    memset(usb_dev->usb_tx_buf, 
+        0, 
+        (int)(sizeof(struct aicwf_usb_buf) * AICWF_USB_TX_URBS));
+    
+    memset(usb_dev->usb_rx_buf, 
+        0, 
+        (int)(sizeof(struct aicwf_usb_buf) * AICWF_USB_RX_URBS));
+
+
     usb_dev->udev = usb;
     usb_dev->dev = &usb->dev;
     usb_set_intfdata(intf, usb_dev);
@@ -2115,6 +2468,8 @@ static int aicwf_usb_probe(struct usb_interface *intf, const struct usb_device_i
     aicwf_usb_deinit(usb_dev);
 out_free:
     usb_err("failed with errno %d\n", ret);
+    vfree(usb_dev->usb_tx_buf);
+    vfree(usb_dev->usb_rx_buf);
     kfree(usb_dev);
     usb_set_intfdata(intf, NULL);
     return ret;
@@ -2144,16 +2499,14 @@ static void aicwf_usb_disconnect(struct usb_interface *intf)
 #endif
     aicwf_bus_deinit(usb_dev->dev);
     aicwf_usb_deinit(usb_dev);
-    rwnx_cmd_mgr_deinit(&usb_dev->cmd_mgr);
 
 #ifdef CONFIG_GPIO_WAKEUP
 	rwnx_unregister_hostwake_irq(usb_dev->dev);
 #endif
 
-    if (usb_dev->rx_priv)
-        aicwf_rx_deinit(usb_dev->rx_priv);
-
     kfree(usb_dev->bus_if);
+    vfree(usb_dev->usb_tx_buf);
+    vfree(usb_dev->usb_rx_buf);
     kfree(usb_dev);
 	AICWFDBG(LOGINFO, "%s exit\r\n", __func__);
 	up(&aicwf_deinit_sem);
@@ -2230,8 +2583,11 @@ static struct usb_device_id aicwf_usb_id_table[] = {
 #else
     {USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_AIC, USB_PRODUCT_ID_AIC8801, 0xff, 0xff, 0xff)},
     {USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_AIC, USB_PRODUCT_ID_AIC8800D81, 0xff, 0xff, 0xff)},
+    {USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_AIC, USB_PRODUCT_ID_AIC8800D41, 0xff, 0xff, 0xff)},
     {USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_AIC, USB_PRODUCT_ID_AIC8800DC, 0xff, 0xff, 0xff)},
     {USB_DEVICE(USB_VENDOR_ID_AIC, USB_PRODUCT_ID_AIC8800DW)},
+    {USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_AIC_V2, USB_PRODUCT_ID_AIC8800D81X2, 0xff, 0xff, 0xff)},
+    {USB_DEVICE(USB_VENDOR_ID_AIC_V2, USB_PRODUCT_ID_AIC8800D89X2)},
 #endif
     {}
 };
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.h
index dd4143cdc103..879bf0ba5b5e 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_usb.h
@@ -16,26 +16,37 @@
 
 /* USB Device ID */
 #define USB_VENDOR_ID_AIC                0xA69C
+#define USB_VENDOR_ID_AIC_V2             0x368B
 
 #ifndef CONFIG_USB_BT
-#define USB_PRODUCT_ID_AIC8800               0x8800
+#define USB_PRODUCT_ID_AIC8800          0x8800
+#define USB_PRODUCT_ID_AIC8801          0x8801
+#define USB_PRODUCT_ID_AIC8800DC        0x88dc
+#define USB_PRODUCT_ID_AIC8800DW        0x88dd
+#define USB_PRODUCT_ID_AIC8800D81       0x8d81
+#define USB_PRODUCT_ID_AIC8800D81X2     0x8d91
+#define USB_PRODUCT_ID_AIC8800D89X2     0x8d99
 #else
-#define USB_PRODUCT_ID_AIC8801				0x8801
-#define USB_PRODUCT_ID_AIC8800DC			0x88dc
-#define USB_PRODUCT_ID_AIC8800DW            0x88dd
-#define USB_PRODUCT_ID_AIC8800D81           0x8d81
-
+#define USB_PRODUCT_ID_AIC8801          0x8801
+#define USB_PRODUCT_ID_AIC8800DC        0x88dc
+#define USB_PRODUCT_ID_AIC8800DW        0x88dd
+#define USB_PRODUCT_ID_AIC8800D81       0x8d81
+#define USB_PRODUCT_ID_AIC8800D41       0x8d41
+#define USB_PRODUCT_ID_AIC8800D81X2     0x8d91
+#define USB_PRODUCT_ID_AIC8800D89X2     0x8d99
 #endif
 
 enum AICWF_IC{
 	PRODUCT_ID_AIC8801	=	0,
 	PRODUCT_ID_AIC8800DC,
 	PRODUCT_ID_AIC8800DW,
-	PRODUCT_ID_AIC8800D81
+	PRODUCT_ID_AIC8800D81,
+	PRODUCT_ID_AIC8800D81X2,
+	PRODUCT_ID_AIC8800D89X2
 };
 
 
-#define AICWF_USB_RX_URBS               (200)//(200)
+#define AICWF_USB_RX_URBS               (20)//(200)
 #ifdef CONFIG_USB_MSG_IN_EP
 #define AICWF_USB_MSG_RX_URBS           (100)
 #endif
@@ -47,7 +58,12 @@ enum AICWF_IC{
 #endif
 #define AICWF_USB_TX_LOW_WATER         (AICWF_USB_TX_URBS/4)//25%
 #define AICWF_USB_TX_HIGH_WATER        (AICWF_USB_TX_LOW_WATER*3)//75%
-#define AICWF_USB_AGGR_MAX_PKT_SIZE     (2048*30)
+#ifdef CONFIG_PLATFORM_HI
+#define AICWF_USB_AGGR_MAX_PKT_SIZE     (2048*1)
+#else
+#define AICWF_USB_AGGR_MAX_PKT_SIZE     (2048*10)
+#endif
+#define AICWF_USB_MSG_MAX_PKT_SIZE      (2048)
 #define AICWF_USB_MAX_PKT_SIZE          (2048)
 #define AICWF_USB_FC_PERSTA_HIGH_WATER		64
 #define AICWF_USB_FC_PERSTA_LOW_WATER		16
@@ -132,9 +148,15 @@ struct aic_usb_dev {
 
     int tx_free_count;
     int tx_post_count;
-
+    bool rx_prepare_ready;
+#if 0
     struct aicwf_usb_buf usb_tx_buf[AICWF_USB_TX_URBS];
     struct aicwf_usb_buf usb_rx_buf[AICWF_USB_RX_URBS];
+#else
+    struct aicwf_usb_buf *usb_tx_buf;
+    struct aicwf_usb_buf *usb_rx_buf;
+#endif
+
 #ifdef CONFIG_USB_MSG_IN_EP
 	struct aicwf_usb_buf usb_msg_rx_buf[AICWF_USB_MSG_RX_URBS];
 #endif
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_wext_linux.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_wext_linux.c
index de591f69d384..bc0643d29436 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_wext_linux.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_wext_linux.c
@@ -400,7 +400,10 @@ static char *aicwf_get_iwe_stream_mac_addr(struct rwnx_hw* rwnx_hw,
 	iwe->cmd = SIOCGIWAP;
 	iwe->u.ap_addr.sa_family = ARPHRD_ETHER;
 
+	if(scan_re->bss && &scan_re->bss->bssid[0]){
 	memcpy(iwe->u.ap_addr.sa_data, scan_re->bss->bssid, ETH_ALEN);
+	}
+
 	start = iwe_stream_add_event(info, start, stop, iwe, IW_EV_ADDR_LEN);
 	return start;
 }
@@ -878,19 +881,21 @@ static char *translate_scan(struct rwnx_hw* rwnx_hw,
 	struct iw_event iwe;
 	memset(&iwe, 0, sizeof(iwe));
 
-	
-	start = aicwf_get_iwe_stream_mac_addr(rwnx_hw, info, scan_re, start, stop, &iwe);
-	start = aicwf_get_iwe_stream_essid(rwnx_hw, info, scan_re, start, stop, &iwe);
-	start = aicwf_get_iwe_stream_protocol(rwnx_hw, info, scan_re, start, stop, &iwe);
-	start = aicwf_get_iwe_stream_chan(rwnx_hw, info, scan_re, start, stop, &iwe);
-	start = aicwf_get_iwe_stream_mode(rwnx_hw, info, scan_re, start, stop, &iwe);
-	start = aicwf_get_iwe_stream_encryption(rwnx_hw, info, scan_re, start, stop, &iwe);
-	start = aicwf_get_iwe_stream_rate(rwnx_hw, info, scan_re, start, stop, &iwe);
-	start = aicwf_get_iwe_stream_wpa_wpa2(rwnx_hw, info, scan_re, start, stop, &iwe);
-	start = aicwf_get_iwe_stream_wps(rwnx_hw, info, scan_re, start, stop, &iwe);
-	start = aicwf_get_iwe_stream_rssi(rwnx_hw, info, scan_re, start, stop, &iwe);
-
-	return start;
+	if(scan_re->bss){
+	    	start = aicwf_get_iwe_stream_mac_addr(rwnx_hw, info, scan_re, start, stop, &iwe);
+	    	start = aicwf_get_iwe_stream_essid(rwnx_hw, info, scan_re, start, stop, &iwe);
+	    	start = aicwf_get_iwe_stream_protocol(rwnx_hw, info, scan_re, start, stop, &iwe);
+	    	start = aicwf_get_iwe_stream_chan(rwnx_hw, info, scan_re, start, stop, &iwe);
+	    	start = aicwf_get_iwe_stream_mode(rwnx_hw, info, scan_re, start, stop, &iwe);
+	    	start = aicwf_get_iwe_stream_encryption(rwnx_hw, info, scan_re, start, stop, &iwe);
+	    	start = aicwf_get_iwe_stream_rate(rwnx_hw, info, scan_re, start, stop, &iwe);
+	    	start = aicwf_get_iwe_stream_wpa_wpa2(rwnx_hw, info, scan_re, start, stop, &iwe);
+	    	start = aicwf_get_iwe_stream_wps(rwnx_hw, info, scan_re, start, stop, &iwe);
+	    	start = aicwf_get_iwe_stream_rssi(rwnx_hw, info, scan_re, start, stop, &iwe);
+		return start;
+	} else{
+		return start;
+	}	
 }
 
 
@@ -920,7 +925,6 @@ static int aicwf_get_wap(struct net_device *dev,
 }
 
 
-extern uint8_t scanning;
 static int aicwf_set_scan(struct net_device *dev, struct iw_request_info *a,
 			   union iwreq_data *wrqu, char *extra)
 {
@@ -939,7 +943,7 @@ static int aicwf_set_scan(struct net_device *dev, struct iw_request_info *a,
 
 	}
 
-    if (rwnx_hw->wext_scan || scanning) {
+    if (rwnx_hw->wext_scan || rwnx_hw->scanning) {
         AICWFDBG(LOGINFO, "is scanning, abort\n");
 	ret =  rwnx_send_scanu_cancel_req(rwnx_hw, NULL);
 	if (ret)
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_msg.h b/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_msg.h
index 5367dc61d947..700e3b1b7a89 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_msg.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_msg.h
@@ -388,6 +388,20 @@ enum mm_msg_tag
     MM_GET_FW_VERSION_REQ,
     MM_GET_FW_VERSION_CFM,
 
+    MM_SET_RESUME_RESTORE_REQ,
+    MM_SET_RESUME_RESTORE_CFM,
+
+    MM_GET_WIFI_DISABLE_REQ,
+    MM_GET_WIFI_DISABLE_CFM,
+
+    MM_CFG_RSSI_CFM,
+
+    MM_SET_VENDOR_SWCONFIG_REQ,
+    MM_SET_VENDOR_SWCONFIG_CFM,
+
+    MM_SET_TXPWR_LVL_ADJ_REQ,
+    MM_SET_TXPWR_LVL_ADJ_CFM,
+
     /// MAX number of messages
     MM_MAX,
 };
@@ -1215,6 +1229,7 @@ struct mm_set_agg_disable_req
 {
     u8_l disable;
     u8_l staidx;
+    u8_l disable_rx;
 };
 
 struct mm_set_coex_req
@@ -1325,6 +1340,13 @@ typedef struct
     s8_l pwrlvl_11ax_5g[12];
 } txpwr_lvl_conf_v3_t;
 
+typedef struct
+{
+    u8_l enable;
+    s8_l pwrlvl_adj_tbl_2g4[3];
+    s8_l pwrlvl_adj_tbl_5g[6];
+} txpwr_lvl_adj_conf_t;
+
 struct mm_set_txpwr_lvl_req
 {
   union {
@@ -1334,6 +1356,11 @@ struct mm_set_txpwr_lvl_req
   };
 };
 
+struct mm_set_txpwr_lvl_adj_req
+{
+    txpwr_lvl_adj_conf_t txpwr_lvl_adj;
+};
+
 typedef struct
 {
     u8_l loss_enable;
@@ -1372,9 +1399,42 @@ typedef struct
     int8_t chan_142_165;
 } txpwr_ofst_conf_t;
 
+/*
+ * pwrofst2x_tbl_2g4[3][3]:
+ * +---------------+----------+----------+----------+
+ * | RateTyp\ChGrp |  CH_1_4  |  CH_5_9  | CH_10_13 |
+ * +---------------+----------+----------+----------+
+ * | DSSS          |  [0][0]  |  [0][1]  |  [0][2]  |
+ * +---------------+----------+----------+----------+
+ * | OFDM_HIGHRATE |  [1][0]  |  [1][1]  |  [1][2]  |
+ * +---------------+----------+----------+----------+
+ * | OFDM_LOWRATE  |  [2][0]  |  [2][1]  |  [2][2]  |
+ * +---------------+----------+----------+----------+
+ * pwrofst2x_tbl_5g[3][6]:
+ * +---------------+--------------+--------------+----------------+----------------+----------------+----------------+
+ * | RateTyp\ChGrp | CH_42(36~50) | CH_58(51~64) | CH_106(98~114) | CH_122(115~130)| CH_138(131~146)| CH_155(147~166)|
+ * +---------------+--------------+--------------+----------------+----------------+----------------+----------------+
+ * | OFDM_LOWRATE  |    [0][0]    |    [0][1]    |     [0][2]     |     [0][3]     |     [0][4]     |     [0][5]     |
+ * +---------------+--------------+--------------+----------------+----------------+----------------+----------------+
+ * | OFDM_HIGHRATE |    [1][0]    |    [1][1]    |     [1][2]     |     [1][3]     |     [1][4]     |     [1][5]     |
+ * +---------------+--------------+--------------+----------------+----------------+----------------+----------------+
+ * | OFDM_MIDRATE  |    [2][0]    |    [2][1]    |     [2][2]     |     [2][3]     |     [2][4]     |     [2][5]     |
+ * +---------------+--------------+--------------+----------------+----------------+----------------+----------------+
+ */
+
+typedef struct
+{
+    int8_t enable;
+    int8_t pwrofst2x_tbl_2g4[3][3];
+    int8_t pwrofst2x_tbl_5g[3][6];
+} txpwr_ofst2x_conf_t;
+
 struct mm_set_txpwr_ofst_req
 {
+  union {
     txpwr_ofst_conf_t txpwr_ofst;
+    txpwr_ofst2x_conf_t txpwr_ofst2x;
+  };
 };
 
 typedef struct
@@ -1914,6 +1974,11 @@ enum vendor_hwconfig_tag{
 	MAC_TIMESCALE_REQ,
 	CCA_THRESHOLD_REQ,
 	BWMODE_REQ,
+	CHIP_TEMP_GET_REQ,
+	AP_PS_LEVEL_SET_REQ,
+	CUSTOMIZED_FREQ_REQ,
+	WAKEUP_INFO_REQ,
+	KEEPALIVE_PKT_REQ,
 };
 
 enum {
@@ -1941,6 +2006,7 @@ struct mm_set_channel_access_req
 	u8_l  long_nav_en;
 	u8_l  cfe_en;
 	u8_l  rc_retry_cnt[3];
+	s8_l ccademod_th;
 };
 
 struct mm_set_mac_timescale_req
@@ -1971,6 +2037,41 @@ struct mm_set_bwmode_req
     u8_l bwmode;
 };
 
+struct mm_get_chip_temp_req
+{
+    u32_l hwconfig_id;
+};
+
+struct mm_get_chip_temp_cfm
+{
+    /// Temp degree val
+    s8_l degree;
+};
+
+struct mm_set_vendor_hwconfig_cfm
+{
+    u32_l hwconfig_id;
+    union {
+        struct mm_get_chip_temp_cfm chip_temp_cfm;
+    };
+};
+
+struct mm_set_customized_freq_req
+{
+	u32_l hwconfig_id;
+	u16_l raw_freq[4];
+	u16_l map_freq[4];
+};
+
+struct mm_set_keepalive_req
+{
+	u32_l hwconfig_id;
+	u16_l code;
+	u16_l length;
+	u32_l intv;
+	u8_l payload[];
+};
+
 struct mm_set_txop_req
 {
 	u16_l txop_bk;
@@ -1994,6 +2095,105 @@ struct mm_get_fw_version_cfm
     u8_l fw_version[63];
 };
 
+struct mm_get_wifi_disable_cfm
+{
+    u8_l wifi_disable;
+};
+
+enum vendor_swconfig_tag
+{
+    BCN_CFG_REQ = 0,
+    TEMP_COMP_SET_REQ,
+    TEMP_COMP_GET_REQ,
+    EXT_FLAGS_SET_REQ,
+    EXT_FLAGS_GET_REQ,
+    EXT_FLAGS_MASK_SET_REQ,
+};
+
+struct mm_set_bcn_cfg_req
+{
+    /// Ignore or not bcn tim bcmc bit
+    bool_l tim_bcmc_ignored_enable;
+};
+
+struct mm_set_bcn_cfg_cfm
+{
+    /// Request status
+    bool_l tim_bcmc_ignored_status;
+};
+
+struct mm_set_temp_comp_req
+{
+    /// Enable or not temp comp
+    u8_l enable;
+    u8_l reserved[3];
+    u32_l tmr_period_ms;
+};
+
+struct mm_set_temp_comp_cfm
+{
+    /// Request status
+    u8_l status;
+};
+
+struct mm_get_temp_comp_cfm
+{
+    /// Request status
+    u8_l status;
+    /// Temp degree val
+    s8_l degree;
+};
+
+struct mm_set_ext_flags_req
+{
+    u32_l user_flags;
+};
+
+struct mm_set_ext_flags_cfm
+{
+    u32_l user_flags;
+};
+
+struct mm_get_ext_flags_cfm
+{
+    u32_l user_flags;
+};
+
+struct mm_mask_set_ext_flags_req
+{
+    u32_l user_flags_mask;
+    u32_l user_flags_val;
+};
+
+struct mm_mask_set_ext_flags_cfm
+{
+    u32_l user_flags;
+};
+
+struct mm_set_vendor_swconfig_req
+{
+    u32_l swconfig_id;
+    union {
+        struct mm_set_bcn_cfg_req bcn_cfg_req;
+        struct mm_set_temp_comp_req temp_comp_set_req;
+        struct mm_set_ext_flags_req ext_flags_set_req;
+        struct mm_mask_set_ext_flags_req ext_flags_mask_set_req;
+    };
+};
+
+struct mm_set_vendor_swconfig_cfm
+{
+    u32_l swconfig_id;
+    union {
+        struct mm_set_bcn_cfg_cfm bcn_cfg_cfm;
+        struct mm_set_temp_comp_cfm temp_comp_set_cfm;
+        struct mm_get_temp_comp_cfm temp_comp_get_cfm;
+        struct mm_set_ext_flags_cfm ext_flags_set_cfm;
+        struct mm_get_ext_flags_cfm ext_flags_get_cfm;
+        struct mm_mask_set_ext_flags_cfm ext_flags_mask_set_cfm;
+    };
+};
+
 /// Structure containing the parameters of the @ref ME_RC_STATS_REQ message.
 struct me_rc_stats_req
 {
@@ -2127,6 +2327,16 @@ enum sm_msg_tag
     SM_EXTERNAL_AUTH_REQUIRED_IND,
     /// Response to external authentication request
     SM_EXTERNAL_AUTH_REQUIRED_RSP,
+    /// Request to update assoc elements after FT over the air authentication
+    SM_FT_AUTH_IND,
+    /// Response to FT authentication with updated assoc elements
+    SM_FT_AUTH_RSP,
+
+    SM_RSP_TIMEOUT_IND,
+
+    SM_COEX_TS_TIMEOUT_IND,
+
+    SM_EXTERNAL_AUTH_REQUIRED_RSP_CFM,
 
     /// MAX number of messages
     SM_MAX,
@@ -2738,6 +2948,20 @@ enum dbg_msg_tag
     DBG_GPIO_INIT_REQ,
     DBG_GPIO_INIT_CFM,
 
+    /// EF usrdata read request
+    DBG_EF_USRDATA_READ_REQ,
+    /// EF usrdata read confirm
+    DBG_EF_USRDATA_READ_CFM,
+    /// Memory block read request
+    DBG_MEM_BLOCK_READ_REQ,
+    /// Memory block read confirm
+    DBG_MEM_BLOCK_READ_CFM,
+
+    DBG_PWM_INIT_REQ,
+    DBG_PWM_INIT_CFM,
+    DBG_PWM_DEINIT_REQ,
+    DBG_PWM_DEINIT_CFM,
+
     /// Max number of Debug messages
     DBG_MAX,
 };
@@ -2871,9 +3095,9 @@ struct dbg_start_app_cfm
 enum {
     HOST_START_APP_AUTO = 1,
     HOST_START_APP_CUSTOM,
-#ifdef CONFIG_USB_BT
+//#ifdef CONFIG_USB_BT
     HOST_START_APP_REBOOT,
-#endif // (CONFIG_USB_BT)
+//#endif // (CONFIG_USB_BT)
 	HOST_START_APP_FNCALL = 4,
 	HOST_START_APP_DUMMY  = 5,
 };
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_types.h b/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_types.h
index 83b112290409..4481d7d285ea 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_types.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_types.h
@@ -1,62 +1,62 @@
-/**
- ****************************************************************************************
- *
- * @file co_types.h
- *
- * @brief This file replaces the need to include stdint or stdbool typical headers,
- *        which may not be available in all toolchains, and adds new types
- *
- * Copyright (C) RivieraWaves 2009-2019
- *
- * $Rev: $
- *
- ****************************************************************************************
- */
-
-#ifndef _LMAC_INT_H_
-#define _LMAC_INT_H_
-
-
-/**
- ****************************************************************************************
- * @addtogroup CO_INT
- * @ingroup COMMON
- * @brief Common integer standard types (removes use of stdint)
- *
- * @{
- ****************************************************************************************
- */
-
-
-/*
- * DEFINES
- ****************************************************************************************
- */
-
-#include <linux/version.h>
-#include <linux/types.h>
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0)
-#include <linux/bits.h>
-#else
-#include <linux/bitops.h>
-#endif
-
-#ifdef CONFIG_RWNX_TL4
-typedef uint16_t u8_l;
-typedef int16_t s8_l;
-typedef uint16_t bool_l;
-#else
-typedef uint8_t u8_l;
-typedef int8_t s8_l;
-typedef bool bool_l;
-#endif
-typedef uint16_t u16_l;
-typedef int16_t s16_l;
-typedef uint32_t u32_l;
-typedef int32_t s32_l;
-typedef uint64_t u64_l;
-
-
-
-/// @} CO_INT
-#endif // _LMAC_INT_H_
+/**
+ ****************************************************************************************
+ *
+ * @file co_types.h
+ *
+ * @brief This file replaces the need to include stdint or stdbool typical headers,
+ *        which may not be available in all toolchains, and adds new types
+ *
+ * Copyright (C) RivieraWaves 2009-2019
+ *
+ * $Rev: $
+ *
+ ****************************************************************************************
+ */
+
+#ifndef _LMAC_INT_H_
+#define _LMAC_INT_H_
+
+
+/**
+ ****************************************************************************************
+ * @addtogroup CO_INT
+ * @ingroup COMMON
+ * @brief Common integer standard types (removes use of stdint)
+ *
+ * @{
+ ****************************************************************************************
+ */
+
+
+/*
+ * DEFINES
+ ****************************************************************************************
+ */
+
+#include <linux/version.h>
+#include <linux/types.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0)
+#include <linux/bits.h>
+#else
+#include <linux/bitops.h>
+#endif
+
+#ifdef CONFIG_RWNX_TL4
+typedef uint16_t u8_l;
+typedef int16_t s8_l;
+typedef uint16_t bool_l;
+#else
+typedef uint8_t u8_l;
+typedef int8_t s8_l;
+typedef bool bool_l;
+#endif
+typedef uint16_t u16_l;
+typedef int16_t s16_l;
+typedef uint32_t u32_l;
+typedef int32_t s32_l;
+typedef uint64_t u64_l;
+
+
+
+/// @} CO_INT
+#endif // _LMAC_INT_H_
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/reg_access.h b/drivers/net/wireless/aic8800/aic8800_fdrv/reg_access.h
index b1d9c014e013..112ef034dcac 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/reg_access.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/reg_access.h
@@ -21,7 +21,7 @@
 #define ROM_FMAC_FW_ADDR               0x00010000
 #define RAM_FMAC_FW_ADDR               0x00120000
 #define ROM_FMAC_PATCH_ADDR            0x00180000
-#ifdef CONFIG_DPD
+#if defined(CONFIG_DPD) || defined(CONFIG_LOFT_CALIB)
 #define ROM_FMAC_CALIB_ADDR            0x00130000
 #endif
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/regdb.c b/drivers/net/wireless/aic8800/aic8800_fdrv/regdb.c
index ebc77a3e59a5..8d29c97b2027 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/regdb.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/regdb.c
@@ -2866,6 +2866,7 @@ const struct ieee80211_regdomain *reg_regdb[] = {
 	&regdom_YT,
 	&regdom_ZA,
 	&regdom_ZW,
+	NULL,
 };
 
 int reg_regdb_size = ARRAY_SIZE(reg_regdb);
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.c
index 562d5701683d..e0e2b34d33f0 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.c
@@ -19,6 +19,7 @@
 #include "rwnx_strs.h"
 #include "rwnx_events.h"
 #include "aicwf_txrxif.h"
+#include "rwnx_wakelock.h"
 #ifdef AICWF_SDIO_SUPPORT
 #include "aicwf_sdio.h"
 #else
@@ -58,6 +59,10 @@ static void cmd_complete(struct rwnx_cmd_mgr *cmd_mgr, struct rwnx_cmd *cmd)
             complete(&cmd->complete);
         }
     }
+    
+    if(cmd_mgr->queue_sz == 0){
+        rwnx_wakeup_unlock(g_rwnx_plat->usbdev->rwnx_hw->ws_tx);
+    }
 }
 
 int cmd_mgr_queue_force_defer(struct rwnx_cmd_mgr *cmd_mgr, struct rwnx_cmd *cmd)
@@ -102,6 +107,9 @@ int cmd_mgr_queue_force_defer(struct rwnx_cmd_mgr *cmd_mgr, struct rwnx_cmd *cmd
         init_completion(&cmd->complete);
 
     list_add_tail(&cmd->list, &cmd_mgr->cmds);
+    if(cmd_mgr->queue_sz == 0){
+        rwnx_wakeup_lock(g_rwnx_plat->usbdev->rwnx_hw->ws_tx);
+    }
     cmd_mgr->queue_sz++;
     spin_unlock_bh(&cmd_mgr->lock);
 
@@ -177,6 +185,9 @@ static int cmd_mgr_queue(struct rwnx_cmd_mgr *cmd_mgr, struct rwnx_cmd *cmd)
         init_completion(&cmd->complete);
 
     list_add_tail(&cmd->list, &cmd_mgr->cmds);
+    if(cmd_mgr->queue_sz == 0){
+        rwnx_wakeup_lock(g_rwnx_plat->usbdev->rwnx_hw->ws_tx);
+    }
     cmd_mgr->queue_sz++;
 
 	if(cmd->a2e_msg->id == ME_TRAFFIC_IND_REQ
@@ -202,7 +213,9 @@ static int cmd_mgr_queue(struct rwnx_cmd_mgr *cmd_mgr, struct rwnx_cmd *cmd)
 
 		kfree(cmd->a2e_msg);
     } else {
-		WAKE_CMD_WORK(cmd_mgr);
+        if(cmd_mgr->queue_sz <= 1){
+		    WAKE_CMD_WORK(cmd_mgr);
+        }
 		return 0;
 	}
 
@@ -463,6 +476,11 @@ static void cmd_mgr_drain(struct rwnx_cmd_mgr *cmd_mgr)
             complete(&cur->complete);
     }
     spin_unlock_bh(&cmd_mgr->lock);
+    
+    if(cmd_mgr->queue_sz == 0){
+        rwnx_wakeup_unlock(g_rwnx_plat->usbdev->rwnx_hw->ws_tx);
+    }
+
 }
 
 void rwnx_cmd_mgr_init(struct rwnx_cmd_mgr *cmd_mgr)
@@ -489,12 +507,14 @@ void rwnx_cmd_mgr_init(struct rwnx_cmd_mgr *cmd_mgr)
 
 void rwnx_cmd_mgr_deinit(struct rwnx_cmd_mgr *cmd_mgr)
 {
-    cmd_mgr->print(cmd_mgr);
-    cmd_mgr->drain(cmd_mgr);
-    cmd_mgr->print(cmd_mgr);
-    flush_workqueue(cmd_mgr->cmd_wq);
-    destroy_workqueue(cmd_mgr->cmd_wq);
-    memset(cmd_mgr, 0, sizeof(*cmd_mgr));
+    if(cmd_mgr->print && cmd_mgr->drain){
+        cmd_mgr->print(cmd_mgr);
+        cmd_mgr->drain(cmd_mgr);
+        cmd_mgr->print(cmd_mgr);
+        flush_workqueue(cmd_mgr->cmd_wq);
+        destroy_workqueue(cmd_mgr->cmd_wq);
+        memset(cmd_mgr, 0, sizeof(*cmd_mgr));
+    }
 }
 
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_compat.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_compat.h
index b85983532a83..204561b267f1 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_compat.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_compat.h
@@ -244,6 +244,11 @@ enum ieee80211_radiotap_he_mu_bits {
 #define REGULATORY_IGNORE_STALE_KICKOFF 0
 #else
 #define STA_TDLS_INITIATOR(sta) sta->tdls_initiator
+
+#ifndef REGULATORY_IGNORE_STALE_KICKOFF
+#define REGULATORY_IGNORE_STALE_KICKOFF 0
+#endif
+
 #endif
 
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_debugfs.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_debugfs.c
index c070aa947e25..2b37400d0e7c 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_debugfs.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_debugfs.c
@@ -491,7 +491,7 @@ static ssize_t rwnx_dbgfs_acsinfo_read(struct file *file,
 
     buf = (char*)kmalloc(sizeof(char) * ((SCAN_CHANNEL_MAX + 1) * 43), GFP_KERNEL);
     memset(buf, 0, ((SCAN_CHANNEL_MAX + 1) * 43));
-    
+
 	if (priv->band_5g_support){
 		band_max = NL80211_BAND_5GHZ + 1;
 	}
@@ -532,10 +532,10 @@ static ssize_t rwnx_dbgfs_acsinfo_read(struct file *file,
     mutex_unlock(&priv->dbgdump_elem.mutex);
 
     size = simple_read_from_buffer(user_buf, count, ppos, buf, len);
-    
+
     kfree(buf);
     buf = NULL;
-    
+
     return size;
 }
 
@@ -1255,12 +1255,18 @@ static ssize_t rwnx_dbgfs_regdbg_write(struct file *file,
 
     	buf[len] = '\0';
 
-	if (sscanf(buf, "%x %x %x" , &oper, &addr, &val ) > 0) 
+	if (sscanf(buf, "%x %x %x" , &oper, &addr, &val ) > 0)
 		printk("addr=%x, val=%x,oper=%d\n", addr, val, oper);
 
     	if(oper== 0) {
 		ret = rwnx_send_dbg_mem_read_req(priv, addr, &mem_read_cfm);
         	printk("[0x%x] = [0x%x]\n", mem_read_cfm.memaddr, mem_read_cfm.memdata);
+	} else if (oper == 1) {
+		ret = rwnx_send_dbg_mem_read_req(priv, addr, &mem_read_cfm);
+		printk("before write : [0x%x] = [0x%x]\n", mem_read_cfm.memaddr, mem_read_cfm.memdata);
+		ret = rwnx_send_dbg_mem_block_write_req(priv, addr, 4, &val);
+		ret = rwnx_send_dbg_mem_read_req(priv, addr, &mem_read_cfm);
+		printk("after write : [0x%x] = [0x%x]\n", mem_read_cfm.memaddr, mem_read_cfm.memdata);
     	}
 
 	return count;
@@ -1274,7 +1280,8 @@ static ssize_t rwnx_dbgfs_vendor_hwconfig_write(struct file *file,
 {
 	struct rwnx_hw *priv = file->private_data;
 	char buf[64];
-	int32_t addr[9];
+	int32_t addr[13];
+    int32_t addr_out[12];
 	u32_l hwconfig_id;
 	size_t len = min_t(size_t,count,sizeof(buf)-1);
 	int ret;
@@ -1287,10 +1294,10 @@ static ssize_t rwnx_dbgfs_vendor_hwconfig_write(struct file *file,
 	}
 
 	buf[len] = '\0';
-	ret = sscanf(buf, "%x %x %x %x %x %x %x %x %x %x %x %x %x",
+	ret = sscanf(buf, "%x %x %x %x %x %x %x %x %x %x %x %x %x %x",
                             &hwconfig_id, &addr[0], &addr[1], &addr[2], &addr[3], &addr[4], &addr[5], &addr[6], &addr[7], &addr[8], &addr[9], &addr[10], &addr[11]);
-	if(ret > 13) {
-		printk("param error > 13\n");
+	if(ret > 14) {
+		printk("param error > 14\n");
 	} else {
 		switch(hwconfig_id)
 		    {
@@ -1298,22 +1305,22 @@ static ssize_t rwnx_dbgfs_vendor_hwconfig_write(struct file *file,
 			if(ret != 5) {
 			    printk("param error  != 5\n");
 			    break;}
-			ret = rwnx_send_vendor_hwconfig_req(priv, hwconfig_id, addr);
+			ret = rwnx_send_vendor_hwconfig_req(priv, hwconfig_id, addr, NULL);
 			printk("ACS_TXOP_REQ bk:0x%x be:0x%x vi:0x%x vo:0x%x\n",addr[0],  addr[1], addr[2], addr[3]);
 			break;
 		    case 1:
-			if(ret != 13) {
-			    printk("param error  != 13\n");
+			if(ret != 14) {
+			    printk("param error  != 14\n");
 			    break;}
-			ret = rwnx_send_vendor_hwconfig_req(priv, hwconfig_id, addr);
-			printk("CHANNEL_ACCESS_REQ edca:%x,%x,%x,%x, vif:%x, retry_cnt:%x, rts:%x, long_nav:%x, cfe:%x, rc_retry_cnt:%x:%x:%x\n",
-                                addr[0],  addr[1], addr[2], addr[3], addr[4], addr[5], addr[6], addr[7], addr[8], addr[9], addr[10], addr[11]);
+			ret = rwnx_send_vendor_hwconfig_req(priv, hwconfig_id, addr, NULL);
+			printk("CHANNEL_ACCESS_REQ edca:%x,%x,%x,%x, vif:%x, retry_cnt:%x, rts:%x, long_nav:%x, cfe:%x, rc_retry_cnt:%x:%x:%x ccademod_th %x\n",
+                                addr[0],  addr[1], addr[2], addr[3], addr[4], addr[5], addr[6], addr[7], addr[8], addr[9], addr[10], addr[11], addr[12]);
 			break;
 		    case 2:
 			if(ret != 7) {
 		            printk("param error  != 7\n");
 			    break;}
-			ret = rwnx_send_vendor_hwconfig_req(priv, hwconfig_id, addr);
+			ret = rwnx_send_vendor_hwconfig_req(priv, hwconfig_id, addr, NULL);
 			printk("MAC_TIMESCALE_REQ sifsA:%x,sifsB:%x,slot:%x,ofdm_delay:%x,long_delay:%x,short_delay:%x\n",
                                 addr[0],  addr[1], addr[2], addr[3], addr[4], addr[5]);
 			break;
@@ -1325,10 +1332,26 @@ static ssize_t rwnx_dbgfs_vendor_hwconfig_write(struct file *file,
 			addr[2] = ~addr[2] + 1;
 			addr[3] = ~addr[3] + 1;
 			addr[4] = ~addr[4] + 1;
-			ret = rwnx_send_vendor_hwconfig_req(priv, hwconfig_id, addr);
+			ret = rwnx_send_vendor_hwconfig_req(priv, hwconfig_id, addr, NULL);
 			printk("CCA_THRESHOLD_REQ auto_cca:%d, cca20p_rise:%d cca20s_rise:%d cca20p_fail:%d cca20s_fail:%d\n",
                                 addr[0],  addr[1], addr[2], addr[3], addr[4]);
 			break;
+            case 4: // BWMODE_REQ
+                if (ret != 2) {
+                    printk("param error != 2\n");
+                } else {
+                    ret = rwnx_send_vendor_hwconfig_req(priv, hwconfig_id, addr, NULL);
+                    printk("BWMODE_REQ md=%d\n", addr[0]);
+                }
+            break;
+            case 5: // CHIP_TEMP_GET_REQ
+                if (ret != 1) {
+                    printk("param error != 1\n");
+                } else {
+                    ret = rwnx_send_vendor_hwconfig_req(priv, hwconfig_id, addr, addr_out);
+                    printk("CHIP_TEMP_GET_REQ degree=%d\n", addr_out[0]);
+                }
+            break;
 		    default:
 			printk("param error\n");
 			break;
@@ -1341,7 +1364,249 @@ static ssize_t rwnx_dbgfs_vendor_hwconfig_write(struct file *file,
 	return count;
 }
 
-DEBUGFS_WRITE_FILE_OPS(vendor_hwconfig)
+DEBUGFS_WRITE_FILE_OPS(vendor_hwconfig);
+
+static ssize_t rwnx_dbgfs_vendor_swconfig_write(struct file *file,
+            const char __user *user_buf,
+            size_t count, loff_t *ppos)
+{
+    struct rwnx_hw *priv = file->private_data;
+    char buf[64];
+    int32_t addr[12];
+    int32_t addr_out[12];
+    u32_l swconfig_id;
+    size_t len = min_t(size_t, count, sizeof(buf) - 1);
+    int ret;
+    printk("%s\n", __func__);
+
+    if (copy_from_user(buf, user_buf, len)) {
+        return -EFAULT;
+    }
+
+    buf[len] = '\0';
+    ret = sscanf(buf, "%x %x %x", &swconfig_id, &addr[0], &addr[1]);
+    if (ret > 3) {
+        printk("param error > 3\n");
+    } else {
+        switch (swconfig_id)
+        {
+            case 0: // BCN_CFG_REQ
+                if (ret != 2) {
+                    printk("param error != 2\n");
+                } else {
+                    ret = rwnx_send_vendor_swconfig_req(priv, swconfig_id, addr, addr_out);
+                    printk("BCN_CFG_REQ set_en=%d, get_en=%d\n", addr[0], addr_out[0]);
+                }
+            break;
+
+            case 1: // TEMP_COMP_SET_REQ
+                if (ret != 3) {
+                    printk("param error != 3\n");
+                } else {
+                    ret = rwnx_send_vendor_swconfig_req(priv, swconfig_id, addr, addr_out);
+                    printk("TEMP_COMP_SET_REQ set_en=%d, tmr=%dms, get_st=%d\n",
+                        addr[0], addr[1], addr_out[0]);
+                }
+            break;
+
+            case 2: // TEMP_COMP_GET_REQ
+                if (ret != 1) {
+                    printk("param error != 1\n");
+                } else {
+                    ret = rwnx_send_vendor_swconfig_req(priv, swconfig_id, addr, addr_out);
+                    printk("TEMP_COMP_GET_REQ get_st=%d, degree=%d\n", addr_out[0], addr_out[1]);
+                }
+            break;
+
+            case 3: // EXT_FLAGS_SET_REQ
+                if (ret != 2) {
+                    printk("param error != 2\n");
+                } else {
+                    ret = rwnx_send_vendor_swconfig_req(priv, swconfig_id, addr, addr_out);
+                    printk("EXT_FLAGS_SET_REQ set ext_flags=0x%x, get ext_flags=0x%x\n",
+                        addr[0], addr_out[0]);
+                }
+            break;
+
+            case 4: // EXT_FLAGS_GET_REQ
+                if (ret != 1) {
+                    printk("param error != 1\n");
+                } else {
+                    ret = rwnx_send_vendor_swconfig_req(priv, swconfig_id, addr, addr_out);
+                    printk("EXT_FLAGS_GET_REQ get ext_flags=0x%x\n", addr_out[0]);
+                }
+            break;
+
+            case 5: // EXT_FLAGS_MASK_SET_REQ
+                if (ret != 3) {
+                    printk("param error != 3\n");
+                } else {
+                    ret = rwnx_send_vendor_swconfig_req(priv, swconfig_id, addr, addr_out);
+                    printk("EXT_FLAGS_MASK_SET_REQ set ext_flags mask=0x%x, val=0x%x, get ext_flags=0x%x\n",
+                        addr[0], addr[1], addr_out[0]);
+                }
+            break;
+
+            default:
+                printk("param error\n");
+                break;
+        }
+
+        if (ret) {
+            printk("rwnx_send_vendor_swconfig_req fail: %x\n", ret);
+        }
+    }
+
+    return count;
+}
+
+DEBUGFS_WRITE_FILE_OPS(vendor_swconfig);
+
+static ssize_t rwnx_dbgfs_agg_disable_write(struct file *file,
+            const char __user *user_buf,
+            size_t count, loff_t *ppos)
+{
+    struct rwnx_hw *priv = file->private_data;
+    char buf[64];
+    int agg_disable, agg_disable_rx, sta_idx;
+    size_t len = min_t(size_t, count, sizeof(buf) - 1);
+    int ret;
+    printk("%s\n", __func__);
+
+    if (copy_from_user(buf, user_buf, len)) {
+        return -EFAULT;
+    }
+
+    buf[len] = '\0';
+    ret = sscanf(buf, "%d %d %d", &agg_disable, &agg_disable_rx, &sta_idx);
+    if ((ret > 3) || (ret < 2)) {
+        printk("param error: cnt=%d\n", ret);
+    } else {
+        if (ret < 3) {
+            sta_idx = RWNX_INVALID_STA;
+        }
+        printk("disable_agg: T=%d, R=%d, staidx=%d\n", agg_disable, agg_disable_rx, sta_idx);
+        ret = rwnx_send_disable_agg_req(priv, (u8_l)agg_disable, (u8_l)agg_disable_rx, (u8_l)sta_idx);
+        if (ret) {
+            printk("rwnx_send_disable_agg_req fail: %d\n", ret);
+        }
+    }
+
+    return count;
+}
+
+DEBUGFS_WRITE_FILE_OPS(agg_disable);
+
+static ssize_t rwnx_dbgfs_set_roc_write(struct file *file,
+            const char __user *user_buf,
+            size_t count, loff_t *ppos)
+{
+    struct rwnx_hw *priv = file->private_data;
+    struct rwnx_vif *vif = NULL;
+    char buf[64];
+    int roc_start, chan_freq, duration;
+    size_t len = min_t(size_t, count, sizeof(buf) - 1);
+    int ret;
+    int if_type = NL80211_IFTYPE_STATION;
+    printk("%s\n", __func__);
+
+    if (copy_from_user(buf, user_buf, len)) {
+        return -EFAULT;
+    }
+
+    buf[len] = '\0';
+    ret = sscanf(buf, "%d %d %d", &roc_start, &chan_freq, &duration);
+
+    list_for_each_entry(vif, &priv->vifs, list) {
+        if (RWNX_VIF_TYPE(vif) == if_type) {
+            break;
+        }
+    }
+    if ((ret > 3) || (ret < 1)) {
+        printk("param error: cnt=%d\n", ret);
+    } else if (vif) {
+        struct ieee80211_channel chan_entry = {0,};
+        struct ieee80211_channel *chan = &chan_entry;
+        struct mm_remain_on_channel_cfm roc_cfm;
+        if (ret < 3) {
+            duration = 2000;
+            if (ret < 2) {
+                chan_freq = 2412;
+            }
+        }
+        printk("set_roc: start=%d, freq=%d\n", roc_start, chan_freq);
+        if (roc_start) {
+            if (chan_freq <= 2484) {
+                chan->band = NL80211_BAND_2GHZ;
+            } else {
+                chan->band = NL80211_BAND_5GHZ;
+            }
+            chan->center_freq = chan_freq;
+            chan->max_power = 18;
+            ret = rwnx_send_roc(priv, vif, chan, duration, &roc_cfm);
+            if (ret) {
+                printk("rwnx_send_roc fail: %d\n", ret);
+            } else {
+                printk("roc_cfm: opcode=%x, st=%d, idx=%d\n", roc_cfm.op_code, roc_cfm.status, roc_cfm.chan_ctxt_index);
+            }
+        } else {
+            ret = rwnx_send_cancel_roc(priv);
+            if (ret) {
+                printk("rwnx_send_cancel_roc fail: %d\n", ret);
+            }
+        }
+    }
+
+    return count;
+}
+
+DEBUGFS_WRITE_FILE_OPS(set_roc);
+
+extern int aicwf_dbg_level;
+static ssize_t rwnx_dbgfs_dbg_level_read(struct file *file,
+			char __user *user_buf,
+			size_t count, loff_t *ppos)
+{
+	struct rwnx_hw *priv = file->private_data;
+    char buf[32];
+    int ret;
+    ssize_t read;
+
+	printk("dbg level case 1 3 7 15 31 \n");
+    ret = scnprintf(buf, min_t(size_t, sizeof(buf) - 1, count),
+                    "dbg_level=%d\n", aicwf_dbg_level);
+
+    read = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
+
+    return read;
+}
+
+
+static ssize_t rwnx_dbgfs_dbg_level_write(struct file *file,
+			const char __user *user_buf,
+			size_t count, loff_t *ppos)
+{
+	struct rwnx_hw *priv = file->private_data;
+    char buf[32];
+    int val;
+    size_t len = min_t(size_t, count, sizeof(buf) - 1);
+
+	printk("now aicwf_dbg_level = %d ;please set level case 1 3 7 15 31 \n",aicwf_dbg_level);
+
+    if (copy_from_user(buf, user_buf, len))
+        return -EFAULT;
+
+    buf[len] = '\0';
+
+	if((sscanf(buf, "%d", &val) > 0)&&(val < 32))
+		aicwf_dbg_level = val;
+
+	printk("set aicwf_dbg_level = %d \n",aicwf_dbg_level);
+    return count;
+}
+
+DEBUGFS_READ_WRITE_FILE_OPS(dbg_level);
+
 
 #ifdef CONFIG_RWNX_FULLMAC
 
@@ -1748,10 +2013,11 @@ static ssize_t rwnx_dbgfs_rc_fixed_rate_idx_write(struct file *file,
     struct rwnx_sta *sta = NULL;
     struct rwnx_hw *priv = file->private_data;
     u8 mac[6];
-    char buf[10];
+    char buf[20];
     int fixed_rate_idx = 1;
 	unsigned int formatmod, mcs, nss, bwTx, gi;
     union rwnx_rate_ctrl_info rate_config;
+	union rwnx_rate_ctrl_info *r_cfg=&rate_config;
     int error = 0;
     size_t len = min_t(size_t, count, sizeof(buf) - 1);
 
@@ -1772,7 +2038,13 @@ static ssize_t rwnx_dbgfs_rc_fixed_rate_idx_write(struct file *file,
     buf[len] = '\0';
     //sscanf(buf, "%i\n", &fixed_rate_idx);
 	sscanf(buf, "%u %u %u %u %u",&formatmod, &mcs, &nss, &bwTx, &gi);
-	//printk("%u %u %u %u %u\n",formatmod, mcs, nss, bwTx, gi);
+	printk("%u %u %u %u %u\n",formatmod, mcs, nss, bwTx, gi);
+
+    if((formatmod > 6) || (mcs > 11) || (nss > 8) || (bwTx > 6) || (gi > 3)){
+        printk("error parameter");
+        return len;
+    }
+
     /* Convert rate index into rate configuration */
     if ((fixed_rate_idx < 0) || (fixed_rate_idx >= (N_CCK + N_OFDM + N_HT + N_VHT + N_HE_SU)))
     {
@@ -1784,9 +2056,8 @@ static ssize_t rwnx_dbgfs_rc_fixed_rate_idx_write(struct file *file,
         //idx_to_rate_cfg(fixed_rate_idx, &rate_config, NULL);
         idx_to_rate_cfg1(formatmod, mcs, nss, bwTx, gi, &rate_config, NULL);
     }
-	/*union rwnx_rate_ctrl_info *r_cfg=&rate_config;
+
 	printk("formatModTx=%u mcsIndexTx=%u bwTx=%u giAndPreTypeTx=%u\n",r_cfg->formatModTx,r_cfg->mcsIndexTx,r_cfg->bwTx,r_cfg->giAndPreTypeTx);
-	printk("you wen ti");*/
 	// Forward the request to the LMAC
     if ((error = rwnx_send_me_rc_set_rate(priv, sta->sta_idx,
                                           (u16)rate_config.value)) != 0)
@@ -1794,6 +2065,7 @@ static ssize_t rwnx_dbgfs_rc_fixed_rate_idx_write(struct file *file,
         return error;
     }
 
+	printk("send success \n");
     priv->debugfs.rc_config[sta->sta_idx] = (int)rate_config.value;
     return len;
 
@@ -1891,7 +2163,7 @@ static ssize_t rwnx_dbgfs_last_rx_read(struct file *file,
         nss = last_rx->ht.mcs / 8;;
         gi = last_rx->ht.short_gi;
     } else {
-        BUG_ON((mcs = legrates_lut[last_rx->leg_rate]) == -1);
+        BUG_ON((mcs = legrates_lut[last_rx->leg_rate].idx) == -1);
         nss = 0;
         gi = 0;
     }
@@ -2169,6 +2441,10 @@ int rwnx_dbgfs_register(struct rwnx_hw *rwnx_hw, const char *name)
 #endif
     DEBUGFS_ADD_FILE(regdbg, dir_drv, S_IWUSR);
 	DEBUGFS_ADD_FILE(vendor_hwconfig, dir_drv,S_IWUSR);
+	DEBUGFS_ADD_FILE(vendor_swconfig, dir_drv,S_IWUSR);
+	DEBUGFS_ADD_FILE(agg_disable, dir_drv,S_IWUSR);
+	DEBUGFS_ADD_FILE(set_roc, dir_drv,S_IWUSR);
+	DEBUGFS_ADD_FILE(dbg_level, dir_drv, S_IWUSR | S_IRUSR);
 
 #ifdef CONFIG_RWNX_P2P_DEBUGFS
     {
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_defs.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_defs.h
index e1a75a3d742b..d039be345c41 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_defs.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_defs.h
@@ -30,6 +30,9 @@
 #include "rwnx_platform.h"
 #include "rwnx_cmds.h"
 #include "rwnx_compat.h"
+#ifdef CONFIG_FILTER_TCP_ACK
+#include "aicwf_tcp_ack.h"
+#endif
 
 #ifdef AICWF_SDIO_SUPPORT
 #include "aicwf_sdio.h"
@@ -57,6 +60,20 @@
 #define PS_SP_INTERRUPTED  255
 #define MAC_ADDR_LEN 6
 
+//because android kernel 5.15 uses kernel 6.0 or 6.1 kernel api
+#ifdef ANDROID_PLATFORM
+#define HIGH_KERNEL_VERSION KERNEL_VERSION(5, 15, 41)
+#define HIGH_KERNEL_VERSION2 KERNEL_VERSION(5, 15, 41)
+#define HIGH_KERNEL_VERSION3 KERNEL_VERSION(5, 15, 104)
+#define HIGH_KERNEL_VERSION4 KERNEL_VERSION(6, 1, 0)
+#else
+#define HIGH_KERNEL_VERSION KERNEL_VERSION(6, 0, 0)
+#define HIGH_KERNEL_VERSION2 KERNEL_VERSION(6, 1, 0)
+#define HIGH_KERNEL_VERSION3 KERNEL_VERSION(6, 3, 0)
+#define HIGH_KERNEL_VERSION4 KERNEL_VERSION(6, 3, 0)
+#endif
+
+
 
 #if LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION
 #define IEEE80211_MAX_AMPDU_BUF                             IEEE80211_MAX_AMPDU_BUF_HE
@@ -326,6 +343,7 @@ struct rwnx_vif {
     struct net_device *ndev;
     struct net_device_stats net_stats;
     struct rwnx_key key[6];
+    unsigned long drv_flags;
     atomic_t drv_conn_state;
     u8 drv_vif_index;           /* Identifier of the VIF in driver */
     u8 vif_index;               /* Identifier of the station in FW */
@@ -351,13 +369,15 @@ struct rwnx_vif {
                                     the AP */
             struct rwnx_sta *tdls_sta; /* Pointer to the TDLS station */
             bool external_auth;  /* Indicate if external authentication is in progress */
-            u8 group_cipher_type;
-            u8 paired_cipher_type;
-            //connected network info start
-            char ssid[33];//ssid max is 32, but this has one spare for '\0'
-            int ssid_len;
-            u8 bssid[ETH_ALEN];
-            //connected network info end
+            u32 group_cipher_type;
+            u32 paired_cipher_type;
+			//connected network info start
+			char ssid[33];//ssid max is 32, but this has one spare for '\0'
+			int ssid_len;
+			u8 bssid[ETH_ALEN];
+			u32 conn_owner_nlportid;
+			bool is_roam;
+			//connected network info end
         } sta;
         struct
         {
@@ -628,14 +648,16 @@ struct rwnx_hw {
     u8 cur_chanctx;
 
     u8 monitor_vif; /* FW id of the monitor interface, RWNX_INVALID_VIF if no monitor vif at fw level */
-
+#ifdef CONFIG_FILTER_TCP_ACK
+       /* tcp ack management */
+    struct tcp_ack_manage ack_m;
+#endif
     /* RoC Management */
     struct rwnx_roc_elem *roc_elem;             /* Information provided by cfg80211 in its remain on channel request */
     u32 roc_cookie_cnt;                         /* Counter used to identify RoC request sent by cfg80211 */
 
     struct rwnx_cmd_mgr *cmd_mgr;
 
-    unsigned long drv_flags;
     struct rwnx_plat *plat;
 
     spinlock_t tx_lock;
@@ -678,7 +700,7 @@ struct rwnx_hw {
 #endif
     struct rwnx_hwq hwq[NX_TXQ_CNT];
 
-    u8 avail_idx_map;
+    u64 avail_idx_map;
     u8 vif_started;
     bool adding_sta;
     struct rwnx_phy_info phy;
@@ -698,11 +720,19 @@ struct rwnx_hw {
     atomic_t p2p_alive_timer_count;
     bool band_5g_support;
     bool fwlog_en;
+    bool scanning;
+    bool p2p_working;
 
-	struct work_struct apmStalossWork;
+    struct work_struct apmStalossWork;
     struct workqueue_struct *apmStaloss_wq;
     u8 apm_vif_idx;
     u8 sta_mac_addr[6];
+    
+    struct wakeup_source *ws_rx;
+    struct wakeup_source *ws_irqrx;
+    struct wakeup_source *ws_tx;
+    struct wakeup_source *ws_pwrctrl;
+
 #ifdef CONFIG_SCHED_SCAN
         bool is_sched_scan;
 #endif//CONFIG_SCHED_SCAN 
@@ -724,7 +754,7 @@ struct rwnx_hw {
 	bool wext_scan;
 	struct completion wext_scan_com;
 	struct list_head wext_scanre_list;
-	char wext_essid[32];
+	char wext_essid[33];
 	int support_freqs[SCAN_CHANNEL_MAX];
 	int support_freqs_number;
 #endif
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.c
index 3fb4879185ba..43ae66c1287c 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.c
@@ -43,7 +43,9 @@
 #include "aicwf_txrxif.h"
 #include "aicwf_compat_8800dc.h"
 #include "aicwf_compat_8800d80.h"
-
+#include "aicwf_compat_8800d80x2.h"
+#include "aic_priv_cmd.h"
+#include "rwnx_wakelock.h"
 
 #ifdef CONFIG_USE_WIRELESS_EXT
 #include "aicwf_wext_linux.h"
@@ -182,13 +184,6 @@
     .max_power  = 30, /* FIXME */               \
 }
 
-#ifdef ANDROID_PLATFORM
-#define HIGH_KERNEL_VERSION KERNEL_VERSION(5, 15, 41)
-#else
-#define HIGH_KERNEL_VERSION KERNEL_VERSION(5, 0, 0)
-#endif
-
-
 static struct ieee80211_rate rwnx_ratetable[] = {
     RATE(10,  0x00, 0),
     RATE(20,  0x01, IEEE80211_RATE_SHORT_PREAMBLE),
@@ -395,7 +390,11 @@ static const struct ieee80211_iface_combination rwnx_combinations[] = {
     {
         .limits                 = rwnx_limits,
         .n_limits               = ARRAY_SIZE(rwnx_limits),
-        .num_different_channels = NX_CHAN_CTXT_CNT,
+#ifdef CONFIG_MCC
+		.num_different_channels = NX_CHAN_CTXT_CNT,
+#else
+		.num_different_channels = 1,
+#endif
         .max_interfaces         = NX_VIRT_DEV_MAX,
     },
     /* Keep this combination as the last one */
@@ -523,8 +522,6 @@ static const int rwnx_hwq2uapsd[NL80211_NUM_ACS] = {
 #define P2P_ALIVE_TIME_MS       (1*1000)
 #define P2P_ALIVE_TIME_COUNT    200
 
-extern uint8_t scanning;
-extern uint8_t p2p_working;
 struct semaphore aicwf_deinit_sem;
 atomic_t aicwf_deinit_atomic;
 
@@ -534,9 +531,6 @@ module_param(aicwf_dbg_level, int, 0660);
 int testmode = 0;
 char aic_fw_path[200];
 
-extern void set_testmode(int);
-
-
 void rwnx_skb_align_8bytes(struct sk_buff *skb){
 #ifdef CONFIG_ALIGN_8BYTES
 	int align __maybe_unused;
@@ -1075,12 +1069,13 @@ static void rwnx_csa_finish(struct work_struct *ws)
         } else
             rwnx_txq_vif_stop(vif, RWNX_TXQ_STOP_CHAN, rwnx_hw);
         spin_unlock_bh(&rwnx_hw->cb_lock);
-#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION)
-                cfg80211_ch_switch_notify(vif->ndev, &csa->chandef, 0, 0);
+#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION3)
+		cfg80211_ch_switch_notify(vif->ndev, &csa->chandef, 0, 0);
+#elif (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION)
+		cfg80211_ch_switch_notify(vif->ndev, &csa->chandef, 0);
 #else
-                cfg80211_ch_switch_notify(vif->ndev, &csa->chandef);
+		cfg80211_ch_switch_notify(vif->ndev, &csa->chandef);
 #endif
-
         mutex_unlock(&vif->wdev.mtx);
         __release(&vif->wdev.mtx);
     }
@@ -1224,10 +1219,21 @@ static int rwnx_open(struct net_device *dev)
     struct rwnx_hw *rwnx_hw = rwnx_vif->rwnx_hw;
     struct mm_add_if_cfm add_if_cfm;
     int error = 0;
+    int err = 0;
     u8 rwnx_rx_gain = 0x0E;
+	int waiting_counter = 10;
 
     RWNX_DBG(RWNX_FN_ENTRY_STR);
 
+	while(test_bit(RWNX_DEV_STARTED, &rwnx_vif->drv_flags)){
+		msleep(100);
+		AICWFDBG(LOGDEBUG, "%s waiting for rwnx_close \r\n", __func__);
+		waiting_counter--;
+		if(waiting_counter == 0){
+			AICWFDBG(LOGERROR, "%s error waiting for close time out \r\n", __func__);
+			break;
+		}
+	}
     // Check if it is the first opened VIF
     if (rwnx_hw->vif_started == 0)
     {
@@ -1243,10 +1249,48 @@ static int rwnx_open(struct net_device *dev)
        }
 
        /* Device is now started */
-       set_bit(RWNX_DEV_STARTED, &rwnx_hw->drv_flags);
-	   atomic_set(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTED);
     }
 
+	set_bit(RWNX_DEV_STARTED, &rwnx_vif->drv_flags);
+	atomic_set(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTED);
+	AICWFDBG(LOGDEBUG, "%s rwnx_vif->drv_flags:%d\r\n", __func__, (int)rwnx_vif->drv_flags);
+
+	if (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_AP || RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_GO)
+    {
+        #ifdef CONFIG_COEX
+        rwnx_send_coex_req(rwnx_hw, 1, 0);
+        #endif
+    }
+
+	if (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_CLIENT || RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_GO) {
+		if (!rwnx_hw->is_p2p_alive) {
+			if (rwnx_hw->p2p_dev_vif && !rwnx_hw->p2p_dev_vif->up) {
+				err = rwnx_send_add_if (rwnx_hw, rwnx_hw->p2p_dev_vif->wdev.address,
+											  RWNX_VIF_TYPE(rwnx_hw->p2p_dev_vif), false, &add_if_cfm);
+				if (err) {
+					return -EIO;
+				}
+
+				if (add_if_cfm.status != 0) {
+					return -EIO;
+				}
+
+				/* Save the index retrieved from LMAC */
+				spin_lock_bh(&rwnx_hw->cb_lock);
+				rwnx_hw->p2p_dev_vif->vif_index = add_if_cfm.inst_nbr;
+				rwnx_hw->p2p_dev_vif->up = true;
+				rwnx_hw->vif_started++;
+				rwnx_hw->vif_table[add_if_cfm.inst_nbr] = rwnx_hw->p2p_dev_vif;
+				spin_unlock_bh(&rwnx_hw->cb_lock);
+			}
+			rwnx_hw->is_p2p_alive = 1;
+#ifndef CONFIG_USE_P2P0
+			mod_timer(&rwnx_hw->p2p_alive_timer, jiffies + msecs_to_jiffies(1000));
+			atomic_set(&rwnx_hw->p2p_alive_timer_count, 0);
+#endif
+		}
+	}
+
     if (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_AP_VLAN) {
         /* For AP_vlan use same fw and drv indexes. We ensure that this index
            will not be used by fw for another vif by taking index >= NX_VIRT_DEV_MAX */
@@ -1259,11 +1303,12 @@ static int rwnx_open(struct net_device *dev)
         rwnx_vif->up = true;
         rwnx_hw->vif_started++;
         rwnx_hw->vif_table[add_if_cfm.inst_nbr] = rwnx_vif;
+        AICWFDBG(LOGDEBUG, "%s ap create vif in rwnx_hw->vif_table[%d] \r\n",
+            __func__, rwnx_vif->vif_index);
         spin_unlock_bh(&rwnx_hw->cb_lock);
     } else {
         /* Forward the information to the LMAC,
          *     p2p value not used in FMAC configuration, iftype is sufficient */
-
         if ((error = rwnx_send_add_if(rwnx_hw, rwnx_vif->wdev.address,
                                       RWNX_VIF_TYPE(rwnx_vif), false, &add_if_cfm))) {
             AICWFDBG(LOGERROR, "add if fail\n");
@@ -1281,6 +1326,8 @@ static int rwnx_open(struct net_device *dev)
         rwnx_vif->up = true;
         rwnx_hw->vif_started++;
         rwnx_hw->vif_table[add_if_cfm.inst_nbr] = rwnx_vif;
+        AICWFDBG(LOGDEBUG, "%s sta create vif in rwnx_hw->vif_table[%d] \r\n",
+            __func__, rwnx_vif->vif_index);
         spin_unlock_bh(&rwnx_hw->cb_lock);
 #ifdef CONFIG_USE_P2P0
         if(rwnx_vif->is_p2p_vif){
@@ -1288,14 +1335,6 @@ static int rwnx_open(struct net_device *dev)
             rwnx_hw->is_p2p_alive = 1;
         }
 #endif
-
-    }
-
-    if (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_AP || RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_GO)
-    {
-        #ifdef CONFIG_COEX
-        rwnx_send_coex_req(rwnx_hw, 1, 0);
-        #endif
     }
 
     if (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_MONITOR){
@@ -1341,7 +1380,9 @@ static int rwnx_close(struct net_device *dev)
     struct rwnx_vif *rwnx_vif = netdev_priv(dev);
     struct rwnx_hw *rwnx_hw = rwnx_vif->rwnx_hw;
     struct aicwf_bus *bus_if = NULL;
-	int ret = 0;
+    int ret = 0;
+    int waiting_counter = 20;
+    int test_counter = 0;
 #if defined(AICWF_USB_SUPPORT)
     struct aic_usb_dev *usbdev = NULL;
     bus_if = dev_get_drvdata(rwnx_hw->dev);
@@ -1357,25 +1398,40 @@ static int rwnx_close(struct net_device *dev)
 
     RWNX_DBG(RWNX_FN_ENTRY_STR);
 
+	test_counter = waiting_counter;
+	while(atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_DISCONNECTING||
+		atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_CONNECTING){
+		AICWFDBG(LOGDEBUG, "%s wifi is connecting or disconnecting, waiting 200ms for state to stable\r\n", __func__);
+		msleep(200);
+		test_counter--;
+		if(test_counter == 0){
+			AICWFDBG(LOGERROR, "%s connecting or disconnecting, not finish\r\n", __func__);
+			WARN_ON(1);
+			break;
+		}
+	}
+
 #if defined(AICWF_USB_SUPPORT) || defined(AICWF_SDIO_SUPPORT)
-    if (scanning){
-        scanning = false;
+    if (rwnx_hw->scanning){
+        rwnx_hw->scanning = false;
     }
 
-	if(p2p_working){
-		p2p_working = false;
-	}
+    if(rwnx_hw->p2p_working){
+	rwnx_hw->p2p_working = false;
+    }
 #endif
 #if 0
     netdev_info(dev, "CLOSE");
 #endif
 	AICWFDBG(LOGINFO, "%s %s Enter\n", __func__, dev->name);
 
+#if 0
 #ifdef CONFIG_USE_P2P0
     if(rwnx_hw->p2p_dev_vif){
         atomic_set(&rwnx_hw->p2p_alive_timer_count, P2P_ALIVE_TIME_MS);
         rwnx_hw->is_p2p_alive = 0;
     }
+#endif
 #endif
 
     rwnx_radar_cancel_cac(&rwnx_hw->radar);
@@ -1408,13 +1464,23 @@ static int rwnx_close(struct net_device *dev)
 
 		if(RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_STATION ||
 			RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_CLIENT){
-			if(atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_CONNECTING){
+			test_counter = waiting_counter;
+			if(atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_CONNECTED){
+				atomic_set(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTING);
 				rwnx_send_sm_disconnect_req(rwnx_hw, rwnx_vif, 3);
-				atomic_set(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTED);
+				while (atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_DISCONNECTING) {
+					AICWFDBG(LOGDEBUG, "%s wifi is disconnecting, waiting 100ms for state to stable\r\n", __func__);
+					msleep(100);
+					test_counter--;
+					if (test_counter ==0)
+						break;
+				}
 			}
 		}
 #ifdef CONFIG_USE_P2P0
         if(!rwnx_vif->is_p2p_vif || ( rwnx_vif->is_p2p_vif && rwnx_hw->is_p2p_alive)){
+			if (rwnx_vif->is_p2p_vif)
+				rwnx_hw->is_p2p_alive = 0;
 #endif
     		rwnx_send_remove_if(rwnx_hw, rwnx_vif->vif_index, false);
 #ifdef CONFIG_USE_P2P0
@@ -1440,6 +1506,8 @@ static int rwnx_close(struct net_device *dev)
     spin_lock_bh(&rwnx_hw->cb_lock);
 
     rwnx_vif->up = false;
+    AICWFDBG(LOGDEBUG, "%s rwnx_vif[%d] down \r\n", __func__, rwnx_vif->vif_index);
+
     if (netif_carrier_ok(dev)) {
         if (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_STATION ||
             RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_CLIENT) {
@@ -1484,16 +1552,19 @@ static int rwnx_close(struct net_device *dev)
         rwnx_ipc_tx_drain(rwnx_hw);
         #else
         #if defined(AICWF_USB_SUPPORT)
-        if (usbdev->bus_if->state != BUS_DOWN_ST && usbdev->state != USB_DOWN_ST) {
+        if (usbdev->bus_if->state != BUS_DOWN_ST && usbdev->state != USB_DOWN_ST)
         #else
-        if (sdiodev->bus_if->state != BUS_DOWN_ST) {
+        if (sdiodev->bus_if->state != BUS_DOWN_ST)
         #endif
+        {
             rwnx_send_reset(rwnx_hw);
             #if defined(AICWF_USB_SUPPORT)
             if (rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8801 ||
                     ((rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DC ||
                       rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW ||
-                      rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81)&& testmode == 0)) {
+                      rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81 ||
+                      rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81X2 ||
+                      rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D89X2)&& testmode == 0)) {
             #endif
                 // Set parameters to firmware
                 rwnx_send_me_config_req(rwnx_hw);
@@ -1504,1247 +1575,13 @@ static int rwnx_close(struct net_device *dev)
             #endif
         }
         #endif
-        clear_bit(RWNX_DEV_STARTED, &rwnx_hw->drv_flags);
     }
 
+	clear_bit(RWNX_DEV_STARTED, &rwnx_vif->drv_flags);
+	AICWFDBG(LOGDEBUG, "%s rwnx_vif->drv_flags:%d\r\n", __func__, (int)rwnx_vif->drv_flags);
     return 0;
 }
 
-#ifdef CONFIG_RFTEST
-enum {
-    SET_TX,
-    SET_TXSTOP,
-    SET_TXTONE,
-    SET_RX,
-    GET_RX_RESULT,
-    SET_RXSTOP,
-    SET_RX_METER,
-    SET_POWER,
-    SET_XTAL_CAP,
-    SET_XTAL_CAP_FINE,
-    GET_EFUSE_BLOCK,
-    SET_FREQ_CAL,
-    SET_FREQ_CAL_FINE,
-    GET_FREQ_CAL,
-    SET_MAC_ADDR,
-    GET_MAC_ADDR,
-    SET_BT_MAC_ADDR,
-    GET_BT_MAC_ADDR,
-    SET_VENDOR_INFO,
-    GET_VENDOR_INFO,
-    RDWR_PWRMM,
-    RDWR_PWRIDX,
-    RDWR_PWRLVL = RDWR_PWRIDX,
-    RDWR_PWROFST,
-    RDWR_DRVIBIT,
-    RDWR_EFUSE_PWROFST,
-    RDWR_EFUSE_DRVIBIT,
-    SET_PAPR,
-    SET_CAL_XTAL,
-    GET_CAL_XTAL_RES,
-    SET_COB_CAL,
-    GET_COB_CAL_RES,
-    RDWR_EFUSE_USRDATA,
-    SET_NOTCH,
-    RDWR_PWROFSTFINE,
-    RDWR_EFUSE_PWROFSTFINE,
-    RDWR_EFUSE_SDIOCFG,
-
-    #ifdef CONFIG_USB_BT
-    BT_CMD_BASE = 0x100,
-    BT_RESET,
-    BT_TXDH,
-    BT_RXDH,
-    BT_STOP,
-    GET_BT_RX_RESULT,
-    #endif
-};
-
-typedef struct
-{
-    u8_l chan;
-    u8_l bw;
-    u8_l mode;
-    u8_l rate;
-    u16_l length;
-}cmd_rf_settx_t;
-
-typedef struct
-{
-    u8_l val;
-}cmd_rf_setfreq_t;
-
-typedef struct
-{
-    u8_l chan;
-    u8_l bw;
-}cmd_rf_rx_t;
-
-typedef struct
-{
-    u8_l block;
-}cmd_rf_getefuse_t;
-typedef struct
-{
-    u8_l dutid;
-    u8_l chip_num;
-    u8_l dis_xtal;
-}cmd_rf_setcobcal_t;
-typedef struct
-{
-    u16_l dut_rcv_golden_num;
-    u8_l golden_rcv_dut_num;
-    s8_l rssi_static;
-    s8_l snr_static;
-    s8_l dut_rssi_static;
-    u16_l reserved;
-}cob_result_ptr_t;
-
-typedef struct
-{
-    u8_l func;
-    u8_l cnt;
-    u8_l reserved[2];
-    u32_l usrdata[3]; // 3 words totally
-} cmd_ef_usrdata_t;
-
-#endif
-
-#define CMD_MAXARGS 30
-
-#if 0
-#define isblank(c)      ((c) == ' ' || (c) == '\t')
-#define isascii(c)      (((unsigned char)(c)) <= 0x7F)
-
-static int isdigit(unsigned char c)
-{
-    return ((c >= '0') && (c <='9'));
-}
-
-static int isxdigit(unsigned char c)
-{
-    if ((c >= '0') && (c <='9'))
-        return 1;
-    if ((c >= 'a') && (c <='f'))
-        return 1;
-    if ((c >= 'A') && (c <='F'))
-        return 1;
-    return 0;
-}
-
-static int islower(unsigned char c)
-{
-    return ((c >= 'a') && (c <='z'));
-}
-
-static unsigned char toupper(unsigned char c)
-{
-    if (islower(c))
-        c -= 'a'-'A';
-    return c;
-}
-#endif
-
-
-static int parse_line (char *line, char *argv[])
-{
-    int nargs = 0;
-
-    while (nargs < CMD_MAXARGS) {
-        /* skip any white space */
-        while ((*line == ' ') || (*line == '\t')) {
-            ++line;
-        }
-
-        if (*line == '\0') {    /* end of line, no more args    */
-            argv[nargs] = 0;
-            return (nargs);
-        }
-
-        /* Argument include space should be bracketed by quotation mark */
-        if (*line == '\"') {
-            /* Skip quotation mark */
-            line++;
-
-            /* Begin of argument string */
-            argv[nargs++] = line;
-
-            /* Until end of argument */
-            while(*line && (*line != '\"')) {
-                ++line;
-            }
-        } else {
-            argv[nargs++] = line;    /* begin of argument string    */
-
-            /* find end of string */
-            while(*line && (*line != ' ') && (*line != '\t')) {
-                ++line;
-            }
-        }
-
-        if (*line == '\0') {    /* end of line, no more args    */
-            argv[nargs] = 0;
-            return (nargs);
-        }
-
-        *line++ = '\0';         /* terminate current arg     */
-    }
-
-    printk("** Too many args (max. %d) **\n", CMD_MAXARGS);
-
-    return (nargs);
-}
-
-unsigned int command_strtoul(const char *cp, char **endp, unsigned int base)
-{
-    unsigned int result = 0, value, is_neg=0;
-
-    if (*cp == '0') {
-        cp++;
-        if ((*cp == 'x') && isxdigit(cp[1])) {
-            base = 16;
-            cp++;
-        }
-        if (!base) {
-            base = 8;
-        }
-    }
-    if (!base) {
-        base = 10;
-    }
-    if (*cp == '-') {
-        is_neg = 1;
-        cp++;
-    }
-    while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp - '0' : (islower(*cp) ? toupper(*cp) : *cp) - 'A' + 10) < base) {
-        result = result * base + value;
-        cp++;
-    }
-    if (is_neg)
-        result = (unsigned int)((int)result * (-1));
-
-    if (endp)
-        *endp = (char *)cp;
-    return result;
-}
-
-
-int handle_private_cmd(struct net_device *net, char *command, u32 cmd_len)
-{
-    int bytes_written = 0;
-    char* para = NULL;
-    char* cmd = NULL;
-    char *argv[CMD_MAXARGS + 1];
-    int argc;
-    #ifdef CONFIG_RFTEST
-    struct dbg_rftest_cmd_cfm cfm = {{0,}};
-    u8_l mac_addr[6];
-    cmd_rf_settx_t settx_param;
-    cmd_rf_rx_t setrx_param;
-    int freq;
-    cmd_rf_getefuse_t getefuse_param;
-    cmd_rf_setfreq_t cmd_setfreq;
-    cmd_rf_setcobcal_t setcob_cal;
-    cob_result_ptr_t *cob_result_ptr;
-    cmd_ef_usrdata_t cmd_ef_usrdata;
-    u8_l ana_pwr;
-    u8_l dig_pwr;
-    u8_l pwr;
-    u8_l papr;
-    u8_l xtal_cap;
-    u8_l xtal_cap_fine;
-    u8_l vendor_info;
-    #ifdef CONFIG_USB_BT
-    int bt_index;
-    u8_l dh_cmd_reset[4];
-    u8_l dh_cmd_txdh[18];
-    u8_l dh_cmd_rxdh[17];
-    u8_l dh_cmd_stop[5];
-    #endif
-    #endif
-	u8_l buf[2];
-	s8_l freq_ = 0;
-	u8_l func = 0;
-	u8_l state = 0;
-
-    RWNX_DBG(RWNX_FN_ENTRY_STR);
-
-    if ((argc = parse_line(command, argv)) == 0) {
-        return -1;
-    }
-
-    do {
-        #ifdef AICWF_SDIO_SUPPORT
-        struct rwnx_hw *p_rwnx_hw = g_rwnx_plat->sdiodev->rwnx_hw;
-        #endif
-        #ifdef AICWF_USB_SUPPORT
-	#ifdef CONFIG_RFTEST
-        struct rwnx_hw *p_rwnx_hw = g_rwnx_plat->usbdev->rwnx_hw;
-	#endif
-        #endif
-        #ifdef CONFIG_RFTEST
-        if (strcasecmp(argv[0], "GET_RX_RESULT") ==0) {
-            AICWFDBG(LOGINFO, "get_rx_result\n");
-            rwnx_send_rftest_req(p_rwnx_hw, GET_RX_RESULT, 0, NULL, &cfm);
-            memcpy(command, &cfm.rftest_result[0], 8);
-            bytes_written = 8;
-        } else if (strcasecmp(argv[0], "SET_TX") == 0) {
-            AICWFDBG(LOGINFO, "set_tx\n");
-            if (argc < 6) {
-                printk("wrong param\n");
-                bytes_written = -EINVAL;
-                break;
-            }
-            settx_param.chan = command_strtoul(argv[1], NULL, 10);
-            settx_param.bw = command_strtoul(argv[2], NULL, 10);
-            settx_param.mode = command_strtoul(argv[3], NULL, 10);
-            settx_param.rate = command_strtoul(argv[4], NULL, 10);
-            settx_param.length = command_strtoul(argv[5], NULL, 10);
-            AICWFDBG(LOGINFO, "txparam:%d,%d,%d,%d,%d\n", settx_param.chan, settx_param.bw,
-                settx_param.mode, settx_param.rate, settx_param.length);
-            rwnx_send_rftest_req(p_rwnx_hw, SET_TX, sizeof(cmd_rf_settx_t), (u8_l *)&settx_param, NULL);
-        } else if (strcasecmp(argv[0], "SET_TXSTOP") == 0) {
-            AICWFDBG(LOGINFO, "settx_stop\n");
-            rwnx_send_rftest_req(p_rwnx_hw, SET_TXSTOP, 0, NULL, NULL);
-        } else if (strcasecmp(argv[0], "SET_TXTONE") == 0) {
-            AICWFDBG(LOGINFO, "set_tx_tone,argc:%d\n",argc);
-            if ((argc == 2) || (argc == 3)) {
-                AICWFDBG(LOGINFO, "argv 1:%s\n",argv[1]);
-                //u8_l func = (u8_l)command_strtoul(argv[1], NULL, 16);
-                func = (u8_l)command_strtoul(argv[1], NULL, 16);
-                //s8_l freq;
-                if (argc == 3) {
-                    AICWFDBG(LOGINFO, "argv 2:%s\n",argv[2]);
-                    freq_ = (u8_l)command_strtoul(argv[2], NULL, 10);
-                } else {
-                    freq_ = 0;
-                };
-                //u8_l buf[2] = {func, (u8_l)freq};
-                buf[0] = func;
-				buf[1] = (u8_l)freq_;
-                rwnx_send_rftest_req(p_rwnx_hw, SET_TXTONE, argc - 1, buf, NULL);
-            } else {
-                AICWFDBG(LOGINFO, "wrong args\n");
-                bytes_written = -EINVAL;
-                break;
-            }
-        } else if (strcasecmp(argv[0], "SET_RX") == 0) {
-            AICWFDBG(LOGINFO, "set_rx\n");
-            if (argc < 3) {
-                AICWFDBG(LOGERROR, "wrong param\n");
-                bytes_written = -EINVAL;
-                break;
-            }
-            setrx_param.chan = command_strtoul(argv[1], NULL, 10);
-            setrx_param.bw = command_strtoul(argv[2], NULL, 10);
-            rwnx_send_rftest_req(p_rwnx_hw, SET_RX, sizeof(cmd_rf_rx_t), (u8_l *)&setrx_param, NULL);
-        } else if (strcasecmp(argv[0], "SET_RXSTOP") == 0) {
-            AICWFDBG(LOGINFO, "set_rxstop\n");
-            rwnx_send_rftest_req(p_rwnx_hw, SET_RXSTOP, 0, NULL, NULL);
-        } else if (strcasecmp(argv[0], "SET_RX_METER") == 0) {
-            AICWFDBG(LOGINFO, "set_rx_meter\n");
-            freq = (int)command_strtoul(argv[1], NULL, 10);
-            rwnx_send_rftest_req(p_rwnx_hw, SET_RX_METER, sizeof(freq), (u8_l *)&freq, NULL);
-        } else if (strcasecmp(argv[0], "SET_FREQ_CAL") == 0) {
-            AICWFDBG(LOGINFO, "set_freq_cal\n");
-            if (argc < 2) {
-                AICWFDBG(LOGERROR, "wrong param\n");
-                bytes_written = -EINVAL;
-                break;
-            }
-            cmd_setfreq.val = command_strtoul(argv[1], NULL, 16);
-            AICWFDBG(LOGINFO, "param:%x\r\n", cmd_setfreq.val);
-            rwnx_send_rftest_req(p_rwnx_hw, SET_FREQ_CAL, sizeof(cmd_rf_setfreq_t), (u8_l *)&cmd_setfreq, &cfm);
-            memcpy(command, &cfm.rftest_result[0], 4);
-            bytes_written = 4;
-        } else if (strcasecmp(argv[0], "SET_FREQ_CAL_FINE") == 0) {
-            AICWFDBG(LOGINFO, "set_freq_cal_fine\n");
-            if (argc < 2) {
-                AICWFDBG(LOGERROR, "wrong param\n");
-                bytes_written = -EINVAL;
-                break;
-            }
-            cmd_setfreq.val = command_strtoul(argv[1], NULL, 16);
-            AICWFDBG(LOGINFO, "param:%x\r\n", cmd_setfreq.val);
-            rwnx_send_rftest_req(p_rwnx_hw, SET_FREQ_CAL_FINE, sizeof(cmd_rf_setfreq_t), (u8_l *)&cmd_setfreq, &cfm);
-            memcpy(command, &cfm.rftest_result[0], 4);
-            bytes_written = 4;
-        } else if (strcasecmp(argv[0], "GET_EFUSE_BLOCK") == 0) {
-            AICWFDBG(LOGINFO, "get_efuse_block\n");
-            if (argc < 2) {
-                AICWFDBG(LOGERROR, "wrong param\n");
-                bytes_written = -EINVAL;
-                break;
-            }
-            getefuse_param.block = command_strtoul(argv[1], NULL, 10);
-            rwnx_send_rftest_req(p_rwnx_hw, GET_EFUSE_BLOCK, sizeof(cmd_rf_getefuse_t), (u8_l *)&getefuse_param, &cfm);
-            AICWFDBG(LOGINFO, "get val=%x\r\n", cfm.rftest_result[0]);
-            memcpy(command, &cfm.rftest_result[0], 4);
-            bytes_written = 4;
-        } else if (strcasecmp(argv[0], "SET_POWER") == 0) {
-            AICWFDBG(LOGINFO, "set_power\n");
-            if (g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8801) {
-                ana_pwr = command_strtoul(argv[1], NULL, 16);
-                dig_pwr = command_strtoul(argv[2], NULL, 16);
-                pwr = (ana_pwr << 4 | dig_pwr);
-                if (ana_pwr > 0xf || dig_pwr > 0xf) {
-                    AICWFDBG(LOGERROR, "invalid param\r\n");
-                    bytes_written = -EINVAL;
-                    break;
-                }
-            } else {
-                ana_pwr = command_strtoul(argv[1], NULL, 10);
-                pwr = ana_pwr;
-                if (ana_pwr > 0x1e) {
-                    AICWFDBG(LOGERROR, "invalid param\r\n");
-                    bytes_written = -EINVAL;
-                    break;
-                }
-            }
-            AICWFDBG(LOGINFO, "pwr =%x\r\n", pwr);
-            rwnx_send_rftest_req(p_rwnx_hw, SET_POWER, sizeof(pwr), (u8_l *)&pwr, NULL);
-        } else if (strcasecmp(argv[0], "SET_PAPR") == 0) {
-            printk("set papr\n");
-            if (argc > 1) {
-                papr = command_strtoul(argv[1], NULL, 10);
-                printk("papr %d\r\n", papr);
-                rwnx_send_rftest_req(p_rwnx_hw, SET_PAPR, sizeof(papr), (u8_l *)&papr, NULL);
-            } else {
-                printk("wrong args\n");
-                bytes_written = -EINVAL;
-                break;
-            }
-        } else if (strcasecmp(argv[0], "SET_NOTCH") == 0) {
-            if (argc > 1) {
-                func = command_strtoul(argv[1], NULL, 10);
-                printk("set notch: %d\n", func);
-                rwnx_send_rftest_req(p_rwnx_hw, SET_NOTCH, sizeof(func), (u8_l *)&func, NULL);
-            } else {
-                printk("wrong args\n");
-                bytes_written = -EINVAL;
-                break;
-            }
-        } else if (strcasecmp(argv[0], "SET_XTAL_CAP")==0) {
-            AICWFDBG(LOGINFO, "set_xtal_cap\n");
-            if (argc < 2) {
-                AICWFDBG(LOGERROR, "wrong param\n");
-                bytes_written = -EINVAL;
-                break;
-            }
-            xtal_cap = command_strtoul(argv[1], NULL, 10);
-            AICWFDBG(LOGINFO, "xtal_cap =%x\r\n", xtal_cap);
-            rwnx_send_rftest_req(p_rwnx_hw, SET_XTAL_CAP, sizeof(xtal_cap), (u8_l *)&xtal_cap, &cfm);
-            memcpy(command, &cfm.rftest_result[0], 4);
-            bytes_written = 4;
-        } else if (strcasecmp(argv[0], "SET_XTAL_CAP_FINE")==0) {
-            AICWFDBG(LOGINFO, "set_xtal_cap_fine\n");
-            if (argc < 2) {
-                AICWFDBG(LOGERROR, "wrong param\n");
-                bytes_written = -EINVAL;
-                break;
-            }
-            xtal_cap_fine = command_strtoul(argv[1], NULL, 10);
-            AICWFDBG(LOGINFO, "xtal_cap_fine =%x\r\n", xtal_cap_fine);
-            rwnx_send_rftest_req(p_rwnx_hw, SET_XTAL_CAP_FINE, sizeof(xtal_cap_fine), (u8_l *)&xtal_cap_fine, &cfm);
-            memcpy(command, &cfm.rftest_result[0], 4);
-            bytes_written = 4;
-        } else if (strcasecmp(argv[0], "SET_MAC_ADDR")==0) {
-            AICWFDBG(LOGINFO, "set_mac_addr\n");
-            if (argc < 7) {
-                AICWFDBG(LOGERROR, "wrong param\n");
-                bytes_written = -EINVAL;
-                break;
-            }
-            mac_addr[5] = command_strtoul(argv[1], NULL, 16);
-            mac_addr[4] = command_strtoul(argv[2], NULL, 16);
-            mac_addr[3] = command_strtoul(argv[3], NULL, 16);
-            mac_addr[2] = command_strtoul(argv[4], NULL, 16);
-            mac_addr[1] = command_strtoul(argv[5], NULL, 16);
-            mac_addr[0] = command_strtoul(argv[6], NULL, 16);
-            AICWFDBG(LOGINFO, "set macaddr:%x,%x,%x,%x,%x,%x\n", mac_addr[5], mac_addr[4], mac_addr[3], mac_addr[2], mac_addr[1], mac_addr[0]);
-            rwnx_send_rftest_req(p_rwnx_hw, SET_MAC_ADDR, sizeof(mac_addr), (u8_l *)&mac_addr, NULL);
-        } else if (strcasecmp(argv[0], "GET_MAC_ADDR")==0) {
-            u32_l addr0, addr1;
-            AICWFDBG(LOGINFO, "get mac addr\n");
-            rwnx_send_rftest_req(p_rwnx_hw, GET_MAC_ADDR, 0, NULL, &cfm);
-            memcpy(command, &cfm.rftest_result[0], 8);
-            bytes_written = 8;
-            addr0 = cfm.rftest_result[0];
-            if ((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DC) ||
-                (g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DW)) {
-                int rem_cnt = (cfm.rftest_result[1] >> 16) & 0x00FF;
-                addr1 = cfm.rftest_result[1] & 0x0000FFFF;
-                AICWFDBG(LOGINFO, "0x%x,0x%x (remain:%x)\n", addr0, addr1, rem_cnt);
-            } else {
-                addr1 = cfm.rftest_result[1];
-                AICWFDBG(LOGINFO, "0x%x,0x%x\n", addr0, addr1);
-            }
-        } else if (strcasecmp(argv[0], "SET_BT_MAC_ADDR") == 0) {
-            AICWFDBG(LOGINFO, "set_bt_mac_addr\n");
-            if (argc < 7) {
-                AICWFDBG(LOGERROR, "wrong param\n");
-                bytes_written = -EINVAL;
-                break;
-            }
-            mac_addr[5] = command_strtoul(argv[1], NULL, 16);
-            mac_addr[4] = command_strtoul(argv[2], NULL, 16);
-            mac_addr[3] = command_strtoul(argv[3], NULL, 16);
-            mac_addr[2] = command_strtoul(argv[4], NULL, 16);
-            mac_addr[1] = command_strtoul(argv[5], NULL, 16);
-            mac_addr[0] = command_strtoul(argv[6], NULL, 16);
-            AICWFDBG(LOGINFO, "set bt macaddr:%x,%x,%x,%x,%x,%x\n", mac_addr[5], mac_addr[4], mac_addr[3], mac_addr[2], mac_addr[1], mac_addr[0]);
-            rwnx_send_rftest_req(p_rwnx_hw, SET_BT_MAC_ADDR, sizeof(mac_addr), (u8_l *)&mac_addr, NULL);
-        } else if (strcasecmp(argv[0], "GET_BT_MAC_ADDR")==0) {
-            u32_l addr0, addr1;
-            AICWFDBG(LOGINFO, "get bt mac addr\n");
-            rwnx_send_rftest_req(p_rwnx_hw, GET_BT_MAC_ADDR, 0, NULL, &cfm);
-            memcpy(command, &cfm.rftest_result[0], 8);
-            bytes_written = 8;
-            addr0 = cfm.rftest_result[0];
-            if ((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DC) ||
-                (g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DW)) {
-                int rem_cnt = (cfm.rftest_result[1] >> 16) & 0x00FF;
-                addr1 = cfm.rftest_result[1] & 0x0000FFFF;
-                AICWFDBG(LOGINFO, "0x%x,0x%x (remain:%x)\n", addr0, addr1, rem_cnt);
-            } else {
-                addr1 = cfm.rftest_result[1];
-                AICWFDBG(LOGINFO, "0x%x,0x%x\n", addr0, addr1);
-            }
-        } else if (strcasecmp(argv[0], "SET_VENDOR_INFO")==0) {
-            vendor_info = command_strtoul(argv[1], NULL, 16);
-            AICWFDBG(LOGINFO, "set vendor info:%x\n", vendor_info);
-            rwnx_send_rftest_req(p_rwnx_hw, SET_VENDOR_INFO, 1, &vendor_info, &cfm);
-            if ((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DC) ||
-                (g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DW)) {
-                memcpy(command, &cfm.rftest_result[0], 2);
-                bytes_written = 2;
-            } else {
-                memcpy(command, &cfm.rftest_result[0], 1);
-                bytes_written = 1;
-            }
-            AICWFDBG(LOGINFO, "0x%x\n", cfm.rftest_result[0]);
-        } else if (strcasecmp(argv[0], "GET_VENDOR_INFO")==0) {
-            AICWFDBG(LOGINFO, "get vendor info\n");
-            rwnx_send_rftest_req(p_rwnx_hw, GET_VENDOR_INFO, 0, NULL, &cfm);
-            if ((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DC) ||
-                (g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DW)) {
-                memcpy(command, &cfm.rftest_result[0], 2);
-                bytes_written = 2;
-            } else {
-                memcpy(command, &cfm.rftest_result[0], 1);
-                bytes_written = 1;
-            }
-            AICWFDBG(LOGINFO, "0x%x\n", cfm.rftest_result[0]);
-        } else if (strcasecmp(argv[0], "GET_FREQ_CAL") == 0) {
-            unsigned int val;
-            AICWFDBG(LOGINFO, "get freq cal\n");
-            rwnx_send_rftest_req(p_rwnx_hw, GET_FREQ_CAL, 0, NULL, &cfm);
-            memcpy(command, &cfm.rftest_result[0], 4);
-            bytes_written = 4;
-            val = cfm.rftest_result[0];
-            if ((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DC) ||
-                (g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DW)) {
-                AICWFDBG(LOGINFO, "cap=0x%x (remain:%x), cap_fine=%x (remain:%x)\n",
-                        val & 0xff, (val >> 8) & 0xff, (val >> 16) & 0xff, (val >> 24) & 0xff);
-            } else {
-                AICWFDBG(LOGINFO, "cap=0x%x, cap_fine=0x%x\n", val & 0xff, (val >> 8) & 0xff);
-            }
-        } else if (strcasecmp(argv[0], "RDWR_PWRMM") == 0) {
-            AICWFDBG(LOGINFO, "read/write txpwr manul mode\n");
-            if (argc <= 1) { // read cur
-                rwnx_send_rftest_req(p_rwnx_hw, RDWR_PWRMM, 0, NULL, &cfm);
-            } else { // write
-                u8_l pwrmm = (u8_l)command_strtoul(argv[1], NULL, 16);
-                pwrmm = (pwrmm) ? 1 : 0;
-                AICWFDBG(LOGINFO, "set pwrmm = %x\r\n", pwrmm);
-                rwnx_send_rftest_req(p_rwnx_hw, RDWR_PWRMM, sizeof(pwrmm), (u8_l *)&pwrmm, &cfm);
-            }
-            memcpy(command, &cfm.rftest_result[0], 4);
-            bytes_written = 4;
-        } else if (strcasecmp(argv[0], "RDWR_PWRIDX") == 0) {
-            u8_l func = 0;
-            #ifdef AICWF_USB_SUPPORT
-            if (g_rwnx_plat->usbdev->chipid != PRODUCT_ID_AIC8801) {
-                    AICWFDBG(LOGERROR, "unsupported cmd\n");
-                    bytes_written = -EINVAL;
-                    break;
-            }
-            #endif
-            AICWFDBG(LOGINFO, "read/write txpwr index\n");
-            if (argc > 1) {
-                func = (u8_l)command_strtoul(argv[1], NULL, 16);
-            }
-            if (func == 0) { // read cur
-                rwnx_send_rftest_req(p_rwnx_hw, RDWR_PWRIDX, 0, NULL, &cfm);
-            } else if (func <= 2) { // write 2.4g/5g pwr idx
-                if (argc > 3) {
-                    u8_l type = (u8_l)command_strtoul(argv[2], NULL, 16);
-                    u8_l pwridx = (u8_l)command_strtoul(argv[3], NULL, 10);
-                    u8_l buf[3] = {func, type, pwridx};
-                    AICWFDBG(LOGINFO, "set pwridx:[%x][%x]=%x\r\n", func, type, pwridx);
-                    rwnx_send_rftest_req(p_rwnx_hw, RDWR_PWRIDX, sizeof(buf), buf, &cfm);
-                } else {
-                    AICWFDBG(LOGERROR, "wrong args\n");
-                    bytes_written = -EINVAL;
-                    break;
-                }
-            } else {
-                AICWFDBG(LOGERROR, "wrong func: %x\n", func);
-                bytes_written = -EINVAL;
-                break;
-            }
-            memcpy(command, &cfm.rftest_result[0], 9);
-            bytes_written = 9;
-        } else if (strcasecmp(argv[0], "RDWR_PWRLVL") == 0) {
-            u8_l func = 0;
-            #ifdef AICWF_USB_SUPPORT
-            if ((g_rwnx_plat->usbdev->chipid != PRODUCT_ID_AIC8800DC)
-                && (g_rwnx_plat->usbdev->chipid != PRODUCT_ID_AIC8800DW)
-                && (g_rwnx_plat->usbdev->chipid != PRODUCT_ID_AIC8800D81)) {
-                    AICWFDBG(LOGERROR, "unsupported cmd\n");
-                    bytes_written = -EINVAL;
-                    break;
-            }
-            #endif
-            printk("read/write txpwr level\n");
-            if (argc > 1) {
-                func = (u8_l)command_strtoul(argv[1], NULL, 16);
-            }
-            if (func == 0) { // read cur
-                rwnx_send_rftest_req(p_rwnx_hw, RDWR_PWRLVL, 0, NULL, &cfm);
-            } else if (func <= 2) { // write 2.4g/5g pwr lvl
-                if (argc > 4) {
-                    u8_l grp = (u8_l)command_strtoul(argv[2], NULL, 16);
-                    u8_l idx, size;
-                    u8_l buf[14] = {func, grp,};
-                    if (argc > 12) { // set all grp
-                        printk("set pwrlvl %s:\n"
-                               "  [%x] =", (func == 1) ? "2.4g" : "5g", grp);
-                        if (grp == 1) { // TXPWR_LVL_GRP_11N_11AC
-                            size = 10;
-                        } else {
-                            size = 12;
-                        }
-                        for (idx = 0; idx < size; idx++) {
-                            s8_l pwrlvl = (s8_l)command_strtoul(argv[3 + idx], NULL, 10);
-                            buf[2 + idx] = (u8_l)pwrlvl;
-                            if (idx && !(idx & 0x3)) {
-                                printk(" ");
-                            }
-                            printk(" %2d", pwrlvl);
-                        }
-                        printk("\n");
-                        size += 2;
-                    } else { // set grp[idx]
-                        u8_l idx = (u8_l)command_strtoul(argv[3], NULL, 10);
-                        s8_l pwrlvl = (s8_l)command_strtoul(argv[4], NULL, 10);
-                        buf[2] = idx;
-                        buf[3] = (u8_l)pwrlvl;
-                        size = 4;
-                        printk("set pwrlvl %s:\n"
-                               "  [%x][%d] = %d\n", (func == 1) ? "2.4g" : "5g", grp, idx, pwrlvl);
-                    }
-                    rwnx_send_rftest_req(p_rwnx_hw, RDWR_PWRLVL, size, buf, &cfm);
-                } else {
-                    printk("wrong args\n");
-                }
-            } else {
-                printk("wrong func: %x\n", func);
-            }
-	    if(g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800D81){
-		memcpy(command, &cfm.rftest_result[0], 6 * 12);
-		bytes_written = 6 * 12;
-	    } else {
-		memcpy(command, &cfm.rftest_result[0], 3 * 12);
-		bytes_written = 3 * 12;
-	    }
-        } else if (strcasecmp(argv[0], "RDWR_PWROFST") == 0) {
-            u8_l func = 0;
-            AICWFDBG(LOGINFO, "read/write txpwr offset\n");
-            if (argc > 1) {
-                func = (u8_l)command_strtoul(argv[1], NULL, 16);
-            }
-            if (func == 0) { // read cur
-                rwnx_send_rftest_req(p_rwnx_hw, RDWR_PWROFST, 0, NULL, &cfm);
-            } else if (func <= 2) { // write 2.4g/5g pwr ofst
-                if (argc > 3) {
-                    u8_l chgrp = (u8_l)command_strtoul(argv[2], NULL, 16);
-                    s8_l pwrofst = (u8_l)command_strtoul(argv[3], NULL, 10);
-                    u8_l buf[3] = {func, chgrp, (u8_l)pwrofst};
-                    AICWFDBG(LOGINFO, "set pwrofst:[%x][%x]=%d\r\n", func, chgrp, pwrofst);
-                    rwnx_send_rftest_req(p_rwnx_hw, RDWR_PWROFST, sizeof(buf), buf, &cfm);
-                } else {
-                    AICWFDBG(LOGERROR, "wrong args\n");
-                    bytes_written = -EINVAL;
-                    break;
-                }
-            } else {
-                AICWFDBG(LOGERROR, "wrong func: %x\n", func);
-                bytes_written = -EINVAL;
-                break;
-            }
-            memcpy(command, &cfm.rftest_result[0], 7);
-            bytes_written = 7;
-        } else if (strcasecmp(argv[0], "RDWR_PWROFSTFINE") == 0) {
-            u8_l func = 0;
-            AICWFDBG(LOGINFO, "read/write txpwr offset fine\n");
-            if (argc > 1) {
-                func = (u8_l)command_strtoul(argv[1], NULL, 16);
-            }
-            if (func == 0) { // read cur
-                rwnx_send_rftest_req(p_rwnx_hw, RDWR_PWROFSTFINE, 0, NULL, &cfm);
-            } else if (func <= 2) { // write 2.4g/5g pwr ofst
-                if (argc > 3) {
-                    u8_l chgrp = (u8_l)command_strtoul(argv[2], NULL, 16);
-                    s8_l pwrofst = (u8_l)command_strtoul(argv[3], NULL, 10);
-                    u8_l buf[3] = {func, chgrp, (u8_l)pwrofst};
-                    AICWFDBG(LOGINFO, "set pwrofstfine:[%x][%x]=%d\r\n", func, chgrp, pwrofst);
-                    rwnx_send_rftest_req(p_rwnx_hw, RDWR_PWROFSTFINE, sizeof(buf), buf, &cfm);
-                } else {
-                    AICWFDBG(LOGERROR, "wrong args\n");
-                    bytes_written = -EINVAL;
-                    break;
-                }
-            } else {
-                AICWFDBG(LOGERROR, "wrong func: %x\n", func);
-                bytes_written = -EINVAL;
-                break;
-            }
-            memcpy(command, &cfm.rftest_result[0], 7);
-            bytes_written = 7;
-        } else if (strcasecmp(argv[0], "RDWR_DRVIBIT") == 0) {
-            u8_l func = 0;
-            AICWFDBG(LOGINFO, "read/write pa drv_ibit\n");
-            if (argc > 1) {
-                func = (u8_l)command_strtoul(argv[1], NULL, 16);
-            }
-            if (func == 0) { // read cur
-                rwnx_send_rftest_req(p_rwnx_hw, RDWR_DRVIBIT, 0, NULL, &cfm);
-            } else if (func == 1) { // write 2.4g pa drv_ibit
-                if (argc > 2) {
-                    u8_l ibit = (u8_l)command_strtoul(argv[2], NULL, 16);
-                    u8_l buf[2] = {func, ibit};
-                    AICWFDBG(LOGINFO, "set drvibit:[%x]=%x\r\n", func, ibit);
-                    rwnx_send_rftest_req(p_rwnx_hw, RDWR_DRVIBIT, sizeof(buf), buf, &cfm);
-                } else {
-                    AICWFDBG(LOGERROR, "wrong args\n");
-                    bytes_written = -EINVAL;
-                    break;
-                }
-            } else {
-                AICWFDBG(LOGERROR, "wrong func: %x\n", func);
-                bytes_written = -EINVAL;
-                break;
-            }
-            memcpy(command, &cfm.rftest_result[0], 16);
-            bytes_written = 16;
-        } else if (strcasecmp(argv[0], "RDWR_EFUSE_PWROFST") == 0) {
-            u8_l func = 0;
-            AICWFDBG(LOGINFO, "read/write txpwr offset into efuse\n");
-            if (argc > 1) {
-                func = (u8_l)command_strtoul(argv[1], NULL, 16);
-            }
-            if (func == 0) { // read cur
-                rwnx_send_rftest_req(p_rwnx_hw, RDWR_EFUSE_PWROFST, 0, NULL, &cfm);
-            } else if (func <= 2) { // write 2.4g/5g pwr ofst
-                if (argc > 3) {
-                    u8_l chgrp = (u8_l)command_strtoul(argv[2], NULL, 16);
-                    s8_l pwrofst = (u8_l)command_strtoul(argv[3], NULL, 10);
-                    u8_l buf[3] = {func, chgrp, (u8_l)pwrofst};
-                    AICWFDBG(LOGINFO, "set efuse pwrofst:[%x][%x]=%d\r\n", func, chgrp, pwrofst);
-                    rwnx_send_rftest_req(p_rwnx_hw, RDWR_EFUSE_PWROFST, sizeof(buf), buf, &cfm);
-                } else {
-                    AICWFDBG(LOGERROR, "wrong args\n");
-                    bytes_written = -EINVAL;
-                    break;
-                }
-            } else {
-                AICWFDBG(LOGERROR, "wrong func: %x\n", func);
-                bytes_written = -EINVAL;
-                break;
-            }
-            if ((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DC) ||
-                (g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DW)) { // 6 = 3 (2.4g) * 2
-                memcpy(command, &cfm.rftest_result[0], 6);
-                bytes_written = 6;
-            } else { // 7 = 3(2.4g) + 4(5g)
-                memcpy(command, &cfm.rftest_result[0], 7);
-                bytes_written = 7;
-            }
-        } else if (strcasecmp(argv[0], "RDWR_EFUSE_DRVIBIT") == 0) {
-            u8_l func = 0;
-            AICWFDBG(LOGINFO, "read/write pa drv_ibit into efuse\n");
-            if (argc > 1) {
-                func = (u8_l)command_strtoul(argv[1], NULL, 16);
-            }
-            if (func == 0) { // read cur
-                rwnx_send_rftest_req(p_rwnx_hw, RDWR_EFUSE_DRVIBIT, 0, NULL, &cfm);
-            } else if (func == 1) { // write 2.4g pa drv_ibit
-                if (argc > 2) {
-                u8_l ibit = (u8_l)command_strtoul(argv[2], NULL, 16);
-                u8_l buf[2] = {func, ibit};
-                AICWFDBG(LOGINFO, "set efuse drvibit:[%x]=%x\r\n", func, ibit);
-                rwnx_send_rftest_req(p_rwnx_hw, RDWR_EFUSE_DRVIBIT, sizeof(buf), buf, &cfm);
-                } else {
-                    AICWFDBG(LOGERROR, "wrong args\n");
-                    bytes_written = -EINVAL;
-                    break;
-                }
-            } else {
-                AICWFDBG(LOGERROR, "wrong func: %x\n", func);
-                bytes_written = -EINVAL;
-                break;
-            }
-            memcpy(command, &cfm.rftest_result[0], 4);
-            bytes_written = 4;
-        } else if (strcasecmp(argv[0], "RDWR_EFUSE_PWROFSTFINE") == 0) {
-            u8_l func = 0;
-            AICWFDBG(LOGINFO, "read/write txpwr offset fine into efuse\n");
-            if (argc > 1) {
-                func = (u8_l)command_strtoul(argv[1], NULL, 16);
-            }
-            if (func == 0) { // read cur
-                rwnx_send_rftest_req(p_rwnx_hw, RDWR_EFUSE_PWROFSTFINE, 0, NULL, &cfm);
-            } else if (func <= 2) { // write 2.4g/5g pwr ofst
-                if (argc > 3) {
-                    u8_l chgrp = (u8_l)command_strtoul(argv[2], NULL, 16);
-                    s8_l pwrofst = (u8_l)command_strtoul(argv[3], NULL, 10);
-                    u8_l buf[3] = {func, chgrp, (u8_l)pwrofst};
-                    AICWFDBG(LOGINFO, "set efuse pwrofstfine:[%x][%x]=%d\r\n", func, chgrp, pwrofst);
-                    rwnx_send_rftest_req(p_rwnx_hw, RDWR_EFUSE_PWROFSTFINE, sizeof(buf), buf, &cfm);
-                } else {
-                    AICWFDBG(LOGERROR, "wrong args\n");
-                    bytes_written = -EINVAL;
-                    break;
-                }
-            } else {
-                AICWFDBG(LOGERROR, "wrong func: %x\n", func);
-                bytes_written = -EINVAL;
-                break;
-            }
-            if ((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DC) ||
-                (g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DW)) { // 6 = 3 (2.4g) * 2
-                memcpy(command, &cfm.rftest_result[0], 6);
-                bytes_written = 6;
-            } else { // 7 = 3(2.4g) + 4(5g)
-                memcpy(command, &cfm.rftest_result[0], 7);
-                bytes_written = 7;
-            }
-        } else if (strcasecmp(argv[0], "RDWR_EFUSE_DRVIBIT") == 0) {
-            u8_l func = 0;
-            AICWFDBG(LOGINFO, "read/write pa drv_ibit into efuse\n");
-            if (argc > 1) {
-                func = (u8_l)command_strtoul(argv[1], NULL, 16);
-            }
-            if (func == 0) { // read cur
-                rwnx_send_rftest_req(p_rwnx_hw, RDWR_EFUSE_DRVIBIT, 0, NULL, &cfm);
-            } else if (func == 1) { // write 2.4g pa drv_ibit
-                if (argc > 2) {
-                u8_l ibit = (u8_l)command_strtoul(argv[2], NULL, 16);
-                u8_l buf[2] = {func, ibit};
-                AICWFDBG(LOGINFO, "set efuse drvibit:[%x]=%x\r\n", func, ibit);
-                rwnx_send_rftest_req(p_rwnx_hw, RDWR_EFUSE_DRVIBIT, sizeof(buf), buf, &cfm);
-                } else {
-                    AICWFDBG(LOGERROR, "wrong args\n");
-                    bytes_written = -EINVAL;
-                    break;
-                }
-            } else {
-                AICWFDBG(LOGERROR, "wrong func: %x\n", func);
-                bytes_written = -EINVAL;
-                break;
-            }
-            memcpy(command, &cfm.rftest_result[0], 4);
-            bytes_written = 4;
-        } else if (strcasecmp(argv[0], "SET_CAL_XTAL") == 0) {
-            AICWFDBG(LOGINFO, "set_cal_xtal\n");
-            rwnx_send_rftest_req(p_rwnx_hw, SET_CAL_XTAL, 0, NULL, NULL);
-        } else if (strcasecmp(argv[0], "GET_CAL_XTAL_RES") == 0) {
-            AICWFDBG(LOGINFO, "get_cal_xtal_res\n");
-            rwnx_send_rftest_req(p_rwnx_hw, GET_CAL_XTAL_RES, 0, NULL, &cfm);
-            memcpy(command, &cfm.rftest_result[0], 4);
-            bytes_written = 4;
-            AICWFDBG(LOGINFO, "cap=0x%x, cap_fine=0x%x\n", cfm.rftest_result[0] & 0x0000ffff, (cfm.rftest_result[0] >> 16) & 0x0000ffff);
-	} else if (strcasecmp(argv[0], "SET_COB_CAL") == 0) {
-	    AICWFDBG(LOGINFO, "set_cob_cal\n");
-	    if (argc < 3) {
-	    	AICWFDBG(LOGERROR, "wrong param\n");
-	    	bytes_written = -EINVAL;
-		break;
-	    }
-	    setcob_cal.dutid = command_strtoul(argv[1], NULL, 10);
-	    setcob_cal.chip_num = command_strtoul(argv[2], NULL, 10);
-	    setcob_cal.dis_xtal = command_strtoul(argv[3], NULL, 10);
-	    rwnx_send_rftest_req(p_rwnx_hw, SET_COB_CAL, sizeof(cmd_rf_setcobcal_t), (u8_l *)&setcob_cal, NULL);
-	} else if (strcasecmp(argv[0], "GET_COB_CAL_RES")==0) {
-            AICWFDBG(LOGINFO, "get_cob_cal_res\n");
-            rwnx_send_rftest_req(p_rwnx_hw, GET_COB_CAL_RES, 0, NULL, &cfm);
-            state = (cfm.rftest_result[0] >> 16) & 0x000000ff;
-            if (!state){
-            	AICWFDBG(LOGINFO, "cap= 0x%x, cap_fine= 0x%x, freq_ofst= %d Hz\n",
-            	cfm.rftest_result[0] & 0x000000ff, (cfm.rftest_result[0] >> 8) & 0x000000ff, cfm.rftest_result[1]);
-                cob_result_ptr = (cob_result_ptr_t *) & (cfm.rftest_result[2]);
-                AICWFDBG(LOGINFO, "golden_rcv_dut= %d , tx_rssi= %d dBm, snr = %d dB\ndut_rcv_godlden= %d , rx_rssi= %d dBm",
-                cob_result_ptr->golden_rcv_dut_num, cob_result_ptr->rssi_static, cob_result_ptr->snr_static,
-		cob_result_ptr->dut_rcv_golden_num, cob_result_ptr->dut_rssi_static);
-                memcpy(command, &cfm.rftest_result, 16);
-                bytes_written = 16;
-            } else {
-                AICWFDBG(LOGERROR, "cob not idle\n");
-                bytes_written = -EINVAL;
-                break;
-            }
-        } else if (strcasecmp(argv[0], "DO_COB_TEST") == 0) {
-            AICWFDBG(LOGINFO, "do_cob_test\n");
-            setcob_cal.dutid = 1;
-            setcob_cal.chip_num = 1;
-	    setcob_cal.dis_xtal = 0;
-            if (argc > 1 ) {
-	        setcob_cal.dis_xtal = command_strtoul(argv[1], NULL, 10);
-	    }
-	    rwnx_send_rftest_req(p_rwnx_hw, SET_COB_CAL, sizeof(cmd_rf_setcobcal_t), (u8_l *)&setcob_cal, NULL);
-            msleep(2000);
-            rwnx_send_rftest_req(p_rwnx_hw, GET_COB_CAL_RES, 0, NULL, &cfm);
-            state = (cfm.rftest_result[0] >> 16) & 0x000000ff;
-            if (!state){
-                AICWFDBG(LOGINFO, "cap= 0x%x, cap_fine= 0x%x, freq_ofst= %d Hz\n",
-                cfm.rftest_result[0] & 0x000000ff, (cfm.rftest_result[0] >> 8) & 0x000000ff, cfm.rftest_result[1]);
-                cob_result_ptr = (cob_result_ptr_t *) & (cfm.rftest_result[2]);
-                AICWFDBG(LOGINFO, "golden_rcv_dut= %d , tx_rssi= %d dBm, snr = %d dB\ndut_rcv_godlden= %d , rx_rssi= %d dBm",
-                cob_result_ptr->golden_rcv_dut_num, cob_result_ptr->rssi_static, cob_result_ptr->snr_static,
-                cob_result_ptr->dut_rcv_golden_num, cob_result_ptr->dut_rssi_static);
-                memcpy(command, &cfm.rftest_result, 16);
-                bytes_written = 16;
-            } else {
-                AICWFDBG(LOGERROR, "cob not idle\n");
-                bytes_written = -EINVAL;
-                break;
-            }
-        } else if (strcasecmp(argv[0], "RDWR_EFUSE_USRDATA") == 0) {
-            AICWFDBG(LOGINFO, "read/write efuse usrdata\n");
-            if (argc <= 1) { // read all
-                cmd_ef_usrdata.func = 0;
-                cmd_ef_usrdata.cnt = 3;
-            } else if (argc >= 2) { // read/write
-                cmd_ef_usrdata.func = (u8_l)command_strtoul(argv[1], NULL, 10);
-                cmd_ef_usrdata.cnt = (u8_l)command_strtoul(argv[2], NULL, 10);
-                if (cmd_ef_usrdata.func == 1) {
-                    int idx;
-                    for (idx = 0; idx < cmd_ef_usrdata.cnt; idx++) {
-                        cmd_ef_usrdata.usrdata[idx] = (u32_l)command_strtoul(argv[3 + idx], NULL, 16);
-                    }
-                }
-            } else {
-                AICWFDBG(LOGERROR, "wrong argc: %x\n", argc);
-                bytes_written = -EINVAL;
-                break;
-            }
-            rwnx_send_rftest_req(p_rwnx_hw, RDWR_EFUSE_USRDATA, sizeof(cmd_ef_usrdata), (u8_l *)&cmd_ef_usrdata, &cfm);
-            memcpy(command, &cfm.rftest_result[0], 12);
-            bytes_written = 12;
-        } else if (strcasecmp(argv[0], "RDWR_EFUSE_SDIOCFG") == 0) {
-            u8_l func = 0;
-            AICWFDBG(LOGINFO, "read/write sdiocfg_bit into efuse\n");
-            if (argc > 1) {
-                func = (u8_l)command_strtoul(argv[1], NULL, 16);
-            }
-            if (func == 0) { // read cur
-                rwnx_send_rftest_req(p_rwnx_hw, RDWR_EFUSE_SDIOCFG, 0, NULL, &cfm);
-            } else if (func == 1) { // write sdiocfg
-                if (argc > 2) {
-                u8_l ibit = (u8_l)command_strtoul(argv[2], NULL, 16);
-                u8_l buf[2] = {func, ibit};
-                AICWFDBG(LOGINFO, "set efuse sdiocfg:[%x]=%x\r\n", func, ibit);
-                rwnx_send_rftest_req(p_rwnx_hw, RDWR_EFUSE_SDIOCFG, sizeof(buf), buf, &cfm);
-                } else {
-                    AICWFDBG(LOGERROR, "wrong args\n");
-                    bytes_written = -EINVAL;
-                    break;
-                }
-            } else {
-                AICWFDBG(LOGERROR, "wrong func: %x\n", func);
-                bytes_written = -EINVAL;
-                break;
-            }
-            memcpy(command, &cfm.rftest_result[0], 4);
-            bytes_written = 4;
-	}
-        #ifdef CONFIG_USB_BT
-        else if (strcasecmp(argv[0], "BT_RESET") == 0) {
-            if (argc == 5) {
-                AICWFDBG(LOGINFO, "btrf reset\n");
-                for (bt_index = 0; bt_index < 4; bt_index++) {
-                    dh_cmd_reset[bt_index] = command_strtoul(argv[bt_index+1], NULL, 16);
-                    AICWFDBG(LOGINFO, "0x%x ",dh_cmd_reset[bt_index]);
-                }
-                AICWFDBG(LOGINFO, "\n");
-            } else {
-                AICWFDBG(LOGERROR, "wrong param\n");
-                bytes_written = -EINVAL;
-                break;
-            }
-            rwnx_send_rftest_req(p_rwnx_hw, BT_RESET, sizeof(dh_cmd_reset), (u8_l *)&dh_cmd_reset, NULL);
-        } else if (strcasecmp(argv[0], "BT_TXDH") == 0) {
-            if (argc == 19) {
-                AICWFDBG(LOGINFO, "btrf txdh\n");
-                for (bt_index = 0; bt_index < 18; bt_index++) {
-                    dh_cmd_txdh[bt_index] = command_strtoul(argv[bt_index+1], NULL, 16);
-                    AICWFDBG(LOGINFO, "0x%x ", dh_cmd_txdh[bt_index]);
-                }
-                AICWFDBG(LOGINFO, "\n");
-            } else {
-                AICWFDBG(LOGERROR, "wrong param\n");
-                bytes_written = -EINVAL;
-                break;
-            }
-            rwnx_send_rftest_req(p_rwnx_hw, BT_TXDH, sizeof(dh_cmd_txdh), (u8_l *)&dh_cmd_txdh, NULL);
-        } else if (strcasecmp(argv[0], "BT_RXDH") == 0) {
-            if (argc == 18) {
-                AICWFDBG(LOGINFO, "btrf rxdh\n");
-                for (bt_index = 0; bt_index < 17; bt_index++) {
-                    dh_cmd_rxdh[bt_index] = command_strtoul(argv[bt_index+1], NULL, 16);
-                    AICWFDBG(LOGINFO, "0x%x ", dh_cmd_rxdh[bt_index]);
-                }
-                AICWFDBG(LOGINFO, "\n");
-            } else {
-                AICWFDBG(LOGERROR, "wrong param\n");
-                bytes_written = -EINVAL;
-                break;
-            }
-            rwnx_send_rftest_req(p_rwnx_hw, BT_RXDH, sizeof(dh_cmd_rxdh), (u8_l *)&dh_cmd_rxdh, NULL);
-        } else if (strcasecmp(argv[0], "BT_STOP") == 0) {
-            if (argc == 6) {
-                AICWFDBG(LOGINFO, "btrf stop\n");
-                for (bt_index = 0; bt_index < 5; bt_index++) {
-                    dh_cmd_stop[bt_index] = command_strtoul(argv[bt_index+1], NULL, 16);
-                    AICWFDBG(LOGINFO, "0x%x ", dh_cmd_stop[bt_index]);
-                }
-                AICWFDBG(LOGINFO, "\n");
-            } else {
-                AICWFDBG(LOGERROR, "wrong param\n");
-                bytes_written = -EINVAL;
-                break;
-            }
-            rwnx_send_rftest_req(p_rwnx_hw, BT_STOP, sizeof(dh_cmd_stop), (u8_l *)&dh_cmd_stop, NULL);
-        } else if (strcasecmp(argv[0], "GET_BT_RX_RESULT") ==0) {
-            AICWFDBG(LOGINFO, "get_bt_rx_result\n");
-            rwnx_send_rftest_req(p_rwnx_hw, GET_BT_RX_RESULT, 0, NULL, &cfm);
-            memcpy(command, &cfm.rftest_result[0], 12);
-            bytes_written = 12;
-        }
-        #endif
-        else {
-            AICWFDBG(LOGERROR, "wrong cmd:%s in %s\n", cmd, __func__);
-            bytes_written = -EINVAL;
-            break;
-        }
-        #endif
-    } while(0);
-    kfree(cmd);
-    kfree(para);
-    return bytes_written;
-}
-
-//Android private command
-
-#define RWNX_COUNTRY_CODE_LEN 2
-#define CMD_SET_COUNTRY         "COUNTRY"
-#define CMD_SET_VENDOR_EX_IE    "SET_VENDOR_EX_IE"
-#define CMD_SET_AP_WPS_P2P_IE   "SET_AP_WPS_P2P_IE"
-#define CMD_SET_TESTMODE        "SET_TESTMODE"
-
-
-struct ieee80211_regdomain *getRegdomainFromRwnxDB(struct wiphy *wiphy, char *alpha2);
-struct ieee80211_regdomain *getRegdomainFromRwnxDBIndex(struct wiphy *wiphy, int index);
-extern int reg_regdb_size;
-
-#ifdef CONFIG_SET_VENDOR_EXTENSION_IE
-extern u8_l vendor_extension_data[256];
-extern u8_l vendor_extension_len;
-
-void set_vendor_extension_ie(char *command){
-
-	char databyte[3]={0x00, 0x00, 0x00};
-	int skip = strlen(CMD_SET_VENDOR_EX_IE) + 1;
-	int command_index = skip;
-	int data_index = 0;
-
-	memset(vendor_extension_data, 0, 256);
-	vendor_extension_len = 0;
-	memcpy(databyte, command + command_index, 2);
-	vendor_extension_len = command_strtoul(databyte, NULL, 16);
-	AICWFDBG(LOGINFO, "%s len:%d \r\n", __func__, vendor_extension_len);
-
-	//parser command and save data in vendor_extension_data
-	for(data_index = 0;data_index < vendor_extension_len; data_index++){
-		command_index = command_index + 3;
-		memcpy(databyte, command + command_index, 2);
-		vendor_extension_data[data_index] = command_strtoul(databyte, NULL, 16);
-	}
-
-}
-#endif//CONFIG_SET_VENDOR_EXTENSION_IE
-
-int android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
-{
-#define PRIVATE_COMMAND_MAX_LEN 8192
-#define PRIVATE_COMMAND_DEF_LEN 4096
-
-	struct rwnx_vif *vif = netdev_priv(net);
-    int ret = 0;
-    char *command = NULL;
-    int bytes_written = 0;
-    android_wifi_priv_cmd priv_cmd;
-    int buf_size = 0;
-	int skip = 0;
-	char *country = NULL;
-	struct ieee80211_regdomain *regdomain;
-	//int index = 0;
-
-    RWNX_DBG(RWNX_FN_ENTRY_STR);
-
-    ///todo: add our lock
-    //net_os_wake_lock(net);
-
-
-/*    if (!capable(CAP_NET_ADMIN)) {
-        ret = -EPERM;
-        goto exit;
-    }*/
-    if (!ifr->ifr_data) {
-        ret = -EINVAL;
-        goto exit;
-    }
-
-#ifdef CONFIG_COMPAT
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0))
-    if (in_compat_syscall())
-#else
-    if (is_compat_task())
-#endif
-    {
-        compat_android_wifi_priv_cmd compat_priv_cmd;
-        if (copy_from_user(&compat_priv_cmd, ifr->ifr_data, sizeof(compat_android_wifi_priv_cmd))) {
-	    ret = -EFAULT;
-            goto exit;
-        }
-        priv_cmd.buf = compat_ptr(compat_priv_cmd.buf);
-        priv_cmd.used_len = compat_priv_cmd.used_len;
-        priv_cmd.total_len = compat_priv_cmd.total_len;
-    } else
-#endif /* CONFIG_COMPAT */
-    {
-        if (copy_from_user(&priv_cmd, ifr->ifr_data, sizeof(android_wifi_priv_cmd))) {
-	    ret = -EFAULT;
-            goto exit;
-        }
-    }
-    if ((priv_cmd.total_len > PRIVATE_COMMAND_MAX_LEN) || (priv_cmd.total_len < 0)) {
-        AICWFDBG(LOGERROR, "%s: buf length invalid:%d\n", __FUNCTION__, priv_cmd.total_len);
-        ret = -EINVAL;
-        goto exit;
-    }
-
-    buf_size = max(priv_cmd.total_len, PRIVATE_COMMAND_DEF_LEN);
-    command = kmalloc((buf_size + 1), GFP_KERNEL);
-
-    if (!command)
-    {
-        AICWFDBG(LOGERROR, "%s: failed to allocate memory\n", __FUNCTION__);
-        ret = -ENOMEM;
-        goto exit;
-    }
-    if (copy_from_user(command, priv_cmd.buf, priv_cmd.total_len)) {
-        ret = -EFAULT;
-        goto exit;
-    }
-    command[priv_cmd.total_len] = '\0';
-
-    /* outputs */
-    AICWFDBG(LOGINFO, "%s: Android private cmd \"%s\" on %s\n", __FUNCTION__, command, ifr->ifr_name);
-    AICWFDBG(LOGINFO, "cmd = %d\n", cmd);
-    AICWFDBG(LOGINFO, "buf_size=%d\n", buf_size);
-
-
-#if 1//Handle Android command
-	if(!strncasecmp(command, CMD_SET_COUNTRY, strlen(CMD_SET_COUNTRY))) {
-		skip = strlen(CMD_SET_COUNTRY) + 1;
-		country = command + skip;
-		if (!country || strlen(country) < RWNX_COUNTRY_CODE_LEN) {
-			AICWFDBG(LOGERROR, "%s: invalid country code\n", __func__);
-			ret = -EINVAL;
-			goto exit;
-		}
-#if 0
-		for(index = 0; index < reg_regdb_size; index++){
-			regdomain = getRegdomainFromRwnxDBIndex(vif->rwnx_hw->wiphy, index);
-			if((ret = regulatory_set_wiphy_regd(vif->rwnx_hw->wiphy, regdomain))){
-				AICWFDBG(LOGERROR, "regulatory_set_wiphy_regd fail \r\n");
-			}else{
-				AICWFDBG(LOGINFO, "regulatory_set_wiphy_regd ok \r\n");
-			}
-		}
-#endif
-		AICWFDBG(LOGINFO, "%s country code:%c%c\n", __func__, toupper(country[0]), toupper(country[1]));
-		regdomain = getRegdomainFromRwnxDB(vif->rwnx_hw->wiphy, country);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 0, 0)
-		if((ret = regulatory_set_wiphy_regd(vif->rwnx_hw->wiphy, regdomain))){
-			AICWFDBG(LOGERROR, "regulatory_set_wiphy_regd fail \r\n");
-		}
-#else
-		wiphy_apply_custom_regulatory(vif->rwnx_hw->wiphy, regdomain);
-#endif
-	}
-#ifdef CONFIG_SET_VENDOR_EXTENSION_IE
-	else if(!strncasecmp(command, CMD_SET_VENDOR_EX_IE, strlen(CMD_SET_VENDOR_EX_IE))){
-		set_vendor_extension_ie(command);
-	}
-#endif//CONFIG_SET_VENDOR_EXTENSION_IE
-	else if(!strncasecmp(command, CMD_SET_AP_WPS_P2P_IE, strlen(CMD_SET_AP_WPS_P2P_IE))){
-		ret = 0;
-		goto exit;
-	}else if(!strncasecmp(command, CMD_SET_TESTMODE, strlen(CMD_SET_TESTMODE))){
-    	if(g_rwnx_plat && g_rwnx_plat->usbdev->rwnx_hw){
-            if (g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DW ||
-                (g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DC)){
-                set_testmode(!testmode);
-	            rwnx_send_reboot(g_rwnx_plat->usbdev->rwnx_hw);
-            }
-        }
-        ret = 0;
-		goto exit;
-    }
-#endif//Handle Android command
-
-
-    bytes_written = handle_private_cmd(net, command, priv_cmd.total_len);
-    if (bytes_written >= 0) {
-        if ((bytes_written == 0) && (priv_cmd.total_len > 0)) {
-            command[0] = '\0';
-        }
-        if (bytes_written >= priv_cmd.total_len) {
-            AICWFDBG(LOGINFO, "%s: err. bytes_written:%d >= buf_size:%d \n",
-                __FUNCTION__, bytes_written, buf_size);
-            goto exit;
-        }
-        bytes_written++;
-        priv_cmd.used_len = bytes_written;
-        if (copy_to_user(priv_cmd.buf, command, bytes_written)) {
-            AICWFDBG(LOGERROR, "%s: failed to copy data to user buffer\n", __FUNCTION__);
-            ret = -EFAULT;
-        }
-    }
-    else {
-        /* Propagate the error */
-        ret = bytes_written;
-    }
-
-exit:
-    ///todo: add our unlock
-    //net_os_wake_unlock(net);
-    kfree(command);
-    return ret;
-}
 
 #define IOCTL_HOSTAPD   (SIOCIWFIRSTPRIV+28)
 #define IOCTL_WPAS      (SIOCIWFIRSTPRIV+30)
@@ -2832,11 +1669,11 @@ static int rwnx_set_mac_address(struct net_device *dev, void *addr)
 static const struct net_device_ops rwnx_netdev_ops = {
     .ndo_open               = rwnx_open,
     .ndo_stop               = rwnx_close,
-    #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
     .ndo_siocdevprivate     = rwnx_do_ioctl,
-    #else
+#else
     .ndo_do_ioctl           = rwnx_do_ioctl,
-    #endif
+#endif
     .ndo_start_xmit         = rwnx_start_xmit,
     .ndo_get_stats          = rwnx_get_stats,
 #ifndef CONFIG_ONE_TXQ
@@ -2907,7 +1744,6 @@ static struct rwnx_vif *rwnx_interface_add(struct rwnx_hw *rwnx_hw,
     int i;
     int nx_nb_ndev_txq = NX_NB_NDEV_TXQ;
 
-
     if((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8801) ||
 		((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DC ||
 		g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8800DW) && chip_id < 3)){
@@ -3031,25 +1867,24 @@ static struct rwnx_vif *rwnx_interface_add(struct rwnx_hw *rwnx_hw,
         break;
     }
 
-    if (type == NL80211_IFTYPE_AP_VLAN) {
-        memcpy(ndev->dev_addr, params->macaddr, ETH_ALEN);
-        memcpy(vif->wdev.address, params->macaddr, ETH_ALEN);
-    }
-    else {
-#if 1
-        unsigned char mac_addr[6];
-	memcpy(mac_addr, rwnx_hw->wiphy->perm_addr, ETH_ALEN);
-        memcpy(mac_addr, rwnx_hw->wiphy->perm_addr, ETH_ALEN);
-        mac_addr[5] ^= vif_idx;
-//        memcpy(ndev->dev_addr, mac_addr, ETH_ALEN);
-        eth_hw_addr_set(ndev, mac_addr);
-	memcpy(vif->wdev.address, ndev->dev_addr, ETH_ALEN);
+	if (type == NL80211_IFTYPE_AP_VLAN) {
+		memcpy((void *)ndev->dev_addr, (const void *)params->macaddr, ETH_ALEN);
+		memcpy((void *)vif->wdev.address, (const void *)params->macaddr, ETH_ALEN);
+	} else {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 17, 0)
+		unsigned char mac_addr[6];
+		memcpy(mac_addr, rwnx_hw->wiphy->perm_addr, ETH_ALEN);
+		mac_addr[5] ^= vif_idx;
+		//memcpy(ndev->dev_addr, mac_addr, ETH_ALEN);
+		eth_hw_addr_set(ndev, mac_addr);
+		memcpy(vif->wdev.address, mac_addr, ETH_ALEN);
 #else
-        memcpy(ndev->dev_addr, rwnx_hw->wiphy->perm_addr, ETH_ALEN);
-        ndev->dev_addr[5] ^= vif_idx;
-        memcpy(vif->wdev.address, ndev->dev_addr, ETH_ALEN);
+		memcpy(ndev->dev_addr, rwnx_hw->wiphy->perm_addr, ETH_ALEN);
+		ndev->dev_addr[5] ^= vif_idx;
+		memcpy(vif->wdev.address, ndev->dev_addr, ETH_ALEN);
 #endif
-    }
+	}
+
 
 	AICWFDBG(LOGINFO, "interface add:%x %x %x %x %x %x\n", vif->wdev.address[0], vif->wdev.address[1],
         vif->wdev.address[2], vif->wdev.address[3], vif->wdev.address[4], vif->wdev.address[5]);
@@ -3069,9 +1904,13 @@ static struct rwnx_vif *rwnx_interface_add(struct rwnx_hw *rwnx_hw,
 #endif
 #endif
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)
+        if (cfg80211_register_netdevice(ndev))
+#else
+        if (register_netdevice(ndev))
+#endif
+            goto err;
 
-    if (register_netdevice(ndev))
-        goto err;
 
     spin_lock_bh(&rwnx_hw->cb_lock);
     list_add_tail(&vif->list, &rwnx_hw->vifs);
@@ -3108,7 +1947,7 @@ void aicwf_p2p_alive_timeout(struct timer_list *t)
 
 #if 1 //AIDEN workaround
 	if(atomic_read(&rwnx_hw->p2p_alive_timer_count) > 2){
-		p2p_working = 0;
+		rwnx_hw->p2p_working = false;
 	}
 #endif
 
@@ -3147,6 +1986,7 @@ void aicwf_p2p_alive_timeout(struct timer_list *t)
 
      rwnx_vif->up = false;
      rwnx_hw->vif_table[rwnx_vif->vif_index] = NULL;
+     AICWFDBG(LOGDEBUG, "%s rwnx_vif[%d] down \r\n", __func__, rwnx_vif->vif_index);
      rwnx_hw->vif_started--;
      spin_unlock_bh(&rwnx_hw->cb_lock);
 }
@@ -3366,7 +2206,12 @@ static int rwnx_cfg80211_del_iface(struct wiphy *wiphy, struct wireless_dev *wde
 	AICWFDBG(LOGINFO, "%s Remove Interface \r\n", dev->name);
     if (dev->reg_state == NETREG_REGISTERED) {
         /* Will call rwnx_close if interface is UP */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)
+        cfg80211_unregister_netdevice(dev);
+#else
         unregister_netdevice(dev);
+#endif
+
     }
 
     spin_lock_bh(&rwnx_hw->cb_lock);
@@ -3399,7 +2244,7 @@ static int rwnx_cfg80211_change_iface(struct wiphy *wiphy,
     int ret;
 
     RWNX_DBG(RWNX_FN_ENTRY_STR);
-	AICWFDBG(LOGINFO, "change_if: %d to %d, %d, %d", vif->wdev.iftype, type, NL80211_IFTYPE_P2P_CLIENT, NL80211_IFTYPE_STATION);
+	AICWFDBG(LOGINFO, "change_if: %d to %d, %d, %d\r\n", vif->wdev.iftype, type, NL80211_IFTYPE_P2P_CLIENT, NL80211_IFTYPE_STATION);
 
 #ifdef CONFIG_COEX
     if (type == NL80211_IFTYPE_AP || type == NL80211_IFTYPE_P2P_GO)
@@ -3465,6 +2310,7 @@ static int rwnx_cfg80211_change_iface(struct wiphy *wiphy,
 	    /* Abort scan request on the vif */
 	    if (vif->rwnx_hw->scan_request &&
 	        vif->rwnx_hw->scan_request->wdev == &vif->wdev) {
+#if 0
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 8, 0)
 	        struct cfg80211_scan_info info = {
 	            .aborted = true,
@@ -3478,7 +2324,14 @@ static int rwnx_cfg80211_change_iface(struct wiphy *wiphy,
 	            return ret;
 	        }
 	        vif->rwnx_hw->scan_request = NULL;
+#else
+            if ((ret = rwnx_send_scanu_cancel_req(vif->rwnx_hw, NULL))) {
+                AICWFDBG(LOGERROR, "scanu_cancel fail\n");
+                return ret;
+            }
+#endif
 	    }
+
 	    if ((ret = rwnx_send_remove_if(vif->rwnx_hw, vif->vif_index, false))) {
 			AICWFDBG(LOGERROR, "remove_if fail\n");
 	        return ret;
@@ -3590,6 +2443,7 @@ static void rwnx_cfgp2p_stop_p2p_device(struct wiphy *wiphy, struct wireless_dev
 			spin_lock_bh(&rwnx_hw->cb_lock);
 			rwnx_vif->up = false;
 			rwnx_hw->vif_table[rwnx_vif->vif_index] = NULL;
+            AICWFDBG(LOGDEBUG, "%s rwnx_vif[%d] down \r\n", __func__, rwnx_vif->vif_index);
 			rwnx_hw->vif_started--;
 			spin_unlock_bh(&rwnx_hw->cb_lock);
 		}
@@ -3648,14 +2502,14 @@ static int rwnx_cfg80211_scan(struct wiphy *wiphy,
 	}
 
 #ifndef CONFIG_STA_SCAN_WHEN_P2P_WORKING
-	if (p2p_working && RWNX_VIF_TYPE(rwnx_vif) != NL80211_IFTYPE_P2P_CLIENT &&
+	if (rwnx_hw->p2p_working && RWNX_VIF_TYPE(rwnx_vif) != NL80211_IFTYPE_P2P_CLIENT &&
 		!rwnx_send_check_p2p(request)) {
 		AICWFDBG(LOGINFO, "p2p is working, scan abort\n");
 		return -EBUSY;
 	}
 #endif
 
-	if (scanning) {
+	if (rwnx_hw->scanning) {
 		AICWFDBG(LOGERROR, "%s is scanning, abort\n", __func__);
     #if 0//AIDEN test
 		error =  rwnx_send_scanu_cancel_req(rwnx_hw, NULL);
@@ -3684,7 +2538,7 @@ bool key_flag = false;
  *	when adding a group key.
  */
 static int rwnx_cfg80211_add_key(struct wiphy *wiphy, struct net_device *netdev,
-#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION)
+#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION2)
                                                                  int link_id,
 #endif
                                  u8 key_index, bool pairwise, const u8 *mac_addr,
@@ -3780,7 +2634,7 @@ static int rwnx_cfg80211_add_key(struct wiphy *wiphy, struct net_device *netdev,
  *
  */
 static int rwnx_cfg80211_get_key(struct wiphy *wiphy, struct net_device *netdev,
-#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION)
+#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION2)
                                                                  int link_id,
 #endif
 
@@ -3799,7 +2653,7 @@ static int rwnx_cfg80211_get_key(struct wiphy *wiphy, struct net_device *netdev,
  *	and @key_index, return -ENOENT if the key doesn't exist.
  */
 static int rwnx_cfg80211_del_key(struct wiphy *wiphy, struct net_device *netdev,
-#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION)
+#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION2)
                                                                  int link_id,
 #endif
 
@@ -3840,7 +2694,7 @@ static int rwnx_cfg80211_del_key(struct wiphy *wiphy, struct net_device *netdev,
  */
 static int rwnx_cfg80211_set_default_key(struct wiphy *wiphy,
                                          struct net_device *netdev,
-#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION)
+#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION2)
                                                                  int link_id,
 #endif
                                          u8 key_index, bool unicast, bool multicast)
@@ -3855,7 +2709,7 @@ static int rwnx_cfg80211_set_default_key(struct wiphy *wiphy,
  */
 static int rwnx_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,
                                               struct net_device *netdev,
-#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION)
+#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION2)
                                                                  int link_id,
 #endif
                                               u8 key_index)
@@ -3892,8 +2746,16 @@ static int rwnx_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
 		return -EALREADY;
 	}
 #endif
-	if((int)atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_DISCONNECTING){
-		AICWFDBG(LOGERROR, "%s driver is disconnecting return it \r\n", __func__);
+	if((int)atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_CONNECTED) {
+		AICWFDBG(LOGDEBUG, "%s this connection is roam \r\n", __func__);
+		rwnx_vif->sta.is_roam = true;
+	}else{
+		rwnx_vif->sta.is_roam = false;
+	}
+
+	if((int)atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_DISCONNECTING||
+		(int)atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_CONNECTING) {
+		AICWFDBG(LOGERROR, "%s driver is disconnecting or connecting ,return it \r\n", __func__);
 		return -EALREADY;
 	}
 #endif
@@ -3937,7 +2799,7 @@ static int rwnx_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
         key_params.seq_len = 0;
         key_params.cipher = sme->crypto.cipher_group;
         rwnx_cfg80211_add_key(wiphy, dev,
-#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION)
+#if (LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION2)
                                 0,
 #endif
 	sme->key_idx, false, NULL, &key_params);
@@ -4021,11 +2883,17 @@ static int rwnx_cfg80211_disconnect(struct wiphy *wiphy, struct net_device *dev,
 		msleep(500);
 	}
 
+	if(atomic_read(&rwnx_vif->drv_conn_state) == RWNX_DRV_STATUS_DISCONNECTING) {
+		AICWFDBG(LOGERROR, "%s wifi is disconnecting, return it:%d \r\n",
+				__func__, reason_code);
+		return -EBUSY;
+	}
+
 	if(atomic_read(&rwnx_vif->drv_conn_state) == RWNX_DRV_STATUS_CONNECTED){
 		atomic_set(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTING);
 
 		#ifdef CONFIG_USE_WIRELESS_EXT
-		memset(rwnx_hw->wext_essid, 0, 32);
+		memset(rwnx_hw->wext_essid, 0, 33);
 		#endif
 		key_flag = true;
 		return(rwnx_send_sm_disconnect_req(rwnx_hw, rwnx_vif, reason_code));
@@ -4033,6 +2901,7 @@ static int rwnx_cfg80211_disconnect(struct wiphy *wiphy, struct net_device *dev,
 		cfg80211_connect_result(dev,  NULL, NULL, 0, NULL, 0,
 			reason_code?reason_code:WLAN_STATUS_UNSPECIFIED_FAILURE, GFP_ATOMIC);
 		atomic_set(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTED);
+		rwnx_external_auth_disable(rwnx_vif);
 		return 0;
 	}
 
@@ -4041,7 +2910,7 @@ static int rwnx_cfg80211_disconnect(struct wiphy *wiphy, struct net_device *dev,
 #ifdef CONFIG_SCHED_SCAN
 
 static int rwnx_cfg80211_sched_scan_stop(struct wiphy *wiphy,
-					   struct net_device *ndev 
+					   struct net_device *ndev
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
 					   ,u64 reqid)
 #else
@@ -4066,17 +2935,17 @@ static int rwnx_cfg80211_sched_scan_start(struct wiphy *wiphy,
                              struct net_device *dev,
                              struct cfg80211_sched_scan_request *request)
 
-{	
+{
     struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
 	struct rwnx_vif *rwnx_vif = netdev_priv(dev);
     struct cfg80211_scan_request *scan_request = NULL;
 
     int ret = 0;
     int index = 0;
-    
+
     AICWFDBG(LOGINFO, "%s enter wiphy:%p\r\n", __func__, wiphy);
 
-    if(rwnx_hw->is_sched_scan || scanning){
+    if(rwnx_hw->is_sched_scan || rwnx_hw->scanning){
         AICWFDBG(LOGERROR, "%s is_sched_scanning and scanning, busy", __func__);
         return -EBUSY;
     }
@@ -4092,29 +2961,31 @@ static int rwnx_cfg80211_sched_scan_start(struct wiphy *wiphy,
     scan_request->flags = request->flags;
     scan_request->wiphy = wiphy;
     scan_request->scan_start = request->scan_start;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,19,0)
     memcpy(scan_request->mac_addr, request->mac_addr, ETH_ALEN);
     memcpy(scan_request->mac_addr_mask, request->mac_addr_mask, ETH_ALEN);
+#endif
     rwnx_hw->sched_scan_req = request;
     scan_request->wdev = &rwnx_vif->wdev;
     AICWFDBG(LOGDEBUG, "%s scan_request->n_channels:%d \r\n", __func__, scan_request->n_channels);
     AICWFDBG(LOGDEBUG, "%s scan_request->n_ssids:%d \r\n", __func__, scan_request->n_ssids);
-    
+
     for(index = 0; index < scan_request->n_ssids; index++){
         memset(scan_request->ssids[index].ssid, 0, IEEE80211_MAX_SSID_LEN);
-        
-        memcpy(scan_request->ssids[index].ssid, 
-            request->match_sets[index].ssid.ssid, 
+
+        memcpy(scan_request->ssids[index].ssid,
+            request->match_sets[index].ssid.ssid,
             IEEE80211_MAX_SSID_LEN);
-        
+
         scan_request->ssids[index].ssid_len = request->match_sets[index].ssid.ssid_len;
-        
-        AICWFDBG(LOGDEBUG, "%s request ssid:%s len:%d \r\n", __func__, 
+
+        AICWFDBG(LOGDEBUG, "%s request ssid:%s len:%d \r\n", __func__,
             scan_request->ssids[index].ssid, scan_request->ssids[index].ssid_len);
     }
-    
+
 	for(index = 0;index < scan_request->n_channels; index++){
 		scan_request->channels[index] = request->channels[index];
-      
+
         AICWFDBG(LOGDEBUG, "%s scan_request->channels[%d]:%d \r\n", __func__, index,
             scan_request->channels[index]->center_freq);
 
@@ -4123,10 +2994,10 @@ static int rwnx_cfg80211_sched_scan_start(struct wiphy *wiphy,
 			continue;
 		}
 	}
-    
+
     rwnx_hw->is_sched_scan = true;
-    
-    if(scanning){
+
+    if(rwnx_hw->scanning){
         AICWFDBG(LOGERROR, "%s scanning, about it", __func__);
         kfree(scan_request);
         return -EBUSY;
@@ -4318,13 +3189,11 @@ static int rwnx_cfg80211_del_station_compat(struct wiphy *wiphy,
     struct aicwf_rx_priv *rx_priv;
 #endif
 
-    //RWNX_DBG(RWNX_FN_ENTRY_STR);
-    AICWFDBG(LOGDEBUG ,"%s: %pM\n", __func__, mac);
-
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)
     if (params)
         mac = params->mac;
 #endif
+    AICWFDBG(LOGDEBUG ,"%s: %pM\n", __func__, mac);
 
 	do {
 		spin_lock_bh(&rwnx_hw->cb_lock);
@@ -4772,6 +3641,7 @@ static int rwnx_cfg80211_start_ap(struct wiphy *wiphy, struct net_device *dev,
             u8 txq_status = 0;
             rwnx_vif->ap.bcmc_index = apm_start_cfm.bcmc_idx;
             rwnx_vif->ap.flags = 0;
+	    rwnx_vif->ap.csa = NULL;
             #if (defined CONFIG_HE_FOR_OLD_KERNEL) || (defined CONFIG_VHT_FOR_OLD_KERNEL)
             rwnx_vif->ap.aic_index = 0;
             #endif
@@ -4842,8 +3712,13 @@ static int rwnx_cfg80211_start_ap(struct wiphy *wiphy, struct net_device *dev,
  * @change_beacon: Change the beacon parameters for an access point mode
  *	interface. This should reject the call when AP mode wasn't started.
  */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(6, 7, 0)
+static int rwnx_cfg80211_change_beacon(struct wiphy *wiphy, struct net_device *dev,
+                                       struct cfg80211_ap_update *info)
+#else
 static int rwnx_cfg80211_change_beacon(struct wiphy *wiphy, struct net_device *dev,
                                        struct cfg80211_beacon_data *info)
+#endif
 {
     struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
     struct rwnx_vif *vif = netdev_priv(dev);
@@ -4857,7 +3732,11 @@ static int rwnx_cfg80211_change_beacon(struct wiphy *wiphy, struct net_device *d
 	elem.dma_addr = 0;
 
     // Build the beacon
+#if LINUX_VERSION_CODE > KERNEL_VERSION(6, 7, 0)
+    buf = rwnx_build_bcn(bcn, &info->beacon);
+#else
     buf = rwnx_build_bcn(bcn, info);
+#endif
     if (!buf)
         return -ENOMEM;
 
@@ -5184,7 +4063,7 @@ static int rwnx_cfg80211_set_txq_params(struct wiphy *wiphy, struct net_device *
  */
 
 static int
-rwnx_cfg80211_remain_on_channel(struct wiphy *wiphy,
+rwnx_cfg80211_remain_on_channel_(struct wiphy *wiphy,
                             #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
                                 struct wireless_dev *wdev,
                             #else
@@ -5194,7 +4073,7 @@ rwnx_cfg80211_remain_on_channel(struct wiphy *wiphy,
                             #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 8, 0)
                                 enum nl80211_channel_type channel_type,
                             #endif
-                                unsigned int duration, u64 *cookie)
+                                unsigned int duration, u64 *cookie, bool mgmt_roc_flag)
 {
     struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
@@ -5264,12 +4143,16 @@ rwnx_cfg80211_remain_on_channel(struct wiphy *wiphy,
             rwnx_hw->vif_table[add_if_cfm.inst_nbr] = rwnx_vif;
             spin_unlock_bh(&rwnx_hw->cb_lock);
             rwnx_hw->is_p2p_alive = 1;
+#ifndef CONFIG_USE_P2P0
             mod_timer(&rwnx_hw->p2p_alive_timer, jiffies + msecs_to_jiffies(1000));
             atomic_set(&rwnx_hw->p2p_alive_timer_count, 0);
+#endif
         }
         else {
+#ifndef CONFIG_USE_P2P0
             mod_timer(&rwnx_hw->p2p_alive_timer, jiffies + msecs_to_jiffies(1000));
             atomic_set(&rwnx_hw->p2p_alive_timer_count, 0);
+#endif
         }
     }
 
@@ -5285,7 +4168,7 @@ rwnx_cfg80211_remain_on_channel(struct wiphy *wiphy,
     roc_elem->wdev = wdev;
     roc_elem->chan = chan;
     roc_elem->duration = duration;
-    roc_elem->mgmt_roc = false;
+    roc_elem->mgmt_roc = mgmt_roc_flag;
     roc_elem->on_chan = false;
 
     /* Initialize the OFFCHAN TX queue to allow off-channel transmissions */
@@ -5317,6 +4200,33 @@ rwnx_cfg80211_remain_on_channel(struct wiphy *wiphy,
     return error;
 }
 
+
+static int
+rwnx_cfg80211_remain_on_channel(struct wiphy *wiphy,
+                            #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+                                struct wireless_dev *wdev,
+                            #else
+                                struct net_device *dev,
+                            #endif
+                                struct ieee80211_channel *chan,
+                            #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 8, 0)
+                                enum nl80211_channel_type channel_type,
+                            #endif
+                                unsigned int duration, u64 *cookie)
+{
+	return rwnx_cfg80211_remain_on_channel_(wiphy,
+                            #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+                                wdev,
+                            #else
+                                dev,
+                            #endif
+                                chan,
+                            #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 8, 0)
+                                channel_type,
+                            #endif
+                                duration, cookie, false);
+}
+
 /**
  * @cancel_remain_on_channel: Cancel an on-going remain-on-channel operation.
  *	This allows the operation to be terminated prior to timeout based on
@@ -5352,6 +4262,10 @@ static int rwnx_cfg80211_cancel_remain_on_channel(struct wiphy *wiphy,
     return rwnx_send_cancel_roc(rwnx_hw);
 }
 
+#define IS_2P4GHZ(n) (n >= 2412 && n <= 2484)
+#define IS_5GHZ(n) (n >= 4000 && n <= 5895)
+#define DEFAULT_NOISE_FLOOR_2GHZ (-89)
+#define DEFAULT_NOISE_FLOOR_5GHZ (-92)
 /**
  * @dump_survey: get site survey information.
  */
@@ -5399,7 +4313,10 @@ static int rwnx_cfg80211_dump_survey(struct wiphy *wiphy, struct net_device *net
     if (rwnx_survey->filled != 0) {
         SURVEY_TIME(info) = (u64)rwnx_survey->chan_time_ms;
         SURVEY_TIME_BUSY(info) = (u64)rwnx_survey->chan_time_busy_ms;
-        info->noise = rwnx_survey->noise_dbm;
+        //info->noise = rwnx_survey->noise_dbm;
+	info->noise = ((IS_2P4GHZ(info->channel->center_freq)) ? DEFAULT_NOISE_FLOOR_2GHZ :
+			(IS_5GHZ(info->channel->center_freq)) ? DEFAULT_NOISE_FLOOR_5GHZ : DEFAULT_NOISE_FLOOR_5GHZ);
+
 
         // Set the survey report as not used
         if(info->noise == 0){
@@ -5420,11 +4337,11 @@ static int rwnx_cfg80211_dump_survey(struct wiphy *wiphy, struct net_device *net
  */
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0))
 static int rwnx_cfg80211_get_channel(struct wiphy *wiphy,
-                                                                         struct wireless_dev *wdev,
+                                                    struct wireless_dev *wdev,
 #if LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION
-                                                                         unsigned int link_id,
+                                                    unsigned int link_id,
 #endif
-                                                                         struct cfg80211_chan_def *chandef)
+                                                    struct cfg80211_chan_def *chandef)
 {
     struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
     struct rwnx_vif *rwnx_vif = container_of(wdev, struct rwnx_vif, wdev);
@@ -5532,7 +4449,6 @@ static int rwnx_cfg80211_mgmt_tx(struct wiphy *wiphy, struct wireless_dev *wdev,
             break;
     }
 
-
     /* Get STA on which management frame has to be sent */
     rwnx_sta = rwnx_retrieve_sta(rwnx_hw, rwnx_vif, mgmt->da,
                                  mgmt->frame_control, ap);
@@ -5581,14 +4497,14 @@ static int rwnx_cfg80211_mgmt_tx(struct wiphy *wiphy, struct wireless_dev *wdev,
 
         /* Start a ROC procedure for 30ms */
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0))
-        error = rwnx_cfg80211_remain_on_channel(wiphy, wdev, channel,
-                                                30, &cookie);
+        error = rwnx_cfg80211_remain_on_channel_(wiphy, wdev, channel,
+                                                30, &cookie, true);
 #elif (LINUX_VERSION_CODE < KERNEL_VERSION(3, 8, 0)) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0))
-        error = rwnx_cfg80211_remain_on_channel(wiphy, wdev, channel, NL80211_CHAN_NO_HT,
-                                                30, &cookie);
+        error = rwnx_cfg80211_remain_on_channel_(wiphy, wdev, channel, NL80211_CHAN_NO_HT,
+                                                30, &cookie, true);
 #else
-        error = rwnx_cfg80211_remain_on_channel(wiphy, dev, channel, NL80211_CHAN_NO_HT,
-                                                30, &cookie);
+        error = rwnx_cfg80211_remain_on_channel_(wiphy, dev, channel, NL80211_CHAN_NO_HT,
+                                                30, &cookie, true);
 #endif
 
         if (error) {
@@ -5597,7 +4513,7 @@ static int rwnx_cfg80211_mgmt_tx(struct wiphy *wiphy, struct wireless_dev *wdev,
         }
         /* Need to keep in mind that RoC has been launched internally in order to
          * avoid to call the cfg80211 callback once expired */
-        rwnx_hw->roc_elem->mgmt_roc = true;
+        //rwnx_hw->roc_elem->mgmt_roc = true;
     }
 
     #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0))
@@ -5771,9 +4687,10 @@ int rwnx_cfg80211_channel_switch(struct wiphy *wiphy,
         goto end;
     } else {
         INIT_WORK(&csa->work, rwnx_csa_finish);
-
-#if LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION
-        cfg80211_ch_switch_started_notify(dev, &csa->chandef, 0, params->count, false, 0);
+#if LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION4
+		cfg80211_ch_switch_started_notify(dev, &csa->chandef, 0, params->count, false, 0);
+#elif LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION2
+        cfg80211_ch_switch_started_notify(dev, &csa->chandef, 0, params->count, false);
 #elif LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)
         cfg80211_ch_switch_started_notify(dev, &csa->chandef, params->count, params->block_tx);
 #else
@@ -6054,8 +4971,12 @@ static int rwnx_fill_station_info(struct rwnx_sta *sta, struct rwnx_vif *vif,
 	rate_info = (union rwnx_rate_ctrl_info *)&cfm.rate_info;
 
 
-	AICWFDBG(LOGDEBUG, "%s ModTx:%d TxIndex:%d ModRx:%d RxHTIndex:%d RxVHTIndex:%d RxHEIndex:%d RSSI:%d \r\n", __func__,
-		rate_info->formatModTx, rate_info->mcsIndexTx, rx_vect1->format_mod,
+	AICWFDBG(LOGDEBUG, "%s ModTx(%d):%d TxIndex:%d ModRx(%d):%d RxHTIndex:%d RxVHTIndex:%d RxHEIndex:%d RSSI:%d \r\n", __func__,
+		rate_info->bwTx,
+		rate_info->formatModTx,
+		rate_info->mcsIndexTx,
+		rx_vect1->ch_bw,
+		rx_vect1->format_mod,
 		rx_vect1->ht.mcs,
 		rx_vect1->vht.mcs,
 		rx_vect1->he.mcs,
@@ -6090,7 +5011,11 @@ static int rwnx_fill_station_info(struct rwnx_sta *sta, struct rwnx_vif *vif,
 	case FORMATMOD_HE_SU:
 	case FORMATMOD_HE_ER:
 		sinfo->txrate.flags = RATE_INFO_FLAGS_VHT_MCS;
-		sinfo->txrate.mcs = rate_info->mcsIndexTx;
+        if(rate_info->mcsIndexTx > 9){
+            sinfo->txrate.mcs = 9;
+        }else{
+		    sinfo->txrate.mcs = rate_info->mcsIndexTx;
+        }
 		break;
 #endif
 	default:
@@ -6160,7 +5085,7 @@ static int rwnx_fill_station_info(struct rwnx_sta *sta, struct rwnx_vif *vif,
 	case FORMATMOD_NON_HT:
 	case FORMATMOD_NON_HT_DUP_OFDM:
 		sinfo->rxrate.flags = 0;
-		sinfo->rxrate.legacy = legrates_lut_rate[legrates_lut[rx_vect1->leg_rate]];
+		sinfo->rxrate.legacy = legrates_lut[rx_vect1->leg_rate].rate;
 		break;
 	case FORMATMOD_HT_MF:
 	case FORMATMOD_HT_GF:
@@ -6191,7 +5116,11 @@ static int rwnx_fill_station_info(struct rwnx_sta *sta, struct rwnx_vif *vif,
 	case FORMATMOD_HE_SU:
 	case FORMATMOD_HE_ER:
 		sinfo->rxrate.flags = RATE_INFO_FLAGS_VHT_MCS;
-		sinfo->rxrate.mcs = rx_vect1->he.mcs;
+        if(rx_vect1->he.mcs > 9){
+            sinfo->rxrate.mcs = 9;
+        }else{
+            sinfo->rxrate.mcs = rx_vect1->he.mcs;
+        }
 		break;
 #endif
 	default:
@@ -6769,7 +5698,7 @@ static struct cfg80211_ops rwnx_cfg80211_ops = {
     .start_radar_detection = rwnx_cfg80211_start_radar_detection,
     .update_ft_ies = rwnx_cfg80211_update_ft_ies,
     .set_cqm_rssi_config = rwnx_cfg80211_set_cqm_rssi_config,
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 16, 0)
     .channel_switch = rwnx_cfg80211_channel_switch,
 #endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)
@@ -6830,12 +5759,14 @@ static void rwnx_reg_notifier(struct wiphy *wiphy,
     // For now trust all initiator
     rwnx_radar_set_domain(&rwnx_hw->radar, request->dfs_region);
 
-	if (rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8801 ||
-		((rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DC ||
-		 rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW ||
-		 rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81) && testmode == 0)){
-    		rwnx_send_me_chan_config_req(rwnx_hw);
-		}
+    if (rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8801 ||
+       ((rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DC ||
+        rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW ||
+        rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81 ||
+        rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81X2 ||
+        rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D89X2) && testmode == 0)){
+            rwnx_send_me_chan_config_req(rwnx_hw);
+    }
 }
 
 static void rwnx_enable_mesh(struct rwnx_hw *rwnx_hw)
@@ -8981,6 +7912,15 @@ int rwnx_ic_system_init(struct rwnx_hw *rwnx_hw){
 #endif
 	}else if(rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81){
 		rwnx_plat_userconfig_load_8800d80(rwnx_hw);
+        #ifdef CONFIG_POWER_LIMIT
+        rwnx_plat_powerlimit_load_8800d80(rwnx_hw);
+        #endif
+	}else if(rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81X2 ||
+		rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D89X2){
+		rwnx_plat_userconfig_load_8800d80x2(rwnx_hw);
+        #ifdef CONFIG_POWER_LIMIT
+        rwnx_plat_powerlimit_load_8800d80x2(rwnx_hw);
+        #endif
 	}
 
 	return 0;
@@ -9016,15 +7956,37 @@ int rwnx_ic_rf_init(struct rwnx_hw *rwnx_hw){
 	}else if(rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81){
 		if ((ret = aicwf_set_rf_config_8800d80(rwnx_hw, &cfm)))
 			return -1;
+	}else if(rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81X2 ||
+			rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D89X2){
+		if ((ret = aicwf_set_rf_config_8800d80x2(rwnx_hw, &cfm)))
+			return -1;
 	}
 #ifdef CONFIG_5M10M
-	rwnx_send_vendor_hwconfig_req(rwnx_hw, hwconfig_id, param);
+	rwnx_send_vendor_hwconfig_req(rwnx_hw, hwconfig_id, param, NULL);
 #endif
 	return 0;
 }
+void aic_ipc_setting(struct rwnx_vif *rwnx_vif){
+    struct rwnx_hw *rwnx_hw = rwnx_vif->rwnx_hw;
+	uint32_t hw_edca = 1;
+	uint32_t hw_cca = 3;
+	int32_t param[13];
+	int32_t cca[5]= {0x10, 0, 0, 0, 0};
+
+	param[0] = 0; param[1] = 0x5e222; param[2] = 0; param[3] = 0;
+	param[4] = rwnx_vif->vif_index;
+	param[5] = 0x1e; param[6] = 0; param[7] = 0; param[8] =0;param[9] = 0x5;param[10] = 0x5;param[11] = 0x5;param[12] = 0;
+	rwnx_send_vendor_hwconfig_req(rwnx_hw, hw_edca, param, NULL);
+	rwnx_send_vendor_hwconfig_req(rwnx_hw, hw_cca, cca, NULL);
+}
+
 
 extern void *aicwf_prealloc_txq_alloc(size_t size);
 extern int aicwf_vendor_init(struct wiphy *wiphy);
+#ifdef CONFIG_POWER_LIMIT
+extern char default_ccode[];
+extern char country_code[];
+#endif
 int rwnx_cfg80211_init(struct rwnx_plat *rwnx_plat, void **platform_data)
 {
     struct rwnx_hw *rwnx_hw;
@@ -9040,6 +8002,9 @@ int rwnx_cfg80211_init(struct rwnx_plat *rwnx_plat, void **platform_data)
     struct aic_feature_t feature;
 #endif
     struct mm_set_stack_start_cfm set_start_cfm;
+#ifdef CONFIG_TEMP_COMP
+	struct mm_set_vendor_swconfig_cfm swconfig_cfm;
+#endif
 
     int nx_remote_sta_max = NX_REMOTE_STA_MAX;
 
@@ -9058,6 +8023,9 @@ if((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8801) ||
     get_random_bytes(&dflt_mac[4], 2);
 #endif
 //#endif
+#ifdef CONFIG_POWER_LIMIT
+    memcpy(country_code, default_ccode, 4);
+#endif
     /* create a new wiphy for use with cfg80211 */
     AICWFDBG(LOGINFO, "%s sizeof(struct rwnx_hw):%d \r\n", __func__, (int)sizeof(struct rwnx_hw));
     wiphy = wiphy_new(&rwnx_cfg80211_ops, sizeof(struct rwnx_hw));
@@ -9084,11 +8052,13 @@ if((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8801) ||
 #endif
     rwnx_hw->mod_params = &rwnx_mod_params;
     rwnx_hw->tcp_pacing_shift = 7;
-    
+
 #ifdef CONFIG_SCHED_SCAN
     rwnx_hw->is_sched_scan = false;
 #endif//CONFIG_SCHED_SCAN
 
+    aicwf_wakeup_lock_init(rwnx_hw);
+
     rwnx_init_aic(rwnx_hw);
     /* set device pointer for wiphy */
     set_wiphy_dev(wiphy, rwnx_hw->dev);
@@ -9101,6 +8071,12 @@ if((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8801) ||
         goto err_cache;
     }
 
+
+#ifdef CONFIG_FILTER_TCP_ACK
+     AICWFDBG(LOGINFO, "%s: FILTER_TCP_ACK\n", __func__);
+    tcp_ack_init(rwnx_hw);
+#endif
+
 #if 0
     if ((ret = rwnx_parse_configfile(rwnx_hw, RWNX_CONFIG_FW_NAME, &init_conf))) {
         wiphy_err(wiphy, "rwnx_parse_configfile failed\n");
@@ -9157,6 +8133,8 @@ if((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8801) ||
 #else
     rwnx_hw->fwlog_en = false;
 #endif
+    rwnx_hw->scanning = false;
+    rwnx_hw->p2p_working = false;
 	//init ic system
 	if((ret = rwnx_ic_system_init(rwnx_hw))){
 		goto err_lmac_reqs;
@@ -9170,7 +8148,9 @@ if((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8801) ||
 	    ret = rwnx_send_set_stack_start_req(rwnx_hw, 1, 0, CO_BIT(5), rwnx_hw->fwlog_en, &set_start_cfm);
 	}
 #else
-    if(rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81){
+    if(rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81 ||
+        rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81X2 ||
+        rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D89X2){
         ret = rwnx_send_set_stack_start_req(rwnx_hw, 1, 0, CO_BIT(5), rwnx_hw->fwlog_en, &set_start_cfm);
     } else {
 	ret = rwnx_send_set_stack_start_req(rwnx_hw, 1, get_hardware_info(), feature.hwinfo, rwnx_hw->fwlog_en, &set_start_cfm);
@@ -9303,6 +8283,10 @@ if((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8801) ||
     if ((ret = rwnx_send_reset(rwnx_hw)))
         goto err_lmac_reqs;
 
+#ifdef CONFIG_TEMP_COMP
+	rwnx_send_set_temp_comp_req(rwnx_hw, &swconfig_cfm);
+#endif
+
     if ((ret = rwnx_send_version_req(rwnx_hw, &rwnx_hw->version_cfm)))
         goto err_lmac_reqs;
     rwnx_set_vers(rwnx_hw);
@@ -9318,7 +8302,9 @@ if((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8801) ||
 	if (rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8801 ||
 		((rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DC ||
 		rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW ||
-		rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81) && testmode == 0)) {
+		rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81 ||
+		rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81X2 ||
+		rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D89X2) && testmode == 0)) {
     	rwnx_send_me_config_req(rwnx_hw);
 	}
 
@@ -9341,7 +8327,9 @@ if((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8801) ||
 	if (rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8801 ||
 		((rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DC ||
 		rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW ||
-		rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81) && testmode == 0)) {
+		rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81 ||
+		rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81X2 ||
+		rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D89X2) && testmode == 0)) {
     	rwnx_send_me_chan_config_req(rwnx_hw);
 		#ifdef CONFIG_COEX
     	rwnx_send_coex_req(rwnx_hw, 0, 1);
@@ -9361,7 +8349,6 @@ if((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8801) ||
     vif = rwnx_interface_add(rwnx_hw, "wlan%d", NET_NAME_UNKNOWN,
                                 NL80211_IFTYPE_STATION, NULL);
 
-
     #ifdef CONFIG_RWNX_MON_DATA
     /* Add an initial station interface */
     vif = rwnx_interface_add(rwnx_hw, "wlan%d", 1,
@@ -9411,6 +8398,9 @@ if((g_rwnx_plat->usbdev->chipid == PRODUCT_ID_AIC8801) ||
         rwnx_hw->is_p2p_connected = 0;
         atomic_set(&rwnx_hw->p2p_alive_timer_count, 0);
 #endif
+#ifdef CONFIG_FOR_IPCAM
+		aic_ipc_setting(vif);
+#endif
 
     return 0;
 
@@ -9424,13 +8414,16 @@ if(rwnx_hw->wiphy){
 }
 err_register_wiphy:
 err_lmac_reqs:
-	AICWFDBG(LOGERROR, "err_lmac_reqs\n");
+    AICWFDBG(LOGERROR, "err_lmac_reqs\n");
+    flush_workqueue(rwnx_hw->apmStaloss_wq);
+    destroy_workqueue(rwnx_hw->apmStaloss_wq);
     //rwnx_fw_trace_dump(rwnx_hw);
     rwnx_platform_off(rwnx_hw, NULL);
+    kmem_cache_destroy(rwnx_hw->sw_txhdr_cache);
 //err_platon:
 //err_config:
-    kmem_cache_destroy(rwnx_hw->sw_txhdr_cache);
 err_cache:
+    aicwf_wakeup_lock_deinit(rwnx_hw);
     wiphy_free(wiphy);
 err_out:
     return ret;
@@ -9449,6 +8442,8 @@ void rwnx_cfg80211_deinit(struct rwnx_hw *rwnx_hw)
     rwnx_send_set_stack_start_req(rwnx_hw, 0, 0, 0, 0, &set_start_cfm);
 
     rwnx_hw->fwlog_en = 0;
+    rwnx_hw->scanning = 0;
+    rwnx_hw->p2p_working = 0;
 
 #ifdef CONFIG_DEBUG_FS
     rwnx_dbgfs_unregister(rwnx_hw);
@@ -9464,6 +8459,11 @@ void rwnx_cfg80211_deinit(struct rwnx_hw *rwnx_hw)
     rwnx_radar_detection_deinit(&rwnx_hw->radar);
     rwnx_platform_off(rwnx_hw, NULL);
     kmem_cache_destroy(rwnx_hw->sw_txhdr_cache);
+#ifdef CONFIG_FILTER_TCP_ACK
+    tcp_ack_deinit(rwnx_hw);
+#endif
+    aicwf_wakeup_lock_deinit(rwnx_hw);
+
 	if(rwnx_hw->wiphy){
     	wiphy_free(rwnx_hw->wiphy);
 	}
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.h
index 0728b4f77a62..7d06691ddf74 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.h
@@ -13,20 +13,6 @@
 
 #include "rwnx_defs.h"
 
-typedef struct _android_wifi_priv_cmd {
-    char *buf;
-    int used_len;
-    int total_len;
-} android_wifi_priv_cmd;
-
-#ifdef CONFIG_COMPAT
-typedef struct _compat_android_wifi_priv_cmd {
-    compat_caddr_t buf;
-    int used_len;
-    int total_len;
-} compat_android_wifi_priv_cmd;
-#endif /* CONFIG_COMPAT */
-
 int rwnx_cfg80211_init(struct rwnx_plat *rwnx_plat, void **platform_data);
 void rwnx_cfg80211_deinit(struct rwnx_hw *rwnx_hw);
 extern int testmode;
@@ -34,5 +20,7 @@ extern u8 chip_id;
 extern u8 chip_sub_id;
 extern u8 chip_mcu_id;
 
+#define CHIP_ID_H_MASK  0xC0
+#define IS_CHIP_ID_H()  ((chip_id & CHIP_ID_H_MASK) == CHIP_ID_H_MASK)
 
 #endif /* _RWNX_MAIN_H_ */
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mod_params.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mod_params.c
index 803341419a55..39afb8d4ef4a 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mod_params.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mod_params.c
@@ -363,9 +363,6 @@ struct ieee80211_regdomain *getRegdomainFromRwnxDB(struct wiphy *wiphy,
 			return reg_regdb[idx];
 		}
 		idx++;
-		if(idx == reg_regdb_size){
-			break;
-		}
 	}
 
 	AICWFDBG(LOGERROR, "%s(): Error, wrong country = %s\n",
@@ -906,6 +903,8 @@ static void rwnx_set_vht_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 #endif
 	        rwnx_hw->vht_cap_5G.cap &= ~IEEE80211_VHT_CAP_SHORT_GI_80;
 	    }
+
+		rwnx_hw->vht_cap_5G.cap |= IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK;
 	}
 #endif
 	return;
@@ -1193,6 +1192,11 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
                         IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_IN_2G;
         he_cap->ppe_thres[0] |= 0x10;
     }
+    if (rwnx_hw->mod_params->use_80) {
+        he_cap->ppe_thres[0] |= 0x20;
+        he_cap->ppe_thres[2] |= 0xc0;
+        he_cap->ppe_thres[3] |= 0x07;
+    }
     //if (rwnx_hw->mod_params->use_80)
     {
         he_cap->he_cap_elem.phy_cap_info[0] |=
@@ -1318,6 +1322,11 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
                         IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_IN_2G;
         he_cap->ppe_thres[0] |= 0x10;
     }
+    if (rwnx_hw->mod_params->use_80) {
+        he_cap->ppe_thres[0] |= 0x20;
+        he_cap->ppe_thres[2] |= 0xc0;
+        he_cap->ppe_thres[3] |= 0x07;
+    }
     //if (rwnx_hw->mod_params->use_80)
     {
         he_cap->he_cap_elem.phy_cap_info[0] |=
@@ -1382,7 +1391,11 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
     he_cap->he_cap_elem.phy_cap_info[9] |= IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_COMP_SIGB |
                                            IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_NON_COMP_SIGB;
     #endif
-    mcs_map = rwnx_hw->mod_params->he_mcs_map;
+	if (rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8801 || rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DC ||
+        rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW)
+        mcs_map = min_t(int, rwnx_hw->mod_params->he_mcs_map, IEEE80211_HE_MCS_SUPPORT_0_9);
+	else
+		mcs_map = rwnx_hw->mod_params->he_mcs_map;
     //mcs_map = min_t(int, rwnx_hw->mod_params->he_mcs_map, IEEE80211_HE_MCS_SUPPORT_0_9);
     memset(&he_cap->he_mcs_nss_supp, 0, sizeof(he_cap->he_mcs_nss_supp));
     for (i = 0; i < nss; i++) {
@@ -1424,6 +1437,11 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 	                        IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_IN_2G;
 	        he_cap->ppe_thres[0] |= 0x10;
 	    }
+	    if (rwnx_hw->mod_params->use_80) {
+		he_cap->ppe_thres[0] |= 0x20;
+		he_cap->ppe_thres[2] |= 0xc0;
+		he_cap->ppe_thres[3] |= 0x07;
+	    }
 	    //if (rwnx_hw->mod_params->use_80)
 	    {
 	        he_cap->he_cap_elem.phy_cap_info[0] |=
@@ -1487,7 +1505,11 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 	    he_cap->he_cap_elem.phy_cap_info[9] |= IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_COMP_SIGB |
 	                                           IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_NON_COMP_SIGB;
 	    #endif
-	    mcs_map = rwnx_hw->mod_params->he_mcs_map;
+		if (rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8801 || rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DC ||
+			rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW)
+			mcs_map = min_t(int, rwnx_hw->mod_params->he_mcs_map, IEEE80211_HE_MCS_SUPPORT_0_9);
+		else
+			mcs_map = rwnx_hw->mod_params->he_mcs_map;
 	    //mcs_map = min_t(int, rwnx_hw->mod_params->he_mcs_map, IEEE80211_HE_MCS_SUPPORT_0_9);
 	    memset(&he_cap->he_mcs_nss_supp, 0, sizeof(he_cap->he_mcs_nss_supp));
 	    for (i = 0; i < nss; i++) {
@@ -1683,19 +1705,25 @@ int rwnx_handle_dynparams(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 #endif
 
     //check he_mcs max
-    if(rwnx_hw->usbdev->chipid != PRODUCT_ID_AIC8800D81 && 
+    if(rwnx_hw->usbdev->chipid != PRODUCT_ID_AIC8800D81 &&
+        rwnx_hw->usbdev->chipid != PRODUCT_ID_AIC8800D81X2 &&
+        rwnx_hw->usbdev->chipid != PRODUCT_ID_AIC8800D89X2 &&
         rwnx_hw->mod_params->he_mcs_map > IEEE80211_HE_MCS_SUPPORT_0_9){
         rwnx_hw->mod_params->he_mcs_map = IEEE80211_HE_MCS_SUPPORT_0_9;
     }
 
     //check use_80 support
     if(rwnx_hw->usbdev->chipid != PRODUCT_ID_AIC8800D81 &&
+        rwnx_hw->usbdev->chipid != PRODUCT_ID_AIC8800D81X2 &&
+        rwnx_hw->usbdev->chipid != PRODUCT_ID_AIC8800D89X2 &&
         rwnx_hw->mod_params->use_80 == true){
         rwnx_hw->mod_params->use_80 = false;
     }
 
     //check sgi80 support
     if(rwnx_hw->usbdev->chipid != PRODUCT_ID_AIC8800D81 &&
+        rwnx_hw->usbdev->chipid != PRODUCT_ID_AIC8800D81X2 &&
+        rwnx_hw->usbdev->chipid != PRODUCT_ID_AIC8800D89X2 &&
         rwnx_hw->mod_params->sgi80 == true){
         rwnx_hw->mod_params->sgi80 = false;
     }
@@ -1729,6 +1757,7 @@ void rwnx_custregd(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 // registration (in rwnx_set_wiphy_params()), so nothing has to be done here
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 0, 0)
+    wiphy->regulatory_flags |= REGULATORY_IGNORE_STALE_KICKOFF;
     wiphy->regulatory_flags |= REGULATORY_WIPHY_SELF_MANAGED;
 
     if (!rwnx_hw->mod_params->custregd)
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_rx.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_rx.c
index 4740022e3261..5fc29d2192fc 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_rx.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_rx.c
@@ -28,6 +28,7 @@
 #ifdef CONFIG_USE_WIRELESS_EXT
 #include "aicwf_wext_linux.h"
 #endif
+void rwnx_cfg80211_unlink_bss(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_vif);
 
 static int rwnx_freq_to_idx(struct rwnx_hw *rwnx_hw, int freq)
 {
@@ -115,25 +116,28 @@ static inline int rwnx_rx_chan_switch_ind(struct rwnx_hw *rwnx_hw,
     } else {
         /* Retrieve the allocated RoC element */
         struct rwnx_roc_elem *roc_elem = rwnx_hw->roc_elem;
+        if (roc_elem) {
+            /* If mgmt_roc is true, remain on channel has been started by ourself */
+            if (!roc_elem->mgmt_roc) {
+                /* Inform the host that we have switch on the indicated off-channel */
+                #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 0)
+                cfg80211_ready_on_channel(roc_elem->wdev->netdev, (u64)(rwnx_hw->roc_cookie_cnt),
+                                        roc_elem->chan, NL80211_CHAN_HT20, roc_elem->duration, GFP_ATOMIC);
+                #elif LINUX_VERSION_CODE < KERNEL_VERSION(3, 8, 0)
+                cfg80211_ready_on_channel(roc_elem->wdev, (u64)(rwnx_hw->roc_cookie_cnt),
+                                        roc_elem->chan, NL80211_CHAN_HT20, roc_elem->duration, GFP_ATOMIC);
+                #else
+                cfg80211_ready_on_channel(roc_elem->wdev, (u64)(rwnx_hw->roc_cookie_cnt),
+                                        roc_elem->chan, roc_elem->duration, GFP_ATOMIC);
+                #endif
+            }
 
-        /* If mgmt_roc is true, remain on channel has been started by ourself */
-        if (!roc_elem->mgmt_roc) {
-            /* Inform the host that we have switch on the indicated off-channel */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 0)
-	    cfg80211_ready_on_channel(roc_elem->wdev->netdev, (u64)(rwnx_hw->roc_cookie_cnt),
-                                      roc_elem->chan, NL80211_CHAN_HT20, roc_elem->duration, GFP_ATOMIC);
-#elif LINUX_VERSION_CODE < KERNEL_VERSION(3, 8, 0)
-	    cfg80211_ready_on_channel(roc_elem->wdev, (u64)(rwnx_hw->roc_cookie_cnt),
-                                      roc_elem->chan, NL80211_CHAN_HT20, roc_elem->duration, GFP_ATOMIC);
-#else
-            cfg80211_ready_on_channel(roc_elem->wdev, (u64)(rwnx_hw->roc_cookie_cnt),
-                                      roc_elem->chan, roc_elem->duration, GFP_ATOMIC);
-#endif
+            /* Keep in mind that we have switched on the channel */
+            roc_elem->on_chan = true;
+        } else {
+            printk("roc_elem == null\n");
         }
 
-        /* Keep in mind that we have switched on the channel */
-        roc_elem->on_chan = true;
-
         // Enable traffic on OFF channel queue
         rwnx_txq_offchan_start(rwnx_hw);
     }
@@ -295,7 +299,9 @@ static inline int rwnx_rx_p2p_vif_ps_change_ind(struct rwnx_hw *rwnx_hw,
     if (ps_state == MM_PS_MODE_OFF) {
         // Start TX queues for provided VIF
         rwnx_txq_vif_start(vif_entry, RWNX_TXQ_STOP_VIF_PS, rwnx_hw);
-    }
+		tasklet_schedule(&rwnx_hw->task);
+	}   
+        
     else {
         // Stop TX queues for provided VIF
         rwnx_txq_vif_stop(vif_entry, RWNX_TXQ_STOP_VIF_PS, rwnx_hw);
@@ -600,7 +606,6 @@ static inline int rwnx_rx_scan_done_ind(struct rwnx_hw *rwnx_hw,
  * Messages from SCANU task
  **************************************************************************/
 #ifdef CONFIG_RWNX_FULLMAC
-extern uint8_t scanning;
 static inline int rwnx_rx_scanu_start_cfm(struct rwnx_hw *rwnx_hw,
                                           struct rwnx_cmd *cmd,
                                           struct ipc_e2a_msg *msg)
@@ -663,7 +668,7 @@ static inline int rwnx_rx_scanu_start_cfm(struct rwnx_hw *rwnx_hw,
 #endif//CONFIG_SCHED_SCAN
 
     rwnx_hw->scan_request = NULL;
-    scanning = 0;
+    rwnx_hw->scanning = 0;
 
     return 0;
 }
@@ -710,7 +715,7 @@ static inline int rwnx_rx_scanu_result_ind(struct rwnx_hw *rwnx_hw,
                                         ind->length, ind->rssi * 100, GFP_ATOMIC);
 #if 0
         //print scan result info start
-        if(ie != NULL){
+        if(ie != NULL && bss != NULL){
             ssid_len = ie[1];
             ssid = (char *)vmalloc(sizeof(char)* (ssid_len + 1));
             if(ssid != NULL){
@@ -846,15 +851,18 @@ static inline int rwnx_rx_sm_connect_ind(struct rwnx_hw *rwnx_hw,
     const u8 *extcap_ie;
     const struct ieee_types_extcap *extcap;
     struct ieee80211_channel *chan;
+	struct cfg80211_bss *bss = NULL;
+    struct wireless_dev *wdev = NULL;
+    int retry_counter = 10;
 
     RWNX_DBG(RWNX_FN_ENTRY_STR);
-
+	
 	if(!rwnx_vif){
 		AICWFDBG(LOGERROR, "%s rwnx_vif is null \r\n", __func__);
 		return 0;
 	}
 	dev = rwnx_vif->ndev;
-
+    wdev = dev->ieee80211_ptr;
 
     /* Retrieve IE addresses and lengths */
     req_ie = (const u8 *)ind->assoc_ie_buf;
@@ -962,61 +970,156 @@ static inline int rwnx_rx_sm_connect_ind(struct rwnx_hw *rwnx_hw,
             rwnx_chanctx_link(rwnx_mon_vif, ind->ch_idx, NULL);
         }
 #endif
-		atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_CONNECTED);
+		//atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_CONNECTED);
 
     } else if (ind->status_code == WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG) {
         if (rwnx_vif->wep_enabled) {
             rwnx_vif->wep_auth_err = true;
-            printk("con ind wep_auth_err %d\n", rwnx_vif->wep_auth_err);
+            AICWFDBG(LOGINFO, "con ind wep_auth_err %d\n", rwnx_vif->wep_auth_err);
         }
 		atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
     }else{
 		atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
 	}
 
-    if (!ind->roamed) {
+
+    AICWFDBG(LOGINFO, "%s ind->roamed:%d ind->status_code:%d rwnx_vif->drv_conn_state:%d\r\n", 
+        __func__, 
+        ind->roamed, 
+        ind->status_code,
+        (int)atomic_read(&rwnx_vif->drv_conn_state));
+
+	do {
+		bss = cfg80211_get_bss(wdev->wiphy, NULL, rwnx_vif->sta.bssid,
+#if LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION
+							wdev->u.client.ssid, wdev->u.client.ssid_len,
+#else
+							wdev->ssid, wdev->ssid_len,
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0)
+							wdev->conn_bss_type,
+							IEEE80211_PRIVACY_ANY);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0)
+							IEEE80211_BSS_TYPE_ESS,
+							IEEE80211_PRIVACY_ANY);
+#else
+                            WLAN_CAPABILITY_ESS,
+                            WLAN_CAPABILITY_PRIVACY);
+#endif
+
+
+		if (!bss) {
+			printk("%s bss is NULL \r\n", __func__);
+
+			printk("%s bss ssid(%d):%s conn_bss_type:%d bss2 ssid(%d):%s conn_bss_type:%d\r\n", 
+				__func__, 
+				(int)rwnx_vif->sta.ssid_len,
+				rwnx_vif->sta.ssid,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0)
+				IEEE80211_BSS_TYPE_ESS,
+#else
+				WLAN_CAPABILITY_ESS,
+#endif
+#if LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION
+				(int)wdev->u.client.ssid_len,
+				wdev->u.client.ssid, 
+#else
+				(int)wdev->ssid_len,
+				wdev->ssid,
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0)
+				wdev->conn_bss_type
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0)
+				IEEE80211_BSS_TYPE_ESS
+#else
+				WLAN_CAPABILITY_ESS
+#endif
+				);
+
+			printk("%s rwnx_vif->sta.bssid %02x %02x %02x %02x %02x %02x \r\n", __func__, 
+				rwnx_vif->sta.bssid[0], rwnx_vif->sta.bssid[1], rwnx_vif->sta.bssid[2],
+				rwnx_vif->sta.bssid[3], rwnx_vif->sta.bssid[4], rwnx_vif->sta.bssid[5]);
+
+#if LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION
+			wdev->u.client.ssid_len = (int)rwnx_vif->sta.ssid_len;
+			memcpy(wdev->u.client.ssid, rwnx_vif->sta.ssid, wdev->u.client.ssid_len);
+#else
+			wdev->ssid_len = (int)rwnx_vif->sta.ssid_len;
+			memcpy(wdev->ssid, rwnx_vif->sta.ssid, wdev->ssid_len);
+#endif
+			msleep(100);
+			retry_counter--;
+			if(retry_counter == 0){
+				printk("%s bss recover fail \r\n", __func__);
+				break;
+			}
+		}
+	} while (!bss);
+
+    if (!ind->roamed) {//not roaming
         cfg80211_connect_result(dev, (const u8 *)ind->bssid.array, req_ie,
                                 ind->assoc_req_ie_len, rsp_ie,
                                 ind->assoc_rsp_ie_len, ind->status_code,
                                 GFP_ATOMIC);
+		if (ind->status_code == 0) {
+			atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_CONNECTED);
+		} else {
+			atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
+			rwnx_external_auth_disable(rwnx_vif);
+		}
+		AICWFDBG(LOGINFO, "%s cfg80211_connect_result pass, rwnx_vif->drv_conn_state:%d\r\n", __func__, (int)atomic_read(&rwnx_vif->drv_conn_state));
     }
-    else {
+    else {//roaming
+        if(ind->status_code != 0){
+            AICWFDBG(LOGINFO, "%s roaming fail to notify disconnect \r\n", __func__);
+			cfg80211_disconnected(dev, 0, NULL, 0,1, GFP_ATOMIC);
+			atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
+			rwnx_external_auth_disable(rwnx_vif);
+        }else{
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)
-        struct cfg80211_roam_info info;
-        memset(&info, 0, sizeof(info));
-        if (rwnx_vif->ch_index < NX_CHAN_CTXT_CNT)
+            struct cfg80211_roam_info info;
+            memset(&info, 0, sizeof(info));
+            
 #if LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
-			info.channel = rwnx_hw->chanctx_table[rwnx_vif->ch_index].chan_def.chan;
+			if (rwnx_vif->ch_index < NX_CHAN_CTXT_CNT)
+    			info.channel = rwnx_hw->chanctx_table[rwnx_vif->ch_index].chan_def.chan;
+			info.bssid = (const u8 *)ind->bssid.array;
+
 #else
-			info.links[0].channel = rwnx_hw->chanctx_table[rwnx_vif->ch_index].chan_def.chan;
+			if (rwnx_vif->ch_index < NX_CHAN_CTXT_CNT)
+    			info.links[0].channel = rwnx_hw->chanctx_table[rwnx_vif->ch_index].chan_def.chan;
+			info.links[0].bssid = (const u8 *)ind->bssid.array;;
 #endif//LINUX_VERSION_CODE < HIGH_KERNEL_VERSION    
 
-#if LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
-        info.bssid = (const u8 *)ind->bssid.array;
-#else
-        info.links[0].bssid = (const u8 *)ind->bssid.array;;
-#endif//LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
-        info.req_ie = req_ie;
-        info.req_ie_len = ind->assoc_req_ie_len;
-        info.resp_ie = rsp_ie;
-        info.resp_ie_len = ind->assoc_rsp_ie_len;
-        cfg80211_roamed(dev, &info, GFP_ATOMIC);
+            info.req_ie = req_ie;
+            info.req_ie_len = ind->assoc_req_ie_len;
+            info.resp_ie = rsp_ie;
+            info.resp_ie_len = ind->assoc_rsp_ie_len;
+            AICWFDBG(LOGINFO, "%s roaming success to notify roam \r\n", __func__);
+            cfg80211_roamed(dev, &info, GFP_ATOMIC);
+			atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_CONNECTED);
 #else
-        chan = ieee80211_get_channel(rwnx_hw->wiphy, ind->center_freq);
-        cfg80211_roamed(dev
+            chan = ieee80211_get_channel(rwnx_hw->wiphy, ind->center_freq);
+            AICWFDBG(LOGINFO, "%s roaming success to notify roam \r\n", __func__);
+            cfg80211_roamed(dev
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 39) || defined(COMPAT_KERNEL_RELEASE)
-            , chan
+                , chan
 #endif
-            , (const u8 *)ind->bssid.array
-            , req_ie
-            , ind->assoc_req_ie_len
-            , rsp_ie
-            , ind->assoc_rsp_ie_len
-            , GFP_ATOMIC);
+                , (const u8 *)ind->bssid.array
+                , req_ie
+                , ind->assoc_req_ie_len
+                , rsp_ie
+                , ind->assoc_rsp_ie_len
+                , GFP_ATOMIC);
 #endif /*LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)*/
+			atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_CONNECTED);
+		}
     }
-    netif_tx_start_all_queues(dev);
-    netif_carrier_on(dev);
+
+	if (ind->status_code == 0) {
+	    netif_tx_start_all_queues(dev);
+	    netif_carrier_on(dev);
+	}
 
     return 0;
 }
@@ -1047,15 +1150,10 @@ void rwnx_cfg80211_unlink_bss(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_vif
 		cfg80211_put_bss(bss);
 #endif
 	}else{
-		AICWFDBG(LOGERROR, "%s(): cfg80211_unlink error %s!!\n", __func__, rwnx_vif->sta.ssid);
+		AICWFDBG(LOGINFO, "%s(): cfg80211_unlink error %s!!\n", __func__, rwnx_vif->sta.ssid);
 	}
-
-	memset(rwnx_vif->sta.ssid, 0, rwnx_vif->sta.ssid_len);
-	rwnx_vif->sta.ssid_len = 0;
-	memset(rwnx_vif->sta.bssid, 0, ETH_ALEN);
 }
 
-
 extern u8 dhcped;
 static inline int rwnx_rx_sm_disconnect_ind(struct rwnx_hw *rwnx_hw,
                                             struct rwnx_cmd *cmd,
@@ -1071,6 +1169,11 @@ static inline int rwnx_rx_sm_disconnect_ind(struct rwnx_hw *rwnx_hw,
 #endif
 
     RWNX_DBG(RWNX_FN_ENTRY_STR);
+	if((int)atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_DISCONNECTED){
+		AICWFDBG(LOGINFO, "%s, is already disconnected, drop disconnect ind", __func__);
+		return 0;
+	}
+
     dhcped = 0;
 
     if(!rwnx_vif){
@@ -1079,9 +1182,11 @@ static inline int rwnx_rx_sm_disconnect_ind(struct rwnx_hw *rwnx_hw,
         return 0;
     }
     dev = rwnx_vif->ndev;
-
-	rwnx_cfg80211_unlink_bss(rwnx_hw, rwnx_vif);
-
+	if (rwnx_vif->sta.is_roam == false) {
+		rwnx_cfg80211_unlink_bss(rwnx_hw, rwnx_vif);
+	} else {
+		AICWFDBG(LOGINFO, "%s roaming no rwnx_cfg80211_unlink_bss \r\n", __func__);
+	}
 
 #ifdef CONFIG_BR_SUPPORT
 	struct rwnx_vif *vif = netdev_priv(dev);
@@ -1095,7 +1200,7 @@ static inline int rwnx_rx_sm_disconnect_ind(struct rwnx_hw *rwnx_hw,
     if (rwnx_vif->up) {
         if (!ind->ft_over_ds && !ind->reassoc) {
             cfg80211_disconnected(dev, ind->reason_code, NULL, 0,
-                                  (ind->reason_code <= 1), GFP_ATOMIC);
+                                  (ind->reason_code < 1), GFP_ATOMIC);
         }
         netif_tx_stop_all_queues(dev);
         netif_carrier_off(dev);
@@ -1113,11 +1218,11 @@ static inline int rwnx_rx_sm_disconnect_ind(struct rwnx_hw *rwnx_hw,
     rx_priv = rwnx_hw->usbdev->rx_priv;
 #endif
     if((rwnx_vif->wdev.iftype == NL80211_IFTYPE_STATION) || (rwnx_vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT)) {
-        macaddr = rwnx_vif->ndev->dev_addr;
+        macaddr = (u8*)rwnx_vif->ndev->dev_addr;
 		AICWFDBG(LOGINFO, "deinit:macaddr:%x,%x,%x,%x,%x,%x\r\n", macaddr[0],macaddr[1],macaddr[2], \
                                macaddr[3],macaddr[4],macaddr[5]);
         list_for_each_entry_safe(reord_info, tmp, &rx_priv->stas_reord_list, list) {
-            macaddr = rwnx_vif->ndev->dev_addr;
+            macaddr = (u8*)rwnx_vif->ndev->dev_addr;
 			AICWFDBG(LOGINFO, "reord_mac:%x,%x,%x,%x,%x,%x\r\n", reord_info->mac_addr[0],reord_info->mac_addr[1],reord_info->mac_addr[2], \
                                    reord_info->mac_addr[3],reord_info->mac_addr[4],reord_info->mac_addr[5]);
             if (!memcmp(reord_info->mac_addr, macaddr, 6)) {
@@ -1155,6 +1260,9 @@ static inline int rwnx_rx_sm_external_auth_required_ind(struct rwnx_hw *rwnx_hw,
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 17, 0) || defined(CONFIG_WPA3_FOR_OLD_KERNEL)
     struct net_device *dev = rwnx_vif->ndev;
     struct cfg80211_external_auth_params params;
+	int ret = 0;
+	struct wireless_dev *wdev = dev->ieee80211_ptr;
+	int retry_counter = 10;
 
     RWNX_DBG(RWNX_FN_ENTRY_STR);
 
@@ -1165,11 +1273,28 @@ static inline int rwnx_rx_sm_external_auth_required_ind(struct rwnx_hw *rwnx_hw,
            min_t(size_t, ind->ssid.length, sizeof(params.ssid.ssid)));
     params.key_mgmt_suite = ind->akm;
 
+	while (wdev->conn_owner_nlportid == 0) {
+		AICWFDBG(LOGINFO, "%s WARNING conn_owner_nlportid = 0, msleep 100ms.\r\n", __func__);
+		msleep(100);
+		retry_counter--;
+		if (retry_counter == 0) {
+			break;
+		}
+	}
+	AICWFDBG(LOGINFO, "%s wdev->conn_owner_nlportid:%d \r\n", __func__, (int)wdev->conn_owner_nlportid);
+
+	if (wdev->conn_owner_nlportid != 0) {
+		rwnx_vif->sta.conn_owner_nlportid = wdev->conn_owner_nlportid;
+	} else {
+		AICWFDBG(LOGINFO, "%s try to recover conn_owner_nlportid\r\n", __func__);
+		wdev->conn_owner_nlportid = rwnx_vif->sta.conn_owner_nlportid;
+	}
+
     if ((ind->vif_idx > NX_VIRT_DEV_MAX) || !rwnx_vif->up ||
         (RWNX_VIF_TYPE(rwnx_vif) != NL80211_IFTYPE_STATION) ||
-        cfg80211_external_auth_request(dev, &params, GFP_ATOMIC)) {
-        wiphy_err(rwnx_hw->wiphy, "Failed to start external auth on vif %d",
-                  ind->vif_idx);
+        (ret = cfg80211_external_auth_request(dev, &params, GFP_ATOMIC))) {
+		wiphy_err(rwnx_hw->wiphy, "Failed to start external auth on vif %d, rwnx_vif->up %d, iftype:%d, ret %d",
+				  ind->vif_idx, rwnx_vif->up, RWNX_VIF_TYPE(rwnx_vif), ret);
         rwnx_send_sm_external_auth_required_rsp(rwnx_hw, rwnx_vif,
                                                 WLAN_STATUS_UNSPECIFIED_FAILURE);
         return 0;
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.c
index 1573ec593411..6b80ce078731 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.c
@@ -67,7 +67,7 @@ const int chnl2bw[] = {
     [PHY_CHNL_BW_80P80]   = NL80211_CHAN_WIDTH_80P80,
 };
 
-#define RWNX_CMD_ARRAY_SIZE 20
+#define RWNX_CMD_ARRAY_SIZE 40
 #define RWNX_CMD_HIGH_WATER_SIZE RWNX_CMD_ARRAY_SIZE/2
 //#define RWNX_MSG_ARRAY_SIZE 20
 
@@ -1065,6 +1065,31 @@ int rwnx_send_arpoffload_en_req(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_v
 }
 #endif
 
+int rwnx_send_disable_agg_req(struct rwnx_hw *rwnx_hw, u8_l agg_disable, u8_l agg_disable_rx, u8_l sta_idx)
+{
+    struct mm_set_agg_disable_req *req;
+    int error;
+
+    RWNX_DBG(RWNX_FN_ENTRY_STR);
+
+    /* Build the MM_SET_AGG_DISABLE_REQ message */
+    req = rwnx_msg_zalloc(MM_SET_AGG_DISABLE_REQ, TASK_MM, DRV_TASK_ID,
+                                  sizeof(struct mm_set_agg_disable_req));
+
+    if (!req) {
+        return -ENOMEM;
+    }
+
+    req->disable = agg_disable;
+    req->staidx = sta_idx;
+    req->disable_rx = agg_disable_rx;
+
+    /* Send the MM_SET_AGG_DISABLE_REQ message to UMAC FW */
+    error = rwnx_send_msg(rwnx_hw, req, 1, MM_SET_AGG_DISABLE_CFM, NULL);
+
+    return (error);
+};
+
 int rwnx_send_coex_req(struct rwnx_hw *rwnx_hw, u8_l disable_coexnull, u8_l enable_nullcts)
 {
     struct mm_set_coex_req *coex_req;
@@ -1114,7 +1139,7 @@ int rwnx_send_rf_config_req(struct rwnx_hw *rwnx_hw, u8_l ofst, u8_l sel, u8_l *
     rf_config_req->table_num = 16;
     rf_config_req->deft_page = 0;
 
-	memcpy(rf_config_req->data, tbl, len);
+    memcpy(rf_config_req->data, tbl, len);
 
     /* Send the MM_SET_RF_CONFIG_REQ message to UMAC FW */
     error = rwnx_send_msg(rwnx_hw, rf_config_req, 1, MM_SET_RF_CONFIG_CFM, NULL);
@@ -1127,7 +1152,7 @@ extern void get_userconfig_xtal_cap(xtal_cap_conf_t *xtal_cap);
 int rwnx_send_rf_calib_req(struct rwnx_hw *rwnx_hw, struct mm_set_rf_calib_cfm *cfm)
 {
     struct mm_set_rf_calib_req *rf_calib_req;
-	xtal_cap_conf_t xtal_cap = {0,};
+    xtal_cap_conf_t xtal_cap = {0,};
     int error;
 
     RWNX_DBG(RWNX_FN_ENTRY_STR);
@@ -1142,30 +1167,34 @@ int rwnx_send_rf_calib_req(struct rwnx_hw *rwnx_hw, struct mm_set_rf_calib_cfm *
 
     if(rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8801){
         rf_calib_req->cal_cfg_24g = 0xbf;
-	rf_calib_req->cal_cfg_5g = 0x3f;
+        rf_calib_req->cal_cfg_5g = 0x3f;
     }else if(rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DC ||
-			rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW){
-	rf_calib_req->cal_cfg_24g = 0x0f8f;
-	rf_calib_req->cal_cfg_5g = 0;
+        rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW){
+        rf_calib_req->cal_cfg_24g = 0x0f8f;
+        rf_calib_req->cal_cfg_5g = 0;
     }else if(rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81){
-	rf_calib_req->cal_cfg_24g = 0x0f8f;
-	rf_calib_req->cal_cfg_5g = 0x0f0f;
+        rf_calib_req->cal_cfg_24g = 0x0f8f;
+        rf_calib_req->cal_cfg_5g = 0x0f0f;
+    }else if(rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81X2 ||
+        rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D89X2){
+        rf_calib_req->cal_cfg_24g = 0x0f8f;
+        rf_calib_req->cal_cfg_5g = 0x0f0f;
     }
 
     rf_calib_req->param_alpha = 0x0c34c008;
     rf_calib_req->bt_calib_en = 0;
     rf_calib_req->bt_calib_param = 0x264203;
 
-	get_userconfig_xtal_cap(&xtal_cap);
+    get_userconfig_xtal_cap(&xtal_cap);
 
-	if (xtal_cap.enable) {
-		AICWFDBG(LOGINFO, "user xtal cap: %d, cap_fine: %d\n", xtal_cap.xtal_cap, xtal_cap.xtal_cap_fine);
-		rf_calib_req->xtal_cap = xtal_cap.xtal_cap;
-		rf_calib_req->xtal_cap_fine = xtal_cap.xtal_cap_fine;
-	} else {
-		rf_calib_req->xtal_cap = 0;
-		rf_calib_req->xtal_cap_fine = 0;
-	}
+    if (xtal_cap.enable) {
+        AICWFDBG(LOGINFO, "user xtal cap: %d, cap_fine: %d\n", xtal_cap.xtal_cap, xtal_cap.xtal_cap_fine);
+        rf_calib_req->xtal_cap = xtal_cap.xtal_cap;
+        rf_calib_req->xtal_cap_fine = xtal_cap.xtal_cap_fine;
+    } else {
+        rf_calib_req->xtal_cap = 0;
+        rf_calib_req->xtal_cap_fine = 0;
+    }
 
     /* Send the MM_SET_RF_CALIB_REQ message to UMAC FW */
     error = rwnx_send_msg(rwnx_hw, rf_calib_req, 1, MM_SET_RF_CALIB_CFM, cfm);
@@ -1266,68 +1295,43 @@ int rwnx_send_set_stack_start_req(struct rwnx_hw *rwnx_hw, u8_l on, u8_l efuse_v
     return error;
 }
 
-#if 0
-int rwnx_send_txop_req(struct rwnx_hw *rwnx_hw, uint16_t *txop, u8_l long_nav_en, u8_l cfe_en)
-{
-    struct mm_set_txop_req *req;
-    int error;
-
-    /* Build the MM_SET_TXOP_REQ message */
-    req = rwnx_msg_zalloc(MM_SET_TXOP_REQ, TASK_MM, DRV_TASK_ID, sizeof(struct mm_set_txop_req));
-
-    if (!req) {
-            return -ENOMEM;
-    }
-
-    req->txop_bk = txop[0];
-    req->txop_be = txop[1];
-    req->txop_vi = txop[2];
-    req->txop_vo = txop[3];
-    req->long_nav_en = long_nav_en;
-    req->cfe_en = cfe_en;
-
-    /* Send the MM_SET_TXOP_REQ  message to UMAC FW */
-    error = rwnx_send_msg(rwnx_hw, req, 1, MM_SET_TXOP_CFM, NULL);
-
-    return error;
-}
-
-int rwnx_send_vendor_trx_param_req(struct rwnx_hw *rwnx_hw, uint32_t *edca, uint8_t vif_idx, uint8_t retry_cnt)
+int rwnx_send_set_temp_comp_req(struct rwnx_hw *rwnx_hw, struct mm_set_vendor_swconfig_cfm *cfm)
 {
-	struct mm_set_vendor_trx_param_req *req;
-	int error;
+	struct mm_set_vendor_swconfig_req *req;
+	int ret;
 
 	RWNX_DBG(RWNX_FN_ENTRY_STR);
-
-	/* Build the MM_SET_VENDOR_TRX_PARAM_REQ message */
-    req = rwnx_msg_zalloc(MM_SET_VENDOR_TRX_PARAM_REQ, TASK_MM, DRV_TASK_ID, sizeof(struct mm_set_vendor_trx_param_req));
+	/* Build the TEMP_COMP_SET_REQ message */
+	req = rwnx_msg_zalloc(MM_SET_VENDOR_SWCONFIG_REQ, TASK_MM, DRV_TASK_ID, sizeof(struct mm_set_vendor_swconfig_req));
 	if (!req) {
-            return -ENOMEM;
-    }
-
-	req->edca[0] = edca[0];
-	req->edca[1] = edca[1];
-	req->edca[2] =  edca[2];
-	req->edca[3] = edca[3];
-	req->vif_idx = vif_idx;
-	req->retry_cnt = retry_cnt;
-
-	/* Send the MM_SET_VENDOR_TRX_PARAM_REQ message to UMAC FW */
-    error = rwnx_send_msg(rwnx_hw, req, 1, MM_SET_VENDOR_TRX_PARAM_CFM, NULL);
-
-	return error;
+		printk("%s msg_alloc fail\n", __func__);
+		return -ENOMEM;
+	}
+	req->swconfig_id = TEMP_COMP_SET_REQ;
+	req->temp_comp_set_req.enable = 1;
+	req->temp_comp_set_req.tmr_period_ms = 15 * 1000;
+
+	ret = rwnx_send_msg(rwnx_hw, req, 1, MM_SET_VENDOR_SWCONFIG_CFM, cfm);
+	if (!ret)
+		printk("temp_comp status: %d\n", cfm->temp_comp_set_cfm.status);
+	else {
+		printk("%s msg_fail\n", __func__);
+		return ret;
+	}
+	return ret;
 }
 
-#endif
-int rwnx_send_vendor_hwconfig_req(struct rwnx_hw *rwnx_hw, uint32_t hwconfig_id, int32_t *param)
+int rwnx_send_vendor_hwconfig_req(struct rwnx_hw *rwnx_hw, uint32_t hwconfig_id, int32_t *param, int32_t *param_out)
 {
 	struct mm_set_acs_txop_req *req0;
 	struct mm_set_channel_access_req *req1;
 	struct mm_set_mac_timescale_req *req2;
 	struct mm_set_cca_threshold_req *req3;
 	struct mm_set_bwmode_req *req4;
+	struct mm_set_customized_freq_req *req5;
 
-	int error;
+	int error = 0;
+	int i;
 
 	switch (hwconfig_id)
 	{
@@ -1365,8 +1369,9 @@ int rwnx_send_vendor_hwconfig_req(struct rwnx_hw *rwnx_hw, uint32_t hwconfig_id,
 		req1->rc_retry_cnt[0] = param[9];
 		req1->rc_retry_cnt[1] = param[10];
 		req1->rc_retry_cnt[2] = param[11];
-		printk("set_channel_access_req:edca[]= %x %x %x %x\nvif_idx: %x, retry_cnt: %x, rts_en: %x, long_nav_en: %x, cfe_en: %x, rc_retry_cnt: %x:%x:%x\n",
-			req1->edca[0], req1->edca[1], req1->edca[2], req1->edca[3], req1->vif_idx, req1->retry_cnt, req1->rts_en, req1->long_nav_en, req1->cfe_en, req1->rc_retry_cnt[0],req1->rc_retry_cnt[1], req1->rc_retry_cnt[2]);
+		req1->ccademod_th = param[12];
+		printk("set_channel_access_req:edca[]= %x %x %x %x\nvif_idx: %x, retry_cnt: %x, rts_en: %x, long_nav_en: %x, cfe_en: %x, rc_retry_cnt: %x:%x:%x, ccademod_th = %d\n",
+			req1->edca[0], req1->edca[1], req1->edca[2], req1->edca[3], req1->vif_idx, req1->retry_cnt, req1->rts_en, req1->long_nav_en, req1->cfe_en, req1->rc_retry_cnt[0],req1->rc_retry_cnt[1], req1->rc_retry_cnt[2], req1->ccademod_th);
 		/* Send the MM_SET_VENDOR_HWCONFIG_CFM  message to UMAC FW */
 		error = rwnx_send_msg(rwnx_hw, req1, 1, MM_SET_VENDOR_HWCONFIG_CFM, NULL);
 		break;
@@ -1416,12 +1421,174 @@ int rwnx_send_vendor_hwconfig_req(struct rwnx_hw *rwnx_hw, uint32_t hwconfig_id,
                 /* Send the MM_SET_VENDOR_HWCONFIG_CFM  message to UMAC FW */
 		error = rwnx_send_msg(rwnx_hw, req4, 1, MM_SET_VENDOR_HWCONFIG_CFM, NULL);
 		break;
+        case CHIP_TEMP_GET_REQ:
+		if ((rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DC) ||
+		(rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW))
+		{
+		struct mm_get_chip_temp_req *req;
+		struct mm_set_vendor_hwconfig_cfm cfm = {0,};
+		/* Build the CHIP_TEMP_GET_REQ message */
+		req = rwnx_msg_zalloc(MM_SET_VENDOR_HWCONFIG_REQ, TASK_MM, DRV_TASK_ID, sizeof(struct mm_get_chip_temp_req));
+		if (!req)
+			return -ENOMEM;
+		req->hwconfig_id = hwconfig_id;
+		/* Send the MM_SET_VENDOR_HWCONFIG_REQ  message to UMAC FW */
+		error = rwnx_send_msg(rwnx_hw, req, 1, MM_SET_VENDOR_HWCONFIG_CFM, &cfm);
+		if (!error) {
+			if (param_out) {
+				param_out[0] = (int32_t)cfm.chip_temp_cfm.degree;
+			}
+			printk("get_chip_temp degree=%d\n", cfm.chip_temp_cfm.degree);
+		} else {
+			printk("get_chip_temp err=%d\n", error);
+			}
+		}
+	case CUSTOMIZED_FREQ_REQ:
+		/* Build the CUSTOMIZED_FREQ_REQ message */
+		req5 = rwnx_msg_zalloc(MM_SET_VENDOR_HWCONFIG_REQ, TASK_MM, DRV_TASK_ID, sizeof(struct mm_set_customized_freq_req));
+		if (!req5)
+		    return -ENOMEM;
+		req5->hwconfig_id = hwconfig_id;
+		for (i = 0; i < 4; i++) {
+		    req5->raw_freq[i] = param [i];
+		    req5->map_freq[i] = param [i + 4];
+		}
+		printk("customized_freq_req: raw_freq[ %d %d %d %d ], map_freq[ %d %d %d %d]\n",
+			param[0], param[1], param[2], param[3], param[4], param[5], param[6], param[7]);
+		/* Send the MM_SET_VENDOR_HWCONFIG_CFM  message to UMAC FW */
+		error = rwnx_send_msg(rwnx_hw, req5, 1, MM_SET_VENDOR_HWCONFIG_CFM, NULL);
+
+        break;
 	    default:
 		return -ENOMEM;
 	}
     return error;
 }
 
+int rwnx_send_vendor_swconfig_req(struct rwnx_hw *rwnx_hw, uint32_t swconfig_id, int32_t *param_in, int32_t *param_out)
+{
+    struct mm_set_vendor_swconfig_req *req;
+    struct mm_set_vendor_swconfig_cfm cfm = {0,};
+    int error;
+
+    req = rwnx_msg_zalloc(MM_SET_VENDOR_SWCONFIG_REQ, TASK_MM, DRV_TASK_ID, sizeof(struct mm_set_vendor_swconfig_req));
+    if (!req) {
+        return -ENOMEM;
+    }
+    req->swconfig_id = swconfig_id;
+
+    switch (swconfig_id)
+    {
+        case BCN_CFG_REQ:
+            /* Build the BCN_CFG_REQ message */
+            req->bcn_cfg_req.tim_bcmc_ignored_enable = (bool_l)param_in[0];
+            printk("bcn_cfg_req: tim_bcmc_ignd=%d\n", req->bcn_cfg_req.tim_bcmc_ignored_enable);
+            /* Send the MM_SET_VENDOR_SWCONFIG_REQ message to UMAC FW */
+            error = rwnx_send_msg(rwnx_hw, req, 1, MM_SET_VENDOR_SWCONFIG_CFM, &cfm);
+            if (!error) {
+                param_out[0] = (int32_t)cfm.bcn_cfg_cfm.tim_bcmc_ignored_status;
+                printk("status=%d\n", cfm.bcn_cfg_cfm.tim_bcmc_ignored_status);
+            }
+            break;
+
+        case TEMP_COMP_SET_REQ:
+            /* Build the TEMP_COMP_SET_REQ message */
+            req->temp_comp_set_req.enable = (u8_l)param_in[0];
+            req->temp_comp_set_req.tmr_period_ms = (u32_l)param_in[1];
+            printk("temp_comp_set_req: en=%d, tmr=%x\n",
+                req->temp_comp_set_req.enable, req->temp_comp_set_req.tmr_period_ms);
+            /* Send the MM_SET_VENDOR_SWCONFIG_REQ message to UMAC FW */
+            error = rwnx_send_msg(rwnx_hw, req, 1, MM_SET_VENDOR_SWCONFIG_CFM, &cfm);
+            if (!error) {
+                param_out[0] = (int32_t)cfm.temp_comp_set_cfm.status;
+                printk("status=%d\n", cfm.temp_comp_set_cfm.status);
+            }
+            break;
+
+        case TEMP_COMP_GET_REQ:
+            printk("temp_comp_get_req\n");
+            /* Send the MM_SET_VENDOR_SWCONFIG_REQ message to UMAC FW */
+            error = rwnx_send_msg(rwnx_hw, req, 1, MM_SET_VENDOR_SWCONFIG_CFM, &cfm);
+            if (!error) {
+                param_out[0] = (int32_t)cfm.temp_comp_get_cfm.status;
+                param_out[1] = (int32_t)cfm.temp_comp_get_cfm.degree;
+                printk("status=%d, degree=%d\n",
+                    cfm.temp_comp_get_cfm.status, cfm.temp_comp_get_cfm.degree);
+            }
+            break;
+
+        case EXT_FLAGS_SET_REQ:
+            /* Build the EXT_FLAGS_SET_REQ message */
+            req->ext_flags_set_req.user_flags = (u32_l)param_in[0];
+            printk("ext_flags_set_req: flags=%x\n",
+                req->ext_flags_set_req.user_flags);
+            /* Send the MM_SET_VENDOR_SWCONFIG_REQ message to UMAC FW */
+            error = rwnx_send_msg(rwnx_hw, req, 1, MM_SET_VENDOR_SWCONFIG_CFM, &cfm);
+            if (!error) {
+                param_out[0] = (uint32_t)cfm.ext_flags_set_cfm.user_flags;
+                printk("cfm flags=%x\n", cfm.ext_flags_set_cfm.user_flags);
+            }
+            break;
+
+        case EXT_FLAGS_GET_REQ:
+            /* Build the EXT_FLAGS_GET_REQ message */
+            printk("ext_flags_get_req\n");
+            /* Send the MM_SET_VENDOR_SWCONFIG_REQ message to UMAC FW */
+            error = rwnx_send_msg(rwnx_hw, req, 1, MM_SET_VENDOR_SWCONFIG_CFM, &cfm);
+            if (!error) {
+                param_out[0] = (uint32_t)cfm.ext_flags_get_cfm.user_flags;
+                printk("cfm flags=%x\n", cfm.ext_flags_get_cfm.user_flags);
+            }
+            break;
+
+        case EXT_FLAGS_MASK_SET_REQ:
+            /* Build the EXT_FLAGS_MASK_SET_REQ message */
+            req->ext_flags_mask_set_req.user_flags_mask = (u32_l)param_in[0];
+            req->ext_flags_mask_set_req.user_flags_val = (u32_l)param_in[1];
+            printk("ext_flags_mask_set_req: flags mask=0x%x, val=0x%x\n",
+                req->ext_flags_mask_set_req.user_flags_mask, req->ext_flags_mask_set_req.user_flags_val);
+            /* Send the MM_SET_VENDOR_SWCONFIG_REQ message to UMAC FW */
+            error = rwnx_send_msg(rwnx_hw, req, 1, MM_SET_VENDOR_SWCONFIG_CFM, &cfm);
+            if (!error) {
+                param_out[0] = (uint32_t)cfm.ext_flags_mask_set_cfm.user_flags;
+                printk("cfm flags=%x\n", cfm.ext_flags_mask_set_cfm.user_flags);
+            }
+            break;
+
+        default:
+            error = -ENOMEM;
+            break;
+    }
+
+    return error;
+}
+
+int rwnx_send_mask_set_ext_flags_req(struct rwnx_hw *rwnx_hw, uint32_t flags_mask, uint32_t flags_val, struct mm_set_vendor_swconfig_cfm *cfm)
+{
+    struct mm_set_vendor_swconfig_req *req;
+    int ret;
+
+    RWNX_DBG(RWNX_FN_ENTRY_STR);
+    /* Build the REQ message */
+    req = rwnx_msg_zalloc(MM_SET_VENDOR_SWCONFIG_REQ, TASK_MM, DRV_TASK_ID, sizeof(struct mm_set_vendor_swconfig_req));
+    if (!req) {
+        AICWFDBG(LOGERROR, "%s msg_alloc fail\n", __func__);
+        return -ENOMEM;
+    }
+    req->swconfig_id = EXT_FLAGS_MASK_SET_REQ;
+    req->ext_flags_mask_set_req.user_flags_mask = (u32_l)flags_mask;
+    req->ext_flags_mask_set_req.user_flags_val = (u32_l)flags_val;
+
+    ret = rwnx_send_msg(rwnx_hw, req, 1, MM_SET_VENDOR_SWCONFIG_CFM, cfm);
+    if (!ret) {
+        AICWFDBG(LOGINFO, "curr ext_flags=%x\n", cfm->ext_flags_mask_set_cfm.user_flags);
+    } else {
+        AICWFDBG(LOGERROR, "%s send_msg_fail\n", __func__);
+        return ret;
+    }
+    return ret;
+}
+
 int rwnx_send_get_fw_version_req(struct rwnx_hw *rwnx_hw, struct mm_get_fw_version_cfm *cfm)
 {
     void *req;
@@ -1593,7 +1760,10 @@ int rwnx_send_txpwr_lvl_v3_req(struct rwnx_hw *rwnx_hw)
     struct mm_set_txpwr_lvl_req *txpwr_lvl_req;
     txpwr_lvl_conf_v3_t txpwr_lvl_v3_tmp;
     txpwr_lvl_conf_v3_t *txpwr_lvl_v3;
+	txpwr_loss_conf_t txpwr_loss_tmp;
+	txpwr_loss_conf_t *txpwr_loss;
     int error;
+	int i;
 
     RWNX_DBG(RWNX_FN_ENTRY_STR);
 
@@ -1606,8 +1776,29 @@ int rwnx_send_txpwr_lvl_v3_req(struct rwnx_hw *rwnx_hw)
     }
 
     txpwr_lvl_v3 = &txpwr_lvl_v3_tmp;
+    txpwr_loss = &txpwr_loss_tmp;
+    txpwr_loss->loss_enable = 0;
 
     get_userconfig_txpwr_lvl_v3_in_fdrv(txpwr_lvl_v3);
+	get_userconfig_txpwr_loss(txpwr_loss);
+
+    if (txpwr_loss->loss_enable == 1) {
+        AICWFDBG(LOGINFO, "%s:loss_value:%d\r\n", __func__, txpwr_loss->loss_value);
+
+        for (i = 0; i <= 11; i++)
+            txpwr_lvl_v3->pwrlvl_11b_11ag_2g4[i] += txpwr_loss->loss_value;
+        for (i = 0; i <= 9; i++)
+            txpwr_lvl_v3->pwrlvl_11n_11ac_2g4[i] += txpwr_loss->loss_value;
+        for (i = 0; i <= 11; i++)
+            txpwr_lvl_v3->pwrlvl_11ax_2g4[i] += txpwr_loss->loss_value;
+
+		for (i = 0; i <= 11; i++)
+            txpwr_lvl_v3->pwrlvl_11a_5g[i] += txpwr_loss->loss_value;
+        for (i = 0; i <= 9; i++)
+            txpwr_lvl_v3->pwrlvl_11n_11ac_5g[i] += txpwr_loss->loss_value;
+        for (i = 0; i <= 11; i++)
+            txpwr_lvl_v3->pwrlvl_11ax_5g[i] += txpwr_loss->loss_value;
+    }
 
     if (txpwr_lvl_v3->enable == 0) {
         rwnx_msg_free(rwnx_hw, txpwr_lvl_req);
@@ -1693,6 +1884,52 @@ int rwnx_send_txpwr_lvl_v3_req(struct rwnx_hw *rwnx_hw)
     }
 }
 
+int rwnx_send_txpwr_lvl_adj_req(struct rwnx_hw *rwnx_hw)
+{
+    struct mm_set_txpwr_lvl_adj_req *txpwr_lvl_adj_req;
+    txpwr_lvl_adj_conf_t txpwr_lvl_adj_tmp;
+    txpwr_lvl_adj_conf_t *txpwr_lvl_adj;
+    int error;
+
+    RWNX_DBG(RWNX_FN_ENTRY_STR);
+
+    /* Build the MM_SET_TXPWR_LVL_REQ message */
+    txpwr_lvl_adj_req = rwnx_msg_zalloc(MM_SET_TXPWR_LVL_ADJ_REQ, TASK_MM, DRV_TASK_ID,
+                                  sizeof(struct mm_set_txpwr_lvl_adj_req));
+
+    if (!txpwr_lvl_adj_req) {
+        return -ENOMEM;
+    }
+
+    txpwr_lvl_adj = &txpwr_lvl_adj_tmp;
+
+    get_userconfig_txpwr_lvl_adj_in_fdrv(txpwr_lvl_adj);
+
+    if (txpwr_lvl_adj->enable == 0) {
+        rwnx_msg_free(rwnx_hw, txpwr_lvl_adj_req);
+        return 0;
+    } else {
+        AICWFDBG(LOGINFO, "%s:enable:%d\r\n",                   __func__, txpwr_lvl_adj->enable);
+        AICWFDBG(LOGINFO, "%s:lvl_adj_2g4_chan_1_4:%d\r\n",     __func__, txpwr_lvl_adj->pwrlvl_adj_tbl_2g4[0]);
+        AICWFDBG(LOGINFO, "%s:lvl_adj_2g4_chan_5_9:%d\r\n",     __func__, txpwr_lvl_adj->pwrlvl_adj_tbl_2g4[1]);
+        AICWFDBG(LOGINFO, "%s:lvl_adj_2g4_chan_10_13:%d\r\n",   __func__, txpwr_lvl_adj->pwrlvl_adj_tbl_2g4[2]);
+
+        AICWFDBG(LOGINFO, "%s:lvl_adj_5g_chan_42:%d\r\n",       __func__, txpwr_lvl_adj->pwrlvl_adj_tbl_5g[0]);
+        AICWFDBG(LOGINFO, "%s:lvl_adj_5g_chan_58:%d\r\n",       __func__, txpwr_lvl_adj->pwrlvl_adj_tbl_5g[1]);
+        AICWFDBG(LOGINFO, "%s:lvl_adj_5g_chan_106:%d\r\n",      __func__, txpwr_lvl_adj->pwrlvl_adj_tbl_5g[2]);
+        AICWFDBG(LOGINFO, "%s:lvl_adj_5g_chan_122:%d\r\n",      __func__, txpwr_lvl_adj->pwrlvl_adj_tbl_5g[3]);
+        AICWFDBG(LOGINFO, "%s:lvl_adj_5g_chan_138:%d\r\n",      __func__, txpwr_lvl_adj->pwrlvl_adj_tbl_5g[4]);
+        AICWFDBG(LOGINFO, "%s:lvl_adj_5g_chan_155:%d\r\n",      __func__, txpwr_lvl_adj->pwrlvl_adj_tbl_5g[5]);
+
+        txpwr_lvl_adj_req->txpwr_lvl_adj  = *txpwr_lvl_adj;
+
+        /* Send the MM_SET_TXPWR_LVL_REQ message to UMAC FW */
+        error = rwnx_send_msg(rwnx_hw, txpwr_lvl_adj_req, 1, MM_SET_TXPWR_LVL_ADJ_CFM, NULL);
+
+        return (error);
+    }
+}
+
 extern void get_userconfig_txpwr_ofst(txpwr_ofst_conf_t *txpwr_ofst);
 
 int rwnx_send_txpwr_ofst_req(struct rwnx_hw *rwnx_hw)
@@ -1723,8 +1960,7 @@ int rwnx_send_txpwr_ofst_req(struct rwnx_hw *rwnx_hw)
 	if(rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8801){
 		get_userconfig_txpwr_ofst(txpwr_ofst);
 	}else if(rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DC ||
-		rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW ||
-		 rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81){
+		rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW){
 		get_userconfig_txpwr_ofst_in_fdrv(txpwr_ofst);
 	}
 	if(txpwr_ofst->enable){
@@ -1748,6 +1984,69 @@ int rwnx_send_txpwr_ofst_req(struct rwnx_hw *rwnx_hw)
     return (error);
 }
 
+int rwnx_send_txpwr_ofst2x_req(struct rwnx_hw *rwnx_hw)
+{
+    struct mm_set_txpwr_ofst_req *txpwr_ofst_req;
+    txpwr_ofst2x_conf_t *txpwr_ofst2x;
+    int error = 0;
+    int type, ch_grp;
+
+    RWNX_DBG(RWNX_FN_ENTRY_STR);
+
+    /* Build the MM_SET_TXPWR_OFST_REQ message */
+    txpwr_ofst_req = rwnx_msg_zalloc(MM_SET_TXPWR_OFST_REQ, TASK_MM, DRV_TASK_ID,
+                                  sizeof(struct mm_set_txpwr_ofst_req));
+
+    if (!txpwr_ofst_req) {
+        return -ENOMEM;
+    }
+
+    txpwr_ofst2x = &txpwr_ofst_req->txpwr_ofst2x;
+    txpwr_ofst2x->enable = 0;
+    for (type = 0; type < 3; type++) {
+        for (ch_grp = 0; ch_grp < 6; ch_grp++) {
+            if (ch_grp < 3) {
+                txpwr_ofst2x->pwrofst2x_tbl_2g4[type][ch_grp] = 0;
+            }
+            txpwr_ofst2x->pwrofst2x_tbl_5g[type][ch_grp] = 0;
+        }
+    }
+    if (rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81){
+        get_userconfig_txpwr_ofst2x_in_fdrv(txpwr_ofst2x);
+    } else if (rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81X2 ||
+        rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D89X2){
+        get_userconfig_txpwr_ofst2x_in_fdrv(txpwr_ofst2x);
+    }
+    if (txpwr_ofst2x->enable){
+        AICWFDBG(LOGINFO, "%s:enable:%d\r\n", __func__, txpwr_ofst2x->enable);
+        AICWFDBG(LOGINFO, "pwrofst2x 2.4g: [0]:11b, [1]:ofdm_highrate, [2]:ofdm_lowrate\n"
+            "  chan=" "\t1-4" "\t5-9" "\t10-13");
+        for (type = 0; type < 3; type++) {
+            AICWFDBG(LOGINFO, "\n  [%d] =", type);
+            for (ch_grp = 0; ch_grp < 3; ch_grp++) {
+                AICWFDBG(LOGINFO, "\t%d", txpwr_ofst2x->pwrofst2x_tbl_2g4[type][ch_grp]);
+            }
+        }
+        AICWFDBG(LOGINFO, "\npwrofst2x 5g: [0]:ofdm_lowrate, [1]:ofdm_highrate, [2]:ofdm_midrate\n"
+            "  chan=" "\t36-50" "\t51-64" "\t98-114" "\t115-130" "\t131-146" "\t147-166");
+        for (type = 0; type < 3; type++) {
+            AICWFDBG(LOGINFO, "\n  [%d] =", type);
+            for (ch_grp = 0; ch_grp < 6; ch_grp++) {
+                AICWFDBG(LOGINFO, "\t%d", txpwr_ofst2x->pwrofst2x_tbl_5g[type][ch_grp]);
+            }
+        }
+        AICWFDBG(LOGINFO, "\n");
+
+        /* Send the MM_SET_TXPWR_OFST_REQ message to UMAC FW */
+        error = rwnx_send_msg(rwnx_hw, txpwr_ofst_req, 1, MM_SET_TXPWR_OFST_CFM, NULL);
+    }else{
+        AICWFDBG(LOGINFO, "%s:Do not use txpwr_ofst2x\r\n", __func__);
+        rwnx_msg_free(rwnx_hw, txpwr_ofst_req);
+    }
+
+    return (error);
+}
+
 int rwnx_send_set_filter(struct rwnx_hw *rwnx_hw, uint32_t filter)
 {
     struct mm_set_filter_req *set_filter_req_param;
@@ -1992,6 +2291,14 @@ int rwnx_send_me_chan_config_req(struct rwnx_hw *rwnx_hw)
             req->chan2G4[req->chan2G4_cnt].band = NL80211_BAND_2GHZ;
             req->chan2G4[req->chan2G4_cnt].freq = b->channels[i].center_freq;
             req->chan2G4[req->chan2G4_cnt].tx_power = chan_to_fw_pwr(b->channels[i].max_power);
+            #ifdef CONFIG_POWER_LIMIT
+            {
+                int8_t max_pwr = get_powerlimit_by_freq(PHY_BAND_2G4, req->chan2G4[req->chan2G4_cnt].freq);
+                if (req->chan2G4[req->chan2G4_cnt].tx_power > max_pwr) {
+                    req->chan2G4[req->chan2G4_cnt].tx_power = max_pwr;
+                }
+            }
+            #endif
             req->chan2G4_cnt++;
             if (req->chan2G4_cnt == MAC_DOMAINCHANNEL_24G_MAX)
                 break;
@@ -2009,6 +2316,14 @@ int rwnx_send_me_chan_config_req(struct rwnx_hw *rwnx_hw)
             req->chan5G[req->chan5G_cnt].band = NL80211_BAND_5GHZ;
             req->chan5G[req->chan5G_cnt].freq = b->channels[i].center_freq;
             req->chan5G[req->chan5G_cnt].tx_power = chan_to_fw_pwr(b->channels[i].max_power);
+            #ifdef CONFIG_POWER_LIMIT
+            {
+                int8_t max_pwr = get_powerlimit_by_freq(PHY_BAND_5G, req->chan5G[req->chan5G_cnt].freq);
+                if (req->chan5G[req->chan5G_cnt].tx_power > max_pwr) {
+                    req->chan5G[req->chan5G_cnt].tx_power = max_pwr;
+                }
+            }
+            #endif
             req->chan5G_cnt++;
             if (req->chan5G_cnt == MAC_DOMAINCHANNEL_5G_MAX)
                 break;
@@ -2039,16 +2354,24 @@ int rwnx_send_me_set_control_port_req(struct rwnx_hw *rwnx_hw, bool opened, u8 s
     return rwnx_send_msg(rwnx_hw, req, 1, ME_SET_CONTROL_PORT_CFM, NULL);
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0) && LINUX_VERSION_CODE < KERNEL_VERSION(4, 20, 0))
+struct ieee80211_he_cap_elem_4_19 {
+	u8 mac_cap_info[6];
+	u8 phy_cap_info[11];
+} __packed;
+#endif
 int rwnx_send_me_sta_add(struct rwnx_hw *rwnx_hw, struct station_parameters *params,
                          const u8 *mac, u8 inst_nbr, struct me_sta_add_cfm *cfm)
 {
     struct me_sta_add_req *req;
-	
-#if LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
-    u8 *ht_mcs = (u8 *)&params->ht_capa->mcs;
+
+#if LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION
+    struct link_station_parameters *link_sta_params = &params->link_sta_params;
 #else
-	u8 *ht_mcs = (u8 *)&params->link_sta_params.ht_capa->mcs;
-#endif//HIGH_KERNEL_VERSION
+    struct station_parameters *link_sta_params = params;
+#endif
+
+	u8 *ht_mcs = (u8 *)&link_sta_params->ht_capa->mcs;
 
     int i;
     struct rwnx_vif *rwnx_vif = rwnx_hw->vif_table[inst_nbr];
@@ -2071,30 +2394,14 @@ int rwnx_send_me_sta_add(struct rwnx_hw *rwnx_hw, struct station_parameters *par
     /* Set parameters for the MM_STA_ADD_REQ message */
     memcpy(&(req->mac_addr.array[0]), mac, ETH_ALEN);
 
-#if LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
-	req->rate_set.length = params->supported_rates_len;
-#else
-	req->rate_set.length = params->link_sta_params.supported_rates_len;
-#endif//LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
-
-    for (i = 0; i < req->rate_set.length; i++){
-#if LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
-		req->rate_set.array[i] = params->supported_rates[i];
-#else
-		req->rate_set.array[i] = params->link_sta_params.supported_rates[i];
-#endif//LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
-    	}
+	req->rate_set.length = link_sta_params->supported_rates_len;;
+	for (i = 0; i < link_sta_params->supported_rates_len; i++)
+		req->rate_set.array[i] = link_sta_params->supported_rates[i];
 
     req->flags = 0;
-    
-#if LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
-	if (params->ht_capa) {
-		const struct ieee80211_ht_cap *ht_capa = params->ht_capa;
-#else
-	if (params->link_sta_params.ht_capa) {
-		const struct ieee80211_ht_cap *ht_capa = params->link_sta_params.ht_capa;
-#endif//LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
 
+	if (link_sta_params->ht_capa) {
+		const struct ieee80211_ht_cap *ht_capa = link_sta_params->ht_capa;
 
         req->flags |= STA_HT_CAPA;
         req->ht_cap.ht_capa_info = cpu_to_le16(ht_capa->cap_info);
@@ -2107,13 +2414,9 @@ int rwnx_send_me_sta_add(struct rwnx_hw *rwnx_hw, struct station_parameters *par
     }
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
-#if LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
-    if (params->vht_capa) {
-        const struct ieee80211_vht_cap *vht_capa = params->vht_capa;
-#else
-	if (params->link_sta_params.vht_capa) {
-		const struct ieee80211_vht_cap *vht_capa = params->link_sta_params.vht_capa;
-#endif//LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
+    if (link_sta_params->vht_capa) {
+		const struct ieee80211_vht_cap *vht_capa = link_sta_params->vht_capa;
+
         req->flags |= STA_VHT_CAPA;
         req->vht_cap.vht_capa_info = cpu_to_le32(vht_capa->vht_cap_info);
         req->vht_cap.rx_highest = cpu_to_le16(vht_capa->supp_mcs.rx_highest);
@@ -2123,25 +2426,24 @@ int rwnx_send_me_sta_add(struct rwnx_hw *rwnx_hw, struct station_parameters *par
     }
 #elif defined(CONFIG_VHT_FOR_OLD_KERNEL)
     if (sta->vht) {
-        const struct ieee80211_vht_cap *vht_capa = rwnx_vht_capa;
+        //const struct ieee80211_vht_cap *vht_capa = rwnx_vht_capa;
 
         req->flags |= STA_VHT_CAPA;
-        req->vht_cap.vht_capa_info = cpu_to_le32(vht_capa->vht_cap_info);
-        req->vht_cap.rx_highest = cpu_to_le16(vht_capa->supp_mcs.rx_highest);
-        req->vht_cap.rx_mcs_map = cpu_to_le16(vht_capa->supp_mcs.rx_mcs_map);
-        req->vht_cap.tx_highest = cpu_to_le16(vht_capa->supp_mcs.tx_highest);
-        req->vht_cap.tx_mcs_map = cpu_to_le16(vht_capa->supp_mcs.tx_mcs_map);
+        req->vht_cap.vht_capa_info = cpu_to_le32(rwnx_vht_capa->cap);
+        req->vht_cap.rx_highest = cpu_to_le16(rwnx_vht_capa->vht_mcs.rx_highest);
+        req->vht_cap.rx_mcs_map = cpu_to_le16(rwnx_vht_capa->vht_mcs.rx_mcs_map);
+        req->vht_cap.tx_highest = cpu_to_le16(rwnx_vht_capa->vht_mcs.tx_highest);
+        req->vht_cap.tx_mcs_map = cpu_to_le16(rwnx_vht_capa->vht_mcs.tx_mcs_map);
     }
 #endif
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 20, 0)
-#if LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
-	if (params->he_capa) {
-		const struct ieee80211_he_cap_elem *he_capa = params->he_capa;
-#else
-	if (params->link_sta_params.he_capa) {
-		const struct ieee80211_he_cap_elem *he_capa = params->link_sta_params.he_capa;
-#endif//LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0)
+	if (link_sta_params->he_capa) {
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 20, 0)
+		const struct ieee80211_he_cap_elem_4_19 *he_capa = (const struct ieee80211_he_cap_elem_4_19 *) link_sta_params->he_capa;
+	#else
+		const struct ieee80211_he_cap_elem *he_capa = link_sta_params->he_capa;
+	#endif
         struct ieee80211_he_mcs_nss_supp *mcs_nss_supp =
                                 (struct ieee80211_he_mcs_nss_supp *)(he_capa + 1);
 
@@ -2189,13 +2491,8 @@ int rwnx_send_me_sta_add(struct rwnx_hw *rwnx_hw, struct station_parameters *par
         req->flags |= STA_MFP_CAPA;
 
     #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
-#if LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
-    if (params->opmode_notif_used) {
-		req->opmode = params->opmode_notif;
-#else
-	if (params->link_sta_params.opmode_notif_used) {
-		req->opmode = params->link_sta_params.opmode_notif;
-#endif//LINUX_VERSION_CODE < HIGH_KERNEL_VERSION
+    if (link_sta_params->opmode_notif_used) {
+		req->opmode = link_sta_params->opmode_notif_used;
         req->flags |= STA_OPMOD_NOTIF;
     }
     #endif
@@ -2353,11 +2650,11 @@ int rwnx_send_sm_connect_req(struct rwnx_hw *rwnx_hw,
     u32_l flags = 0;
     bool gval = false;
     bool pval = false;
-	
+
     rwnx_vif->wep_enabled = false;
     rwnx_vif->wep_auth_err = false;
     rwnx_vif->last_auth_type = 0;
-	
+
 
     RWNX_DBG(RWNX_FN_ENTRY_STR);
 
@@ -2453,14 +2750,15 @@ int rwnx_send_sm_connect_req(struct rwnx_hw *rwnx_hw,
         rwnx_vif->last_auth_type = sme->auth_type;
     }
 #ifdef CONFIG_USE_WIRELESS_EXT
-	memset(rwnx_hw->wext_essid, 0, 32);
+	memset(rwnx_hw->wext_essid, 0, 33);
 	memcpy(rwnx_hw->wext_essid, sme->ssid, (int)sme->ssid_len);
 #endif
 
 	rwnx_vif->sta.ssid_len = (int)sme->ssid_len;
 	memset(rwnx_vif->sta.ssid, 0, rwnx_vif->sta.ssid_len + 1);
 	memcpy(rwnx_vif->sta.ssid, sme->ssid, rwnx_vif->sta.ssid_len);
-	memcpy(rwnx_vif->sta.bssid, sme->bssid, ETH_ALEN);
+	if (sme->bssid)
+		memcpy(rwnx_vif->sta.bssid, sme->bssid, ETH_ALEN);
 
 	AICWFDBG(LOGINFO, "%s drv_vif_index:%d connect to %s(%d) channel:%d auth_type:%d\r\n",
 		__func__,
@@ -2516,7 +2814,7 @@ int rwnx_send_sm_external_auth_required_rsp(struct rwnx_hw *rwnx_hw,
     rsp->vif_idx = rwnx_vif->vif_index;
 
     /* send the SM_EXTERNAL_AUTH_REQUIRED_RSP message UMAC FW */
-    return rwnx_send_msg(rwnx_hw, rsp, 0, 0, NULL);
+    return rwnx_send_msg(rwnx_hw, rsp, 1, SM_EXTERNAL_AUTH_REQUIRED_RSP_CFM, NULL);
 }
 
 int rwnx_send_apm_start_req(struct rwnx_hw *rwnx_hw, struct rwnx_vif *vif,
@@ -2649,8 +2947,6 @@ int rwnx_send_apm_stop_req(struct rwnx_hw *rwnx_hw, struct rwnx_vif *vif)
     return rwnx_send_msg(rwnx_hw, req, 1, APM_STOP_CFM, NULL);
 }
 
-uint8_t scanning = 0;
-uint8_t p2p_working = 0;
 
 #define P2P_WILDCARD_SSID                       "DIRECT-"
 #define P2P_WILDCARD_SSID_LEN                   (sizeof(P2P_WILDCARD_SSID) - 1)
@@ -2731,7 +3027,7 @@ int rwnx_send_scanu_req(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_vif,
     if (!req)
         return -ENOMEM;
 
-    scanning = 1;
+    rwnx_hw->scanning = 1;
     /* Set parameters */
     req->vif_idx = rwnx_vif->vif_index;
     req->chan_cnt = (u8)min_t(int, SCAN_CHANNEL_MAX, param->n_channels);
@@ -2787,9 +3083,9 @@ int rwnx_send_scanu_req(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_vif,
 #endif
             AICWFDBG(LOGINFO ,"p2p scan start\n");
 #ifdef CONFIG_STA_SCAN_WHEN_P2P_WORKING
-			p2p_working = 0;
+			rwnx_hw->p2p_working = false;
 #else
-			p2p_working = 1;
+			rwnx_hw->p2p_working = true;
 #endif
         }
     }
@@ -3736,10 +4032,10 @@ int rwnx_send_cfg_rssi_req(struct rwnx_hw *rwnx_hw, u8 vif_index, int rssi_thold
     req->rssi_hyst = (u8)rssi_hyst;
 
     /* Send the MM_CFG_RSSI_REQ message to LMAC FW */
-    return rwnx_send_msg(rwnx_hw, req, 0, 0, NULL);
+    return rwnx_send_msg(rwnx_hw, req, 1, MM_CFG_RSSI_CFM, NULL);
 }
 
-#ifdef CONFIG_USB_BT
+//#ifdef CONFIG_USB_BT
 int rwnx_send_reboot(struct rwnx_hw *rwnx_hw)
 {
     int ret = 0;
@@ -3750,4 +4046,4 @@ int rwnx_send_reboot(struct rwnx_hw *rwnx_hw)
     ret = rwnx_send_dbg_start_app_req(rwnx_hw, delay, HOST_START_APP_REBOOT);
     return ret;
 }
-#endif // CONFIG_USB_BT
+//#endif // CONFIG_USB_BT
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.h
index 7142dc0aa065..5533c527acf7 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.h
@@ -159,23 +159,29 @@ int rwnx_send_dbg_gpio_write_req(struct rwnx_hw *rwnx_hw, u8_l gpio_idx, u8_l gp
 int rwnx_send_dbg_gpio_read_req(struct rwnx_hw *rwnx_hw, u8_l gpio_idx, struct dbg_gpio_read_cfm *cfm);
 int rwnx_send_dbg_gpio_init_req(struct rwnx_hw *rwnx_hw, u8_l gpio_idx, u8_l gpio_dir, u8_l gpio_val);
 int rwnx_send_cfg_rssi_req(struct rwnx_hw *rwnx_hw, u8 vif_index, int rssi_thold, u32 rssi_hyst);
+int rwnx_send_disable_agg_req(struct rwnx_hw *rwnx_hw, u8_l agg_disable, u8_l agg_disable_rx, u8_l sta_idx);
 int rwnx_send_coex_req(struct rwnx_hw *rwnx_hw, u8_l disable_coexnull, u8_l enable_nullcts);
 int rwnx_send_get_sta_info_req(struct rwnx_hw *rwnx_hw, u8_l sta_idx, struct mm_get_sta_info_cfm *cfm);
 int rwnx_send_set_stack_start_req(struct rwnx_hw *rwnx_hw, u8_l on, u8_l efuse_valid, u8_l set_vendor_info,
 					u8_l fwtrace_redir_en, struct mm_set_stack_start_cfm *cfm);
 int rwnx_send_txop_req(struct rwnx_hw *rwnx_hw, uint16_t *txop, u8_l long_nav_en, u8_l cfe_en);
-int rwnx_send_vendor_hwconfig_req(struct rwnx_hw *rwnx_hw, uint32_t hwconfig_id, int32_t *param);
+int rwnx_send_set_temp_comp_req(struct rwnx_hw *rwnx_hw, struct mm_set_vendor_swconfig_cfm *cfm);
+int rwnx_send_vendor_hwconfig_req(struct rwnx_hw *rwnx_hw, uint32_t hwconfig_id, int32_t *param, int32_t *param_out);
+int rwnx_send_vendor_swconfig_req(struct rwnx_hw *rwnx_hw, uint32_t swconfig_id, int32_t *param_in, int32_t *param_out);
+int rwnx_send_mask_set_ext_flags_req(struct rwnx_hw *rwnx_hw, uint32_t flags_mask, uint32_t flags_val, struct mm_set_vendor_swconfig_cfm *cfm);
 
 int rwnx_send_get_fw_version_req(struct rwnx_hw *rwnx_hw, struct mm_get_fw_version_cfm *cfm);
 int rwnx_send_txpwr_idx_req(struct rwnx_hw *rwnx_hw);
 int rwnx_send_txpwr_ofst_req(struct rwnx_hw *rwnx_hw);
+int rwnx_send_txpwr_ofst2x_req(struct rwnx_hw *rwnx_hw);
 int rwnx_send_set_filter(struct rwnx_hw *rwnx_hw, uint32_t filter);
 int rwnx_send_txpwr_lvl_req(struct rwnx_hw *rwnx_hw);
 int rwnx_send_txpwr_lvl_v3_req(struct rwnx_hw *rwnx_hw);
+int rwnx_send_txpwr_lvl_adj_req(struct rwnx_hw *rwnx_hw);
 
-#ifdef CONFIG_USB_BT
+//#ifdef CONFIG_USB_BT
 int rwnx_send_reboot(struct rwnx_hw *rwnx_hw);
-#endif // CONFIG_USB_BT
+//#endif // CONFIG_USB_BT
 
 
 #endif /* _RWNX_MSG_TX_H_ */
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.c
index 9ccd54389901..0402d145bc57 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.c
@@ -33,6 +33,7 @@
 #include "md5.h"
 #include "aicwf_compat_8800dc.h"
 #include "aicwf_compat_8800d80.h"
+#include "aicwf_compat_8800d80x2.h"
 #ifdef CONFIG_USE_FW_REQUEST
 #include <linux/firmware.h>
 #endif
@@ -60,8 +61,10 @@ typedef struct
     txpwr_lvl_conf_t txpwr_lvl;
     txpwr_lvl_conf_v2_t txpwr_lvl_v2;
     txpwr_lvl_conf_v3_t txpwr_lvl_v3;
+    txpwr_lvl_adj_conf_t txpwr_lvl_adj;
     txpwr_loss_conf_t txpwr_loss;
     txpwr_ofst_conf_t txpwr_ofst;
+    txpwr_ofst2x_conf_t txpwr_ofst2x;
     xtal_cap_conf_t xtal_cap;
 } userconfig_info_t;
 
@@ -125,6 +128,21 @@ userconfig_info_t userconfig_info = {
         .chan_122_140 = 0,
         .chan_142_165 = 0,
     },
+    .txpwr_ofst2x = {
+        .enable       = 0,
+        .pwrofst2x_tbl_2g4 =
+        { // ch1-4, ch5-9, ch10-13
+            {   0,    0,    0   }, // 11b
+            {   0,    0,    0   }, // ofdm_highrate
+            {   0,    0,    0   }, // ofdm_lowrate
+        },
+        .pwrofst2x_tbl_5g =
+        { // ch42,  ch58, ch106,ch122,ch138,ch155
+            {   0,    0,    0,    0,    0,    0   }, // ofdm_lowrate
+            {   0,    0,    0,    0,    0,    0   }, // ofdm_highrate
+            {   0,    0,    0,    0,    0,    0   }, // ofdm_midrate
+        },
+    },
     .xtal_cap = {
         .enable        = 0,
         .xtal_cap      = 24,
@@ -132,6 +150,29 @@ userconfig_info_t userconfig_info = {
     },
 };
 
+#ifdef CONFIG_POWER_LIMIT
+#define POWER_LIMIT_INVALID_VAL     POWER_LEVEL_INVALID_VAL
+
+#define POWER_LIMIT_CC_MATCHED_BIT  (0x1U << 0)
+
+typedef struct
+{
+    u8_l ch_cnt_2g4;
+    u8_l ch_cnt_5g;
+    u8_l ch_num_2g4[MAC_DOMAINCHANNEL_24G_MAX];
+    u8_l ch_num_5g[MAC_DOMAINCHANNEL_5G_MAX];
+    s8_l max_pwr_2g4[MAC_DOMAINCHANNEL_24G_MAX];
+    s8_l max_pwr_5g[MAC_DOMAINCHANNEL_5G_MAX];
+} txpwr_lmt_info_t;
+
+typedef struct
+{
+    u32_l flags;
+    txpwr_lmt_info_t txpwr_lmt;
+} powerlimit_info_t;
+
+powerlimit_info_t powerlimit_info = {0,};
+#endif
 
 #ifndef CONFIG_ROM_PATCH_EN
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 9, 0))
@@ -319,9 +360,9 @@ static int rwnx_load_firmware(u32 **fw_buf, const char *name, struct device *dev
     void *buffer = NULL;
     char *path = NULL;
     struct file *fp = NULL;
-    int size = 0, len = 0, i = 0;
+    int size = 0, len = 0;// i = 0;
     ssize_t rdlen = 0;
-    u32 *src = NULL, *dst = NULL;
+    //u32 *src = NULL, *dst = NULL;
 	MD5_CTX md5;
 	unsigned char decrypt[16];
 
@@ -394,6 +435,7 @@ static int rwnx_load_firmware(u32 **fw_buf, const char *name, struct device *dev
         fp->f_pos += rdlen;
     }
 
+#if 0
     /*start to transform the data format*/
     src = (u32 *)buffer;
     dst = (u32 *)vmalloc(size);
@@ -411,16 +453,17 @@ static int rwnx_load_firmware(u32 **fw_buf, const char *name, struct device *dev
     for (i = 0; i < (size/4); i++) {
         dst[i] = src[i];
     }
+#endif
 
     __putname(path);
     filp_close(fp, NULL);
     fp = NULL;
-    vfree(buffer);
-    buffer = NULL;
-    *fw_buf = dst;
+    //vfree(buffer);
+    //buffer = NULL;
+    *fw_buf = (u32*)buffer;
 
 	MD5Init(&md5);
-	MD5Update(&md5, (unsigned char *)dst, size);
+	MD5Update(&md5, (unsigned char *)buffer, size);
 	MD5Final(&md5, decrypt);
 
 	AICWFDBG(LOGINFO, MD5PINRT, MD5(decrypt));
@@ -1221,7 +1264,7 @@ static void rwnx_plat_mpif_sel(struct rwnx_plat *rwnx_plat)
 #endif
 }
 #endif
-#ifdef CONFIG_DPD
+#if (defined(CONFIG_DPD) && !defined(CONFIG_FORCE_DPD_CALIB))
 int is_file_exist(char* name)
 {
     char *path = NULL;
@@ -1248,15 +1291,13 @@ int is_file_exist(char* name)
         return 1;
     }
 }
-#endif//CONFIG_DPD
+#endif//CONFIG_DPD && !CONFIG_FORCE_DPD_CALIB
 /**
  * rwnx_plat_patch_load() - Load patch code
  *
  * @rwnx_hw: Main driver data
  */
 #ifdef CONFIG_ROM_PATCH_EN
-
-
 static int rwnx_plat_patch_load(struct rwnx_hw *rwnx_hw)
 {
     int ret = 0;
@@ -1268,47 +1309,140 @@ static int rwnx_plat_patch_load(struct rwnx_hw *rwnx_hw)
 #ifndef ANDROID_PLATFORM
         sprintf(aic_fw_path, "%s/%s", aic_fw_path, "aic8800DC");
 #endif
-#ifdef CONFIG_DPD
-		if (chip_sub_id == 1) {
-			 AICWFDBG(LOGINFO, "testmode=%d\n", testmode);
-			 if (testmode == FW_NORMAL_MODE) {
-				 if (is_file_exist(FW_DPDRESULT_NAME_8800DC) == 1) {
-					 AICWFDBG(LOGINFO, "dpd bin load\n");
-					 ret = aicwf_dpd_result_load_8800dc(rwnx_hw);
-					 if (ret) {
-						 AICWFDBG(LOGINFO, "load dpd bin fail: %d\n", ret);
-						 return ret;
-					 }
-				} else {
-					aicwf_misc_ram_init_8800dc(rwnx_hw);
-				 }
-			 } else if (testmode == FW_DPDCALIB_MODE) {
-				 if (is_file_exist(FW_DPDRESULT_NAME_8800DC) == 0) {
-					 uint32_t dpd_res[DPD_RESULT_SIZE_8800DC / 4] = {0,};
-					 AICWFDBG(LOGINFO, "dpd calib & write\n");
-					 ret = aicwf_dpd_calib_8800dc(rwnx_hw, &dpd_res[0]);
-					 if (ret) {
-						 AICWFDBG(LOGINFO, "dpd calib fail: %d\n", ret);
-						 return ret;
-					 }
-					 ret = aicwf_dpd_result_write_8800dc((void *)dpd_res, DPD_RESULT_SIZE_8800DC);
-					 if (ret) {
-						 AICWFDBG(LOGINFO, "file write fail: %d\n", ret);
-						 return ret;
-					 }
-				 }
-				 return 1; // exit calib mode
-			 }
-		}
-#else
-		if (chip_sub_id == 1) {
-			aicwf_misc_ram_init_8800dc(rwnx_hw);
-		}
-#endif
-
-	ret = aicwf_plat_patch_load_8800dc(rwnx_hw);
-        if (!ret) {
-            aicwf_patch_config_8800dc(rwnx_hw);
+        AICWFDBG(LOGINFO, "testmode=%d\n", testmode);
+        if (chip_sub_id == 0) {
+            if (testmode == FW_NORMAL_MODE) {
+                ret = aicwf_plat_patch_load_8800dc(rwnx_hw);
+                if (ret) {
+                    AICWFDBG(LOGINFO, "load patch bin fail: %d\n", ret);
+                    return ret;
+                }
+                aicwf_patch_config_8800dc(rwnx_hw);
+            } else if (testmode == FW_RFTEST_MODE) {
+                ret = aicwf_plat_rftest_load_8800dc(rwnx_hw);
+                if (ret) {
+                    AICWFDBG(LOGINFO, "load rftest bin fail: %d\n", ret);
+                    return ret;
+                }
+            }
+        } else if (chip_sub_id >= 1) {
+            if (testmode == FW_NORMAL_MODE) {
+                ret = aicwf_plat_patch_load_8800dc(rwnx_hw);
+                if (ret) {
+                    AICWFDBG(LOGINFO, "load patch bin fail: %d\n", ret);
+                    return ret;
+                }
+                aicwf_patch_config_8800dc(rwnx_hw);
+                #ifdef CONFIG_DPD
+                #ifdef CONFIG_FORCE_DPD_CALIB
+                if (1) {
+                    AICWFDBG(LOGINFO, "dpd calib & write\n");
+                    ret = aicwf_dpd_calib_8800dc(rwnx_hw, &dpd_res);
+                    if (ret) {
+                        AICWFDBG(LOGINFO, "dpd calib fail: %d\n", ret);
+                        return ret;
+                    }
+                }
+                #else
+                if (is_file_exist(FW_DPDRESULT_NAME_8800DC) == 1) {
+                    AICWFDBG(LOGINFO, "dpd bin load\n");
+                    ret = aicwf_dpd_result_load_8800dc(rwnx_hw, &dpd_res);
+                    if (ret) {
+                        AICWFDBG(LOGINFO, "load dpd bin fail: %d\n", ret);
+                        return ret;
+                    }
+                    ret = aicwf_dpd_result_apply_8800dc(rwnx_hw, &dpd_res);
+                    if (ret) {
+                        AICWFDBG(LOGINFO, "apply dpd bin fail: %d\n", ret);
+                        return ret;
+                    }
+                }
+                #endif
+                else
+                #elif defined(CONFIG_LOFT_CALIB)
+                if (1) {
+                    AICWFDBG(LOGINFO, "loft calib\n");
+                    ret = aicwf_loft_calib_8800dc(rwnx_hw, &loft_res_local);
+                    if (ret) {
+                        AICWFDBG(LOGINFO, "loft calib fail: %d\n", ret);
+                        return ret;
+                    }
+                } else
+                #endif
+                {
+                    ret = aicwf_misc_ram_init_8800dc(rwnx_hw);
+                    if (ret) {
+                        AICWFDBG(LOGINFO, "misc ram init fail: %d\n", ret);
+                        return ret;
+                    }
+                }
+            } else if (testmode == FW_RFTEST_MODE) {
+                #ifdef CONFIG_DPD
+                #ifdef CONFIG_FORCE_DPD_CALIB
+                if (1) {
+                    AICWFDBG(LOGINFO, "patch load\n");
+                    ret = aicwf_plat_patch_load_8800dc(rwnx_hw);
+                    if (ret) {
+                        AICWFDBG(LOGINFO, "load patch bin fail: %d\n", ret);
+                        return ret;
+                    }
+                    //aicwf_patch_config_8800dc(rwnx_hw);
+                    AICWFDBG(LOGINFO, "dpd calib & write\n");
+                    ret = aicwf_dpd_calib_8800dc(rwnx_hw, &dpd_res);
+                    if (ret) {
+                        AICWFDBG(LOGINFO, "dpd calib fail: %d\n", ret);
+                        return ret;
+                    }
+                }
+                #endif/*CONFIG_FORCE_DPD_CALIB*/
+                #elif defined(CONFIG_LOFT_CALIB)
+                {
+                    AICWFDBG(LOGINFO, "patch load\n");
+                    ret = aicwf_plat_patch_load_8800dc(rwnx_hw);
+                    if (ret) {
+                        AICWFDBG(LOGINFO, "load patch bin fail: %d\n", ret);
+                        return ret;
+                    }
+                    AICWFDBG(LOGINFO, "loft calib\n");
+                    ret = aicwf_loft_calib_8800dc(rwnx_hw, &loft_res_local);
+                    if (ret) {
+                        AICWFDBG(LOGINFO, "loft calib fail: %d\n", ret);
+                        return ret;
+                    }
+                }
+                #endif/*CONFIG_DPD*/
+                AICWFDBG(LOGINFO, "%s load rftest bin\n", __func__);
+                ret = aicwf_plat_rftest_load_8800dc(rwnx_hw);
+                if (ret) {
+                    AICWFDBG(LOGINFO, "load rftest bin fail: %d\n", ret);
+                    return ret;
+                }
+                /* Note: apply dpd_res after rftest running */
+            } else if (testmode == FW_DPDCALIB_MODE) {
+                #if (defined(CONFIG_DPD) && !defined(CONFIG_FORCE_DPD_CALIB))
+                if (is_file_exist(FW_DPDRESULT_NAME_8800DC) == 0) {
+                    AICWFDBG(LOGINFO, "patch load\n");
+                    ret = aicwf_plat_patch_load_8800dc(rwnx_hw);
+                    if (ret) {
+                        AICWFDBG(LOGINFO, "load patch bin fail: %d\n", ret);
+                        return ret;
+                    }
+                    //aicwf_patch_config_8800dc(rwnx_hw);
+                    AICWFDBG(LOGINFO, "dpd calib & write\n");
+                    ret = aicwf_dpd_calib_8800dc(rwnx_hw, &dpd_res);
+                    if (ret) {
+                        AICWFDBG(LOGINFO, "dpd calib fail: %d\n", ret);
+                        return ret;
+                    }
+                    ret = aicwf_dpd_result_write_8800dc((void *)&dpd_res, DPD_RESULT_SIZE_8800DC);
+                    if (ret) {
+                        AICWFDBG(LOGINFO, "file write fail: %d\n", ret);
+                        return ret;
+                    }
+                }
+                #endif
+                return 1; // exit calib mode
+            }
         }
     }
 
@@ -1711,6 +1845,23 @@ void get_userconfig_txpwr_lvl_v3_in_fdrv(txpwr_lvl_conf_v3_t *txpwr_lvl_v3)
     AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs11_5g:%d\r\n",    __func__, txpwr_lvl_v3->pwrlvl_11ax_5g[11]);
 }
 
+void get_userconfig_txpwr_lvl_adj_in_fdrv(txpwr_lvl_adj_conf_t *txpwr_lvl_adj)
+{
+    *txpwr_lvl_adj = userconfig_info.txpwr_lvl_adj;
+
+    AICWFDBG(LOGINFO, "%s:enable:%d\r\n",                   __func__, txpwr_lvl_adj->enable);
+    AICWFDBG(LOGINFO, "%s:lvl_adj_2g4_chan_1_4:%d\r\n",     __func__, txpwr_lvl_adj->pwrlvl_adj_tbl_2g4[0]);
+    AICWFDBG(LOGINFO, "%s:lvl_adj_2g4_chan_5_9:%d\r\n",     __func__, txpwr_lvl_adj->pwrlvl_adj_tbl_2g4[1]);
+    AICWFDBG(LOGINFO, "%s:lvl_adj_2g4_chan_10_13:%d\r\n",   __func__, txpwr_lvl_adj->pwrlvl_adj_tbl_2g4[2]);
+
+    AICWFDBG(LOGINFO, "%s:lvl_adj_5g_chan_42:%d\r\n",       __func__, txpwr_lvl_adj->pwrlvl_adj_tbl_5g[0]);
+    AICWFDBG(LOGINFO, "%s:lvl_adj_5g_chan_58:%d\r\n",       __func__, txpwr_lvl_adj->pwrlvl_adj_tbl_5g[1]);
+    AICWFDBG(LOGINFO, "%s:lvl_adj_5g_chan_106:%d\r\n",      __func__, txpwr_lvl_adj->pwrlvl_adj_tbl_5g[2]);
+    AICWFDBG(LOGINFO, "%s:lvl_adj_5g_chan_122:%d\r\n",      __func__, txpwr_lvl_adj->pwrlvl_adj_tbl_5g[3]);
+    AICWFDBG(LOGINFO, "%s:lvl_adj_5g_chan_138:%d\r\n",      __func__, txpwr_lvl_adj->pwrlvl_adj_tbl_5g[4]);
+    AICWFDBG(LOGINFO, "%s:lvl_adj_5g_chan_155:%d\r\n",      __func__, txpwr_lvl_adj->pwrlvl_adj_tbl_5g[5]);
+}
+
 
 void get_userconfig_txpwr_ofst_in_fdrv(txpwr_ofst_conf_t *txpwr_ofst)
 {
@@ -1733,6 +1884,30 @@ void get_userconfig_txpwr_ofst_in_fdrv(txpwr_ofst_conf_t *txpwr_ofst)
     AICWFDBG(LOGINFO, "%s:chan_142_165:%d\r\n", __func__, txpwr_ofst->chan_142_165);
 }
 
+void get_userconfig_txpwr_ofst2x_in_fdrv(txpwr_ofst2x_conf_t *txpwr_ofst2x)
+{
+    int type, ch_grp;
+    *txpwr_ofst2x = userconfig_info.txpwr_ofst2x;
+    AICWFDBG(LOGINFO, "%s:enable      :%d\r\n", __func__, txpwr_ofst2x->enable);
+    AICWFDBG(LOGINFO, "pwrofst2x 2.4g: [0]:11b, [1]:ofdm_highrate, [2]:ofdm_lowrate\n"
+        "  chan=" "\t1-4" "\t5-9" "\t10-13");
+    for (type = 0; type < 3; type++) {
+        AICWFDBG(LOGINFO, "\n  [%d] =", type);
+        for (ch_grp = 0; ch_grp < 3; ch_grp++) {
+            AICWFDBG(LOGINFO, "\t%d", txpwr_ofst2x->pwrofst2x_tbl_2g4[type][ch_grp]);
+        }
+    }
+    AICWFDBG(LOGINFO, "\npwrofst2x 5g: [0]:ofdm_lowrate, [1]:ofdm_highrate, [2]:ofdm_midrate\n"
+        "  chan=" "\t36-50" "\t51-64" "\t98-114" "\t115-130" "\t131-146" "\t147-166");
+    for (type = 0; type < 3; type++) {
+        AICWFDBG(LOGINFO, "\n  [%d] =", type);
+        for (ch_grp = 0; ch_grp < 6; ch_grp++) {
+            AICWFDBG(LOGINFO, "\t%d", txpwr_ofst2x->pwrofst2x_tbl_5g[type][ch_grp]);
+        }
+    }
+    AICWFDBG(LOGINFO, "\n");
+}
+
 void get_userconfig_txpwr_loss(txpwr_loss_conf_t *txpwr_loss)
 {
     txpwr_loss->loss_enable      = userconfig_info.txpwr_loss.loss_enable;
@@ -1947,12 +2122,33 @@ void rwnx_plat_nvram_set_value(char *command, char *value)
         userconfig_info.txpwr_lvl_v3.pwrlvl_11ax_5g[10] = rwnx_atoi(value);
     } else if (!strcmp(command,     "lvl_11ax_mcs11_5g")) {
         userconfig_info.txpwr_lvl_v3.pwrlvl_11ax_5g[11] = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_enable")) {
+        userconfig_info.txpwr_lvl_adj.enable = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_2g4_chan_1_4")) {
+        userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_2g4[0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_2g4_chan_5_9")) {
+        userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_2g4[1] = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_2g4_chan_10_13")) {
+        userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_2g4[2] = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_5g_chan_42")) {
+        userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_5g[0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_5g_chan_58")) {
+        userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_5g[1] = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_5g_chan_106")) {
+        userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_5g[2] = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_5g_chan_122")) {
+        userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_5g[3] = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_5g_chan_138")) {
+        userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_5g[4] = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_5g_chan_155")) {
+        userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_5g[5] = rwnx_atoi(value);
     } else if (!strcmp(command, "loss_enable")) {
         userconfig_info.txpwr_loss.loss_enable = rwnx_atoi(value);
     } else if (!strcmp(command, "loss_value")) {
         userconfig_info.txpwr_loss.loss_value = rwnx_atoi(value);
     } else if (!strcmp(command, "ofst_enable")) {
         userconfig_info.txpwr_ofst.enable = rwnx_atoi(value);
+        userconfig_info.txpwr_ofst2x.enable = rwnx_atoi(value);
     } else if (!strcmp(command, "ofst_chan_1_4")) {
         userconfig_info.txpwr_ofst.chan_1_4 = rwnx_atoi(value);
     } else if (!strcmp(command, "ofst_chan_5_9")) {
@@ -1967,6 +2163,60 @@ void rwnx_plat_nvram_set_value(char *command, char *value)
         userconfig_info.txpwr_ofst.chan_122_140 = rwnx_atoi(value);
     } else if (!strcmp(command, "ofst_chan_142_165")) {
         userconfig_info.txpwr_ofst.chan_142_165 = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_11b_chan_1_4")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_2g4[0][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_11b_chan_5_9")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_2g4[0][1] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_11b_chan_10_13")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_2g4[0][2] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_ofdm_highrate_chan_1_4")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_2g4[1][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_ofdm_highrate_chan_5_9")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_2g4[1][1] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_ofdm_highrate_chan_10_13")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_2g4[1][2] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_ofdm_lowrate_chan_1_4")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_2g4[2][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_ofdm_lowrate_chan_5_9")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_2g4[2][1] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_ofdm_lowrate_chan_10_13")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_2g4[2][2] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ofdm_lowrate_chan_42")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_5g[0][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ofdm_lowrate_chan_58")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_5g[0][1] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ofdm_lowrate_chan_106")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_5g[0][2] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ofdm_lowrate_chan_122")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_5g[0][3] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ofdm_lowrate_chan_138")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_5g[0][4] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ofdm_lowrate_chan_155")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_5g[0][5] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ofdm_highrate_chan_42")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_5g[1][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ofdm_highrate_chan_58")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_5g[1][1] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ofdm_highrate_chan_106")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_5g[1][2] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ofdm_highrate_chan_122")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_5g[1][3] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ofdm_highrate_chan_138")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_5g[1][4] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ofdm_highrate_chan_155")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_5g[1][5] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ofdm_midrate_chan_42")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_5g[2][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ofdm_midrate_chan_58")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_5g[2][1] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ofdm_midrate_chan_106")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_5g[2][2] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ofdm_midrate_chan_122")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_5g[2][3] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ofdm_midrate_chan_138")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_5g[2][4] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ofdm_midrate_chan_155")) {
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_5g[2][5] = rwnx_atoi(value);
     } else if (!strcmp(command, "xtal_enable")) {
         userconfig_info.xtal_cap.enable = rwnx_atoi(value);
     } else if (!strcmp(command, "xtal_cap")) {
@@ -1983,11 +2233,11 @@ void rwnx_plat_userconfig_parsing(char *buffer, int size)
 {
     int i = 0;
     int parse_state = 0;
-    char command[30];
+    char command[64];
     char value[100];
     int char_counter = 0;
 
-    memset(command, 0, 30);
+    memset(command, 0, 64);
     memset(value, 0, 100);
 
     for (i = 0; i < size; i++) {
@@ -2001,7 +2251,7 @@ void rwnx_plat_userconfig_parsing(char *buffer, int size)
                 }
             }
             //Reset command value and char_counter
-            memset(command, 0, 30);
+            memset(command, 0, 64);
             memset(value, 0, 100);
             char_counter = 0;
             parse_state = INIT;
@@ -2035,12 +2285,406 @@ void rwnx_plat_userconfig_parsing(char *buffer, int size)
             command[char_counter] = buffer[i];
             char_counter++;
         } else if (parse_state == GET_VALUE) {
+            if(buffer[i] != 0x2D && (buffer[i] < 0x30 || buffer[i] > 0x39)) {
+		continue;
+            }
             value[char_counter] = buffer[i];
             char_counter++;
         }
     }
 }
 
+#ifdef CONFIG_POWER_LIMIT
+#define GetLineFromBuffer(buffer)   strsep(&buffer, "\n")
+
+int isAllSpaceOrTab(uint8_t *data, uint8_t size)
+{
+    uint8_t cnt = 0, NumOfSpaceAndTab = 0;
+    while (size > cnt) {
+        if (data[cnt] == ' ' || data[cnt] == '\t' || data[cnt] == '\0')
+            ++NumOfSpaceAndTab;
+        ++cnt;
+    }
+    return size == NumOfSpaceAndTab;
+}
+
+int IsCommentString(char *szStr)
+{
+    if (*szStr == '#' && *(szStr + 1) == ' ')
+        return 1;
+    else
+        return 0;
+}
+
+int ParseQualifiedString(char *In, u32 *Start, char *Out, char LeftQualifier, char RightQualifier)
+{
+    u32 i = 0, j = 0;
+    char c = In[(*Start)++];
+    if (c != LeftQualifier)
+        return 0;
+    i = (*Start);
+    c = In[(*Start)++];
+    while (c != RightQualifier && c != '\0')
+        c = In[(*Start)++];
+    if (c == '\0')
+        return 0;
+    j = (*Start) - 2;
+    strncpy((char *)Out, (const char *)(In + i), j - i + 1);
+    return 1;
+}
+
+int GetU1ByteIntegerFromStringInDecimal(char *Str, u8 *pInt)
+{
+    u16 i = 0;
+    *pInt = 0;
+    while (Str[i] != '\0') {
+        if (Str[i] >= '0' && Str[i] <= '9') {
+            *pInt *= 10;
+            *pInt += (Str[i] - '0');
+        } else
+            return 0;
+        ++i;
+    }
+    return 1;
+}
+int GetS1ByteIntegerFromStringInDecimal(char *str, s8 *val)
+{
+    u8 negative = 0;
+    u16 i = 0;
+    *val = 0;
+    while (str[i] != '\0') {
+        if (i == 0 && (str[i] == '+' || str[i] == '-')) {
+            if (str[i] == '-')
+                negative = 1;
+        } else if (str[i] >= '0' && str[i] <= '9') {
+            *val *= 10;
+            *val += (str[i] - '0');
+        } else
+            return 0;
+        ++i;
+    }
+    if (negative)
+        *val = -*val;
+    return 1;
+}
+
+void rwnx_plat_powerlimit_parsing(char *buffer, int size, char *cc)
+{
+#define LD_STAGE_EXC_MAPPING    0
+#define LD_STAGE_TAB_DEFINE     1
+#define LD_STAGE_TAB_START      2
+#define LD_STAGE_COLUMN_DEFINE  3
+#define LD_STAGE_CH_ROW         4
+
+    uint8_t loadingStage = LD_STAGE_EXC_MAPPING;
+    uint32_t i = 0, forCnt = 0;
+    uint32_t i_cc;
+    char *szLine, *ptmp;
+    char band[10], colNumBuf[10];
+    uint8_t colNum = 0, colNum_cc = 255, band_cc = 0;
+    // clear powerlimit info at first
+    memset((void *)&powerlimit_info, 0, sizeof(powerlimit_info_t));
+    ptmp = buffer;
+    for (szLine = GetLineFromBuffer(ptmp); szLine != NULL; szLine = GetLineFromBuffer(ptmp)) {
+        if (isAllSpaceOrTab(szLine, sizeof(*szLine)))
+            continue;
+        if (IsCommentString(szLine))
+            continue;
+
+        if (loadingStage == LD_STAGE_EXC_MAPPING) {
+            if (szLine[0] == '#' || szLine[1] == '#') {
+                loadingStage = LD_STAGE_TAB_DEFINE;
+            } else {
+                continue;
+            }
+        }
+
+        if (loadingStage == LD_STAGE_TAB_DEFINE) {
+            /* read "##	2.4G" */
+            if (szLine[0] != '#' || szLine[1] != '#')
+                continue;
+
+            /* skip the space */
+            i = 2;
+            while (szLine[i] == ' ' || szLine[i] == '\t')
+                ++i;
+
+            szLine[--i] = ' '; /* return the space in front of the regulation info */
+
+            /* Parse the label of the table */
+            memset((void *)band, 0, 10);
+            if (!ParseQualifiedString(szLine, &i, band, ' ', ',')) {
+                AICWFDBG(LOGERROR, "Fail to parse band!\n");
+                goto exit;
+            }
+            if (strncmp(band, "2.4G", 4) == 0) {
+                band_cc = PHY_BAND_2G4;
+            } else if (strncmp(band, "5G", 2) == 0) {
+                band_cc = PHY_BAND_5G;
+            }
+            memset((void *) colNumBuf, 0, 10);
+            if (!ParseQualifiedString(szLine, &i, colNumBuf, '#', '#')) {
+                AICWFDBG(LOGERROR, "Fail to parse column number!\n");
+                goto exit;
+            }
+            if (!GetU1ByteIntegerFromStringInDecimal(colNumBuf, &colNum)) {
+                AICWFDBG(LOGERROR, "Column number \"%s\" is not unsigned decimal\n", colNumBuf);
+                goto exit;
+            }
+            if (colNum == 0) {
+                AICWFDBG(LOGERROR, "Column number is 0\n");
+                goto exit;
+            }
+
+            AICWFDBG(LOGINFO, "band=%s(%d)\n", band, band_cc);
+            loadingStage = LD_STAGE_TAB_START;
+        } else if (loadingStage == LD_STAGE_TAB_START) {
+            /* read "##	START" */
+            if (szLine[0] != '#' || szLine[1] != '#')
+                continue;
+
+            /* skip the space */
+            i = 2;
+            while (szLine[i] == ' ' || szLine[i] == '\t')
+                ++i;
+
+            if (strncmp((u8 *)(szLine + i), "START", 5)) {
+                AICWFDBG(LOGERROR, "Missing \"##   START\" label\n");
+                goto exit;
+            }
+
+            loadingStage = LD_STAGE_COLUMN_DEFINE;
+        } else if (loadingStage == LD_STAGE_COLUMN_DEFINE) {
+            /* read "##	CN	US" */
+            if (szLine[0] != '#' || szLine[1] != '#')
+                continue;
+
+            /* skip the space */
+            i = 2;
+            while (szLine[i] == ' ' || szLine[i] == '\t')
+                ++i;
+
+            for (forCnt = 0; forCnt < colNum; forCnt++) {
+                /* skip the space */
+                while (szLine[i] == ' ' || szLine[i] == '\t')
+                    i++;
+                i_cc = i;
+
+                while (szLine[i] != ' ' && szLine[i] != '\t' && szLine[i] != '\0')
+                    i++;
+
+                if ((i - i_cc) != 2) {
+                    AICWFDBG(LOGERROR, "CC len err\n");
+                    goto exit;
+                } else if ((szLine[i_cc] == cc[0]) && (szLine[i_cc + 1] == cc[1])) {
+                    AICWFDBG(LOGINFO, "CC matched: %s, col=%d\n", cc, forCnt);
+                    colNum_cc = forCnt;
+                    powerlimit_info.flags |= POWER_LIMIT_CC_MATCHED_BIT;
+                    break;
+                }
+            }
+
+            loadingStage = LD_STAGE_CH_ROW;
+        } else if (loadingStage == LD_STAGE_CH_ROW) {
+            char channel[10] = {0}, powerLimit[10] = {0};
+            u8 channel_num, powerLimit_val, cnt = 0;
+
+            /* the table ends */
+            if (szLine[0] == '#' && szLine[1] == '#') {
+                i = 2;
+                while (szLine[i] == ' ' || szLine[i] == '\t')
+                    ++i;
+
+                if (strncmp((u8 *)(szLine + i), "END", 3) == 0) {
+                    loadingStage = LD_STAGE_TAB_DEFINE;
+                    colNum = 0;
+                    continue;
+                } else {
+                    AICWFDBG(LOGERROR, "Missing \"##   END\" label\n");
+                    goto exit;
+                }
+            }
+
+            if ((szLine[0] != 'c' && szLine[0] != 'C') ||
+                (szLine[1] != 'h' && szLine[1] != 'H')
+            ) {
+                AICWFDBG(LOGERROR, "Wrong channel prefix: '%c','%c'(%d,%d)\n", szLine[0], szLine[1], szLine[0], szLine[1]);
+                continue;
+            }
+            i = 2;/* move to the  location behind 'h' */
+
+            /* load the channel number */
+            cnt = 0;
+            while (szLine[i] >= '0' && szLine[i] <= '9') {
+                channel[cnt] = szLine[i];
+                ++cnt;
+                ++i;
+            }
+
+            for (forCnt = 0; forCnt < colNum; ++forCnt) {
+                /* skip the space between channel number and the power limit value */
+                while (szLine[i] == ' ' || szLine[i] == '\t')
+                    ++i;
+
+                /* load the power limit value */
+                memset((void *)powerLimit, 0, 10);
+
+                if (szLine[i] == 'N' && szLine[i + 1] == 'A') {
+                    /*
+                    * means channel not available
+                    */
+                    sprintf(powerLimit, "%d", POWER_LIMIT_INVALID_VAL);
+                    i += 2;
+                } else if ((szLine[i] >= '0' && szLine[i] <= '9')
+                    || szLine[i] == '+' || szLine[i] == '-'
+                ) {
+                    /* case of dBm value */
+                    cnt = 0;
+                    while ((szLine[i] >= '0' && szLine[i] <= '9')
+                        || szLine[i] == '+' || szLine[i] == '-'
+                    ) {
+                        powerLimit[cnt] = szLine[i];
+                        ++cnt;
+                        ++i;
+                    }
+                } else {
+                    AICWFDBG(LOGERROR, "Wrong limit expression \"%c%c\"(%d, %d)\n"
+                        , szLine[i], szLine[i + 1], szLine[i], szLine[i + 1]);
+                    goto exit;
+                }
+
+                if (forCnt == colNum_cc) {
+                    /* store the power limit value */
+                    if (GetU1ByteIntegerFromStringInDecimal((char *)channel, &channel_num) == 0
+                        || GetS1ByteIntegerFromStringInDecimal((char *)powerLimit, &powerLimit_val) == 0
+                    ) {
+                        AICWFDBG(LOGERROR, "Illegal index of power limit table [ch %s][val %s]\n", channel, powerLimit);
+                        goto exit;
+                    }
+
+                    if (band_cc == PHY_BAND_2G4) {
+                        uint8_t cur_idx = powerlimit_info.txpwr_lmt.ch_cnt_2g4;
+                        AICWFDBG(LOGINFO, "[%d]: ch=%s, pwr=%s\n", cur_idx, channel, powerLimit);
+                        if (cur_idx < MAC_DOMAINCHANNEL_24G_MAX) {
+                            powerlimit_info.txpwr_lmt.ch_num_2g4[cur_idx] = channel_num;
+                            powerlimit_info.txpwr_lmt.max_pwr_2g4[cur_idx] = powerLimit_val;
+                            powerlimit_info.txpwr_lmt.ch_cnt_2g4++;
+                        } else {
+                            AICWFDBG(LOGERROR, "band %d chan_cnt reached %d\n", band_cc, MAC_DOMAINCHANNEL_24G_MAX);
+                            AICWFDBG(LOGERROR, "channel=%s(%d) powerLimit=%s(%d)\n", channel, channel_num, powerLimit, powerLimit_val);
+                        }
+                    } else if (band_cc == PHY_BAND_5G) {
+                        uint8_t cur_idx = powerlimit_info.txpwr_lmt.ch_cnt_5g;
+                        AICWFDBG(LOGINFO, "[%d]: ch=%s, pwr=%s\n", cur_idx, channel, powerLimit);
+                        if (cur_idx < MAC_DOMAINCHANNEL_5G_MAX) {
+                            powerlimit_info.txpwr_lmt.ch_num_5g[cur_idx] = channel_num;
+                            powerlimit_info.txpwr_lmt.max_pwr_5g[cur_idx] = powerLimit_val;
+                            powerlimit_info.txpwr_lmt.ch_cnt_5g++;
+                        } else {
+                            AICWFDBG(LOGERROR, "band %d chan_cnt reached %d\n", band_cc, MAC_DOMAINCHANNEL_5G_MAX);
+                            AICWFDBG(LOGERROR, "channel=%s(%d) powerLimit=%s(%d)\n", channel, channel_num, powerLimit, powerLimit_val);
+                        }
+                    }
+                    break;
+                }
+            }
+        }
+    }
+exit:
+    return;
+}
+
+/// 5G lower bound freq
+#define PHY_FREQ_5G 5000
+
+uint16_t phy_channel_to_freq(uint8_t band, int channel)
+{
+    if ((band == PHY_BAND_2G4) && (channel >= 1) && (channel <= 14)) {
+        if (channel == 14)
+            return 2484;
+        else
+            return 2407 + channel * 5;
+    } else if ((band == PHY_BAND_5G) && (channel >= 1) && (channel <= 165)) {
+        return PHY_FREQ_5G + channel * 5;
+    }
+    return 0;
+}
+
+int8_t get_powerlimit_by_freq(uint8_t band, uint16_t freq)
+{
+    int8_t ret = POWER_LIMIT_INVALID_VAL;
+    uint8_t idx;
+    if (powerlimit_info.flags & POWER_LIMIT_CC_MATCHED_BIT) {
+        if (band == PHY_BAND_2G4) {
+            uint8_t idx_cnt = powerlimit_info.txpwr_lmt.ch_cnt_2g4;
+            for (idx = 0; idx < idx_cnt; idx++) {
+                int ch_num = powerlimit_info.txpwr_lmt.ch_num_2g4[idx];
+                uint16_t freq_tmp = phy_channel_to_freq(PHY_BAND_2G4, ch_num);
+                if (freq == freq_tmp) {
+                    ret = powerlimit_info.txpwr_lmt.max_pwr_2g4[idx];
+                    //AICWFDBG(LOGINFO, "[%d]: ch=%d(freq=%d), pwr=%d\n", idx, ch_num, freq, ret);
+                    break;
+                }
+            }
+            if (idx == idx_cnt) {
+                AICWFDBG(LOGERROR, "powerlimit search failed: band=%d freq=%d\n", band, freq);
+            }
+        } else if (band == PHY_BAND_5G) {
+            uint8_t idx_cnt = powerlimit_info.txpwr_lmt.ch_cnt_5g;
+            for (idx = 0; idx < idx_cnt; idx++) {
+                int ch_num = powerlimit_info.txpwr_lmt.ch_num_5g[idx];
+                uint16_t freq_tmp = phy_channel_to_freq(PHY_BAND_5G, ch_num);
+                if (freq == freq_tmp) {
+                    ret = powerlimit_info.txpwr_lmt.max_pwr_5g[idx];
+                    //AICWFDBG(LOGINFO, "[%d]: ch=%d(freq=%d), pwr=%d\n", idx, ch_num, freq, ret);
+                    break;
+                }
+            }
+            if (idx == idx_cnt) {
+                AICWFDBG(LOGERROR, "powerlimit search failed: band=%d freq=%d\n", band, freq);
+            }
+        }
+    }
+    return ret;
+}
+
+int8_t get_powerlimit_by_chnum(uint8_t chnum)
+{
+    int8_t ret = POWER_LIMIT_INVALID_VAL;
+    uint8_t idx;
+    if (powerlimit_info.flags & POWER_LIMIT_CC_MATCHED_BIT) {
+        if (chnum <= 14) {
+            uint8_t idx_cnt = powerlimit_info.txpwr_lmt.ch_cnt_2g4;
+            for (idx = 0; idx < idx_cnt; idx++) {
+                uint8_t ch_num = powerlimit_info.txpwr_lmt.ch_num_2g4[idx];
+                if (chnum == ch_num) {
+                    ret = powerlimit_info.txpwr_lmt.max_pwr_2g4[idx];
+                    //AICWFDBG(LOGINFO, "[%d]: ch=%d, pwr=%d\n", idx, ch_num, ret);
+                    break;
+                }
+            }
+            if (idx == idx_cnt) {
+                AICWFDBG(LOGERROR, "powerlimit search failed: chnum=%d\n", chnum);
+            }
+        } else if (chnum <= 165) {
+            uint8_t idx_cnt = powerlimit_info.txpwr_lmt.ch_cnt_5g;
+            for (idx = 0; idx < idx_cnt; idx++) {
+                int ch_num = powerlimit_info.txpwr_lmt.ch_num_5g[idx];
+                if (chnum == ch_num) {
+                    ret = powerlimit_info.txpwr_lmt.max_pwr_5g[idx];
+                    //AICWFDBG(LOGINFO, "[%d]: ch=%d, pwr=%d\n", idx, ch_num, ret);
+                    break;
+                }
+            }
+            if (idx == idx_cnt) {
+                AICWFDBG(LOGERROR, "powerlimit search failed: chnum=%d\n", chnum);
+            }
+        }
+    }
+    return ret;
+}
+#endif
+
 /**
  * rwnx_plat_userconfig_load  ---Load aic_userconfig.txt
  *@filename name of config
@@ -2049,10 +2693,19 @@ static int rwnx_plat_userconfig_load(struct rwnx_hw *rwnx_hw) {
 
 	if(rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DC){
 		rwnx_plat_userconfig_load_8800dc(rwnx_hw);
+        #ifdef CONFIG_POWER_LIMIT
+        rwnx_plat_powerlimit_load_8800dcdw(rwnx_hw, PRODUCT_ID_AIC8800DC);
+        #endif
 	}else if(rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800DW){
         rwnx_plat_userconfig_load_8800dw(rwnx_hw);
+        #ifdef CONFIG_POWER_LIMIT
+        rwnx_plat_powerlimit_load_8800dcdw(rwnx_hw, PRODUCT_ID_AIC8800DW);
+        #endif
     }else if(rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81){
         rwnx_plat_userconfig_load_8800d80(rwnx_hw);
+    }else if(rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D81X2 ||
+        rwnx_hw->usbdev->chipid == PRODUCT_ID_AIC8800D89X2){
+        rwnx_plat_userconfig_load_8800d80x2(rwnx_hw);
     }
 
 	return 0;
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.h
index 2df790ce8d2c..e957763b73fe 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.h
@@ -34,10 +34,12 @@
 #endif
 
 #define RWNX_FCU_FW_NAME                "fcuram.bin"
-#ifdef CONFIG_DPD
-#define FW_DPDRESULT_NAME_8800DC        "aic_dpdresult_8800dc.bin"
+#if (defined(CONFIG_DPD) && !defined(CONFIG_FORCE_DPD_CALIB))
+#define FW_DPDRESULT_NAME_8800DC        "aic_dpdresult_lite_8800dc.bin"
 #endif
 
+#define POWER_LEVEL_INVALID_VAL     (127)
+
 enum {
     FW_NORMAL_MODE          = 0,
     FW_RFTEST_MODE          = 1,
@@ -127,8 +129,16 @@ int is_file_exist(char* name);
 void get_userconfig_txpwr_lvl_in_fdrv(txpwr_lvl_conf_t *txpwr_lvl);
 void get_userconfig_txpwr_lvl_v2_in_fdrv(txpwr_lvl_conf_v2_t *txpwr_lvl_v2);
 void get_userconfig_txpwr_lvl_v3_in_fdrv(txpwr_lvl_conf_v3_t *txpwr_lvl_v3);
+void get_userconfig_txpwr_lvl_adj_in_fdrv(txpwr_lvl_adj_conf_t *txpwr_lvl_adj);
 void get_userconfig_txpwr_ofst_in_fdrv(txpwr_ofst_conf_t *txpwr_ofst);
+void get_userconfig_txpwr_ofst2x_in_fdrv(txpwr_ofst2x_conf_t *txpwr_ofst2x);
 void get_userconfig_txpwr_loss(txpwr_loss_conf_t *txpwr_loss);
+void rwnx_plat_userconfig_parsing(char *buffer, int size);
+#ifdef CONFIG_POWER_LIMIT
+void rwnx_plat_powerlimit_parsing(char *buffer, int size, char *cc);
+int8_t get_powerlimit_by_freq(uint8_t band, uint16_t freq);
+int8_t get_powerlimit_by_chnum(uint8_t chnum);
+#endif
 int rwnx_platform_register_drv(void);
 void rwnx_platform_unregister_drv(void);
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.c
index 3dbbc0b9d8c5..f817eb5f422e 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.c
@@ -47,44 +47,23 @@ u16 tx_legrates_lut_rate[] = {
     540
 };
 
-
-u16 legrates_lut_rate[] = {
-    10 ,
-    20 ,
-    55 ,
-    110 ,
-    0 ,
-    0 ,
-    0 ,
-    0 ,
-    480 ,
-    240 ,
-    120 ,
-    60 ,
-    540 ,
-    360 ,
-    180 ,
-    90
-};
-
-
-const u8 legrates_lut[] = {
-    0,                          /* 0 */
-    1,                          /* 1 */
-    2,                          /* 2 */
-    3,                          /* 3 */
-    -1,                         /* 4 */
-    -1,                         /* 5 */
-    -1,                         /* 6 */
-    -1,                         /* 7 */
-    10,                         /* 8 */
-    8,                          /* 9 */
-    6,                          /* 10 */
-    4,                          /* 11 */
-    11,                         /* 12 */
-    9,                          /* 13 */
-    7,                          /* 14 */
-    5                           /* 15 */
+struct rwnx_legrate legrates_lut[] = {
+	[0] = { .idx = 0, .rate = 10},
+	[1] = { .idx = 1, .rate = 20},
+	[2] = { .idx = 2, .rate = 55},
+	[3] = { .idx = 3, .rate = 110},
+	[4] = { .idx = -1, .rate = 0},
+	[5] = { .idx = -1, .rate = 0},
+	[6] = { .idx = -1, .rate = 0},
+	[7] = { .idx = -1, .rate = 0},
+	[8] = { .idx = 10, .rate = 480},
+	[9] = { .idx = 8, .rate = 240},
+	[10] = { .idx = 6, .rate = 120},
+	[11] = { .idx = 4, .rate = 60},
+	[12] = { .idx = 11, .rate = 540},
+	[13] = { .idx = 9, .rate = 360},
+	[14] = { .idx = 7, .rate = 180},
+	[15] = { .idx = 5, .rate = 90},
 };
 
 struct vendor_radiotap_hdr {
@@ -113,8 +92,13 @@ struct rwnx_vif *rwnx_rx_get_vif(struct rwnx_hw *rwnx_hw, int vif_idx)
 
     if (vif_idx < NX_VIRT_DEV_MAX) {
         rwnx_vif = rwnx_hw->vif_table[vif_idx];
-        if (!rwnx_vif || !rwnx_vif->up)
+        if(!rwnx_vif){
+            AICWFDBG(LOGERROR, "%s rwnx_hw->vif_table[%d] NULL\r\n", __func__, vif_idx);
+            return NULL;
+        }else if(!rwnx_vif->up){
+            AICWFDBG(LOGERROR, "%s rwnx_hw->vif_table[%d] is down\r\n", __func__, vif_idx);
             return NULL;
+        }
     }
 
     return rwnx_vif;
@@ -280,7 +264,7 @@ static void rwnx_rx_statistic(struct rwnx_hw *rwnx_hw, struct hw_rxhdr *hw_rxhdr
                 break;
         }
     } else {
-        int idx = legrates_lut[rxvect->leg_rate];
+        int idx = legrates_lut[rxvect->leg_rate].idx;
         if (idx < 4) {
             rate_idx = idx * 2 + rxvect->pre_type;
         } else {
@@ -409,6 +393,12 @@ static void rwnx_rx_data_skb_forward(struct rwnx_hw *rwnx_hw, struct rwnx_vif *r
 	rx_skb->protocol = eth_type_trans(rx_skb, rwnx_vif->ndev);
 	memset(rx_skb->cb, 0, sizeof(rx_skb->cb));
 	REG_SW_SET_PROFILING(rwnx_hw, SW_PROF_IEEE80211RX);
+
+
+#ifdef CONFIG_FILTER_TCP_ACK
+	filter_rx_tcp_ack(rwnx_hw, rx_skb->data, cpu_to_le16(rx_skb->len));
+#endif
+
 	#ifdef CONFIG_RX_NETIF_RECV_SKB //modify by aic
 	local_bh_disable();
 	netif_receive_skb(rx_skb);
@@ -453,8 +443,13 @@ static bool rwnx_rx_data_skb(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_vif,
 
     if (amsdu) {
         int count;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
         ieee80211_amsdu_to_8023s(skb, &list, rwnx_vif->ndev->dev_addr,
                                  RWNX_VIF_TYPE(rwnx_vif), 0, NULL, NULL, false);
+#else
+        ieee80211_amsdu_to_8023s(skb, &list, rwnx_vif->ndev->dev_addr,
+                                 RWNX_VIF_TYPE(rwnx_vif), 0, NULL, NULL);
+#endif
 
         count = skb_queue_len(&list);
         if (count > ARRAY_SIZE(rwnx_hw->stats.amsdus_rx))
@@ -584,6 +579,12 @@ static bool rwnx_rx_data_skb(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_vif,
 #endif
             memset(rx_skb->cb, 0, sizeof(rx_skb->cb));
             REG_SW_SET_PROFILING(rwnx_hw, SW_PROF_IEEE80211RX);
+
+
+#ifdef CONFIG_FILTER_TCP_ACK
+            filter_rx_tcp_ack(rwnx_hw, rx_skb->data, cpu_to_le16(rx_skb->len));
+#endif
+
             #ifdef CONFIG_RX_NETIF_RECV_SKB //modify by aic
             local_bh_disable();
             netif_receive_skb(rx_skb);
@@ -996,7 +997,7 @@ static void rwnx_rx_add_rtap_hdr(struct rwnx_hw* rwnx_hw,
         struct ieee80211_supported_band* band =
                 rwnx_hw->wiphy->bands[phy_info->phy_band];
         rtap->it_present |= cpu_to_le32(1 << IEEE80211_RADIOTAP_RATE);
-        BUG_ON((rate_idx = legrates_lut[rxvect->leg_rate]) == -1);
+        BUG_ON((rate_idx = legrates_lut[rxvect->leg_rate].idx) == -1);
         if (phy_info->phy_band == NL80211_BAND_5GHZ)
             rate_idx -= 4;  /* rwnx_ratetable_5ghz[0].hw_value == 4 */
         *pos = DIV_ROUND_UP(band->bitrates[rate_idx].bitrate, 5);
@@ -1230,7 +1231,11 @@ static int rwnx_rx_monitor(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_vif,
     skb->ip_summed = CHECKSUM_UNNECESSARY;
     skb->pkt_type = PACKET_OTHERHOST;
     skb->protocol = htons(ETH_P_802_2);
-    
+
+#ifdef CONFIG_FILTER_TCP_ACK
+    filter_rx_tcp_ack(rwnx_hw, skb->data, cpu_to_le16(skb->len));
+#endif
+
     local_bh_disable();
     netif_receive_skb(skb);
     local_bh_enable();
@@ -1262,10 +1267,13 @@ void arpoffload_proc(struct sk_buff *skb, struct rwnx_vif *rwnx_vif)
                             if (option[offset+2] == DHCP_ACK) {
                                 AICWFDBG(LOGDEBUG, "dhcp:   ack\n");
                                 dhcped = 1;
-                                if(rwnx_vif->sta.group_cipher_type == WLAN_CIPHER_SUITE_CCMP)
-                                    rwnx_send_arpoffload_en_req(rwnx_vif->rwnx_hw, rwnx_vif, dhcph->yiaddr, 1);
+				if (rwnx_vif->sta.paired_cipher_type == WLAN_CIPHER_SUITE_CCMP || \
+					rwnx_vif->sta.paired_cipher_type == WLAN_CIPHER_SUITE_AES_CMAC || \
+					((rwnx_vif->sta.group_cipher_type == 0xff) && \
+					 (rwnx_vif->sta.paired_cipher_type == 0xff)))
+					rwnx_send_arpoffload_en_req(rwnx_vif->rwnx_hw, rwnx_vif, dhcph->yiaddr, 1);
                                 else
-                                    rwnx_send_arpoffload_en_req(rwnx_vif->rwnx_hw, rwnx_vif, dhcph->yiaddr, 0);
+					rwnx_send_arpoffload_en_req(rwnx_vif->rwnx_hw, rwnx_vif, dhcph->yiaddr, 0);
                              }
                         }
                         offset += 2 + option[offset+1];
@@ -1523,6 +1531,10 @@ int reord_single_frame_ind(struct aicwf_rx_priv *rx_priv, struct recv_msdu *prfr
 #endif
     memset(skb->cb, 0, sizeof(skb->cb));
 
+#ifdef CONFIG_FILTER_TCP_ACK
+     filter_rx_tcp_ack(rwnx_vif->rwnx_hw, skb->data, cpu_to_le16(skb->len));
+#endif
+
 #ifdef CONFIG_RX_NETIF_RECV_SKB//AIDEN test
     local_bh_disable();
 	netif_receive_skb(skb);
@@ -1762,12 +1774,13 @@ int reord_process_unit(struct aicwf_rx_priv *rx_priv, struct sk_buff *skb, u16 s
 
     spin_lock_bh(&preorder_ctrl->reord_list_lock);
     if (reord_need_check(preorder_ctrl, pframe->seq_num)) {
+#if 1
 		if(pframe->rx_data[42] == 0x80){//this is rtp package
 			if(pframe->seq_num == preorder_ctrl->ind_sn){
-				printk("%s pframe->seq_num1:%d \r\n", __func__, pframe->seq_num);
+				//printk("%s pframe->seq_num1:%d \r\n", __func__, pframe->seq_num);
 	        	reord_single_frame_ind(rx_priv, pframe);//not need to reorder
 			}else{
-				printk("%s free pframe->seq_num:%d \r\n", __func__, pframe->seq_num);
+				//printk("%s free pframe->seq_num:%d \r\n", __func__, pframe->seq_num);
 			    if (pframe->pkt){
 			        dev_kfree_skb(pframe->pkt);
 			        pframe->pkt = NULL;
@@ -1778,6 +1791,9 @@ int reord_process_unit(struct aicwf_rx_priv *rx_priv, struct sk_buff *skb, u16 s
 			//printk("%s pframe->seq_num2:%d \r\n", __func__, pframe->seq_num);
 			reord_single_frame_ind(rx_priv, pframe);//not need to reorder
 		}
+#else
+        reord_single_frame_ind(rx_priv, pframe);//not need to reor
+#endif
 
         spin_unlock_bh(&preorder_ctrl->reord_list_lock);
 		return 0;
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.h
index e5480cdc90d4..690ad41220c7 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.h
@@ -326,8 +326,12 @@ struct hw_rxhdr {
     u32    pattern;
 };
 
-extern const u8 legrates_lut[];
-extern u16 legrates_lut_rate[];
+struct rwnx_legrate {
+	int idx;
+	int rate;
+};
+
+extern struct rwnx_legrate legrates_lut[];
 extern u16 tx_legrates_lut_rate[];
 
 struct DHCPInfo {
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_strs.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_strs.c
index bafb440515de..1e52871c5758 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_strs.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_strs.c
@@ -130,6 +130,11 @@ static const char *const rwnx_mmid2str[MSG_I(MM_MAX)] = {
     [MSG_I(MM_SET_VENDOR_HWCONFIG_CFM)]        = "MM_SET_VENDOR_HWCONFIG_CFM",
     [MSG_I(MM_GET_FW_VERSION_REQ)]  = "MM_GET_FW_VERSION_REQ",
     [MSG_I(MM_GET_FW_VERSION_CFM)]  = "MM_GET_FW_VERSION_CFM",
+    [MSG_I(MM_SET_RESUME_RESTORE_REQ)]          = "MM_SET_RESUME_RESTORE_REQ",
+    [MSG_I(MM_SET_RESUME_RESTORE_CFM)]          = "MM_SET_RESUME_RESTORE_CFM",
+    [MSG_I(MM_GET_WIFI_DISABLE_REQ)]            = "MM_GET_WIFI_DISABLE_REQ",
+    [MSG_I(MM_GET_WIFI_DISABLE_CFM)]            = "MM_GET_WIFI_DISABLE_CFM",
+    [MSG_I(MM_CFG_RSSI_CFM)]                    = "MM_CFG_RSSI_CFM",
 };
 
 static const char *const rwnx_dbgid2str[MSG_I(DBG_MAX)] = {
@@ -212,6 +217,7 @@ static const char *const rwnx_smid2str[MSG_I(SM_MAX)] = {
     [MSG_I(SM_DISCONNECT_IND)]    = "SM_DISCONNECT_IND",
     [MSG_I(SM_EXTERNAL_AUTH_REQUIRED_IND)] = "SM_EXTERNAL_AUTH_REQUIRED_IND",
     [MSG_I(SM_EXTERNAL_AUTH_REQUIRED_RSP)] = "SM_EXTERNAL_AUTH_REQUIRED_RSP",
+    [MSG_I(SM_EXTERNAL_AUTH_REQUIRED_RSP_CFM)] = "SM_EXTERNAL_AUTH_REQUIRED_RSP_CFM",
 };
 
 static const char *const rwnx_apmid2str[MSG_I(APM_MAX)] = {
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tx.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tx.c
index 5e3ac1e83184..74a0573a425a 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tx.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tx.c
@@ -677,7 +677,14 @@ void rwnx_tx_push(struct rwnx_hw *rwnx_hw, struct rwnx_txhdr *txhdr, int flags)
         sw_txhdr->need_cfm = 1;
         sw_txhdr->desc.host.status_desc_addr = ((1<<31) | rwnx_hw->usb_env.txdesc_free_idx[0]);
         aicwf_usb_host_txdesc_push(&(rwnx_hw->usb_env), 0, (long)(skb));
-        AICWFDBG(LOGINFO, "need cfm ethertype:%8x,user_idx=%d, skb=%p sta_idx:%d\n", 
+        if((sw_txhdr->desc.host.flags & TXU_CNTRL_MGMT))
+		AICWFDBG(LOGINFO, "need cfm mgmt:%x,user_idx=%d, skb=%p sta_idx:%d\n",
+			*(skb->data+sw_txhdr->headroom),
+			rwnx_hw->usb_env.txdesc_free_idx[0],
+			skb,
+			sw_txhdr->desc.host.staid);
+	else
+		AICWFDBG(LOGINFO, "need cfm ethertype:%8x,user_idx=%d, skb=%p sta_idx:%d\n",
 			sw_txhdr->desc.host.ethertype, 
 			rwnx_hw->usb_env.txdesc_free_idx[0], 
 			skb,
@@ -1227,6 +1234,179 @@ int aic_br_client_tx(struct rwnx_vif *vif, struct sk_buff **pskb)
 #endif /* CONFIG_BR_SUPPORT */
 
 
+#ifdef CONFIG_FILTER_TCP_ACK
+/* return:
+ *      0, msg buf freed by the real driver
+ *      others, skb need free by the caller,remember not use msg->skb!
+ */
+
+int intf_tx(struct rwnx_hw *priv,struct msg_buf *msg)
+{
+	struct rwnx_vif *rwnx_vif = msg->rwnx_vif;
+	struct rwnx_hw *rwnx_hw = rwnx_vif->rwnx_hw;
+	struct rwnx_txhdr *txhdr;
+	struct rwnx_sw_txhdr *sw_txhdr;
+	struct txdesc_api *desc;
+	struct rwnx_sta *sta;
+	struct rwnx_txq *txq;
+	int headroom;
+	//int max_headroom;
+	int hdr_pads;
+
+	u16 frame_len;
+	u16 frame_oft;
+	u8 tid;
+	struct sk_buff *skb=msg->skb;
+	struct ethhdr eth_t;
+
+	move_tcpack_msg(rwnx_hw,msg);
+	kfree(msg);
+
+	memcpy(&eth_t, skb->data, sizeof(struct ethhdr));
+
+	/* Get the STA id and TID information */
+	sta = rwnx_get_tx_priv(rwnx_vif, skb, &tid);
+	if (!sta)
+		goto free;
+
+	txq = rwnx_txq_sta_get(sta, tid, rwnx_hw);
+	if (txq->idx == TXQ_INACTIVE)
+		goto free;
+
+#ifdef CONFIG_RWNX_AMSDUS_TX
+	if (rwnx_amsdu_add_subframe(rwnx_hw, skb, sta, txq))
+		return NETDEV_TX_OK;
+#endif
+
+#ifdef CONFIG_BR_SUPPORT
+		 if (1) {//(check_fwstate(&padapter->mlmepriv, WIFI_STATION_STATE | WIFI_ADHOC_STATE) == _TRUE) {
+			 void *br_port = NULL;
+
+	#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
+			 br_port = rwnx_vif->ndev->br_port;
+	#else
+			 rcu_read_lock();
+			 br_port = rcu_dereference(rwnx_vif->ndev->rx_handler_data);
+			 rcu_read_unlock();
+	#endif
+
+			 if (br_port) {
+				 s32 res = aic_br_client_tx(rwnx_vif, &skb);
+				 if (res == -1) {
+					 goto free;
+				 }
+			 }
+		 }
+#endif /* CONFIG_BR_SUPPORT */
+
+
+	/* Retrieve the pointer to the Ethernet data */
+	// eth = (struct ethhdr *)skb->data;
+
+	skb_pull(skb, 14);
+	//hdr_pads	= RWNX_SWTXHDR_ALIGN_PADS((long)eth);
+	hdr_pads  = RWNX_SWTXHDR_ALIGN_PADS((long)skb->data);
+	headroom  = sizeof(struct rwnx_txhdr) + hdr_pads;
+
+	skb_push(skb, headroom);
+
+	txhdr = (struct rwnx_txhdr *)skb->data;
+	sw_txhdr = kmem_cache_alloc(rwnx_hw->sw_txhdr_cache, GFP_ATOMIC);
+	if (unlikely(sw_txhdr == NULL))
+		goto free;
+	txhdr->sw_hdr = sw_txhdr;
+	desc = &sw_txhdr->desc;
+
+	frame_len = (u16)skb->len - headroom;// - sizeof(*eth);
+
+	sw_txhdr->txq		= txq;
+	sw_txhdr->frame_len = frame_len;
+	sw_txhdr->rwnx_sta	= sta;
+	sw_txhdr->rwnx_vif	= rwnx_vif;
+	sw_txhdr->skb		= skb;
+	sw_txhdr->headroom	= headroom;
+	sw_txhdr->map_len	= skb->len - offsetof(struct rwnx_txhdr, hw_hdr);
+
+#ifdef CONFIG_RWNX_AMSDUS_TX
+	sw_txhdr->amsdu.len = 0;
+	sw_txhdr->amsdu.nb = 0;
+#endif
+	sw_txhdr->raw_frame = 0;
+	sw_txhdr->fixed_rate = 0;
+
+	// Fill-in the descriptor
+	memcpy(&desc->host.eth_dest_addr, eth_t.h_dest, ETH_ALEN);
+	memcpy(&desc->host.eth_src_addr, eth_t.h_source, ETH_ALEN);
+	desc->host.ethertype = eth_t.h_proto;
+	desc->host.staid = sta->sta_idx;
+	desc->host.tid = tid;
+	if (unlikely(rwnx_vif->wdev.iftype == NL80211_IFTYPE_AP_VLAN))
+		desc->host.vif_idx = rwnx_vif->ap_vlan.master->vif_index;
+	else
+		desc->host.vif_idx = rwnx_vif->vif_index;
+
+	if (rwnx_vif->use_4addr && (sta->sta_idx < NX_REMOTE_STA_MAX))
+		desc->host.flags = TXU_CNTRL_USE_4ADDR;
+	else
+		desc->host.flags = 0;
+
+	if ((rwnx_vif->tdls_status == TDLS_LINK_ACTIVE) &&
+		rwnx_vif->sta.tdls_sta &&
+		(memcmp(desc->host.eth_dest_addr.array, rwnx_vif->sta.tdls_sta->mac_addr, ETH_ALEN) == 0)) {
+		desc->host.flags |= TXU_CNTRL_TDLS;
+		rwnx_vif->sta.tdls_sta->tdls.last_tid = desc->host.tid;
+		//rwnx_vif->sta.tdls_sta->tdls.last_sn = desc->host.sn;
+	}
+
+	if (rwnx_vif->wdev.iftype == NL80211_IFTYPE_MESH_POINT) {
+		if (rwnx_vif->is_resending) {
+			desc->host.flags |= TXU_CNTRL_MESH_FWD;
+		}
+	}
+
+#ifdef CONFIG_RWNX_SPLIT_TX_BUF
+	desc->host.packet_len[0] = frame_len;
+#else
+	desc->host.packet_len = frame_len;
+#endif
+
+	txhdr->hw_hdr.cfm.status.value = 0;
+
+	if (unlikely(rwnx_prep_tx(rwnx_hw, txhdr))) {
+		kmem_cache_free(rwnx_hw->sw_txhdr_cache, sw_txhdr);
+		skb_pull(skb, headroom);
+		dev_kfree_skb_any(skb);
+		return NETDEV_TX_BUSY;
+	}
+
+	/* Fill-in TX descriptor */
+	frame_oft = sizeof(struct rwnx_txhdr) - offsetof(struct rwnx_txhdr, hw_hdr)
+				+ hdr_pads;// + sizeof(*eth);
+#if 0
+#ifdef CONFIG_RWNX_SPLIT_TX_BUF
+	desc->host.packet_addr[0] = sw_txhdr->dma_addr + frame_oft;
+	desc->host.packet_cnt = 1;
+#else
+	desc->host.packet_addr = sw_txhdr->dma_addr + frame_oft;
+#endif
+#endif
+	desc->host.status_desc_addr = sw_txhdr->dma_addr;
+
+	spin_lock_bh(&rwnx_hw->tx_lock);
+	if (rwnx_txq_queue_skb(skb, txq, rwnx_hw, false))
+		rwnx_hwq_process(rwnx_hw, txq->hwq);
+	spin_unlock_bh(&rwnx_hw->tx_lock);
+
+	return 0;//NETDEV_TX_OK
+
+free:
+	dev_kfree_skb_any(skb);
+
+	return 0;//NETDEV_TX_OK
+}
+#endif
+
+
 /**
  * netdev_tx_t (*ndo_start_xmit)(struct sk_buff *skb,
  *                               struct net_device *dev);
@@ -1257,12 +1437,14 @@ netdev_tx_t rwnx_start_xmit(struct sk_buff *skb, struct net_device *dev)
     u8 tid;
     
     struct ethhdr eth_t;
+#ifdef CONFIG_FILTER_TCP_ACK
+    struct msg_buf *msgbuf;
+#endif
 
 #ifdef CONFIG_ONE_TXQ
     skb->queue_mapping = rwnx_select_txq(rwnx_vif, skb);
 #endif
 
-    memcpy(&eth_t, skb->data, sizeof(struct ethhdr));
 
     sk_pacing_shift_update(skb->sk, rwnx_hw->tcp_pacing_shift);
     max_headroom = sizeof(struct rwnx_txhdr);
@@ -1280,6 +1462,24 @@ netdev_tx_t rwnx_start_xmit(struct sk_buff *skb, struct net_device *dev)
         skb = newskb;
     }
 
+	if(skb->priority < 3)
+		skb->priority = 0;
+
+#ifdef CONFIG_FILTER_TCP_ACK
+	if(cpu_to_le16(skb->len) <= MAX_TCP_ACK){
+        msgbuf=intf_tcp_alloc_msg(msgbuf);
+        msgbuf->rwnx_vif=rwnx_vif;
+        msgbuf->skb=skb;
+        if(filter_send_tcp_ack(rwnx_hw,msgbuf,skb->data,cpu_to_le16(skb->len))){
+            return NETDEV_TX_OK;
+        }else{
+            move_tcpack_msg(rwnx_hw,msgbuf);
+            kfree(msgbuf);
+        }
+	}
+#endif
+    memcpy(&eth_t, skb->data, sizeof(struct ethhdr));
+
     /* Get the STA id and TID information */
     sta = rwnx_get_tx_priv(rwnx_vif, skb, &tid);
     if (!sta)
@@ -2100,8 +2300,9 @@ int rwnx_txdatacfm(void *pthis, void *host_id)
     }
 #endif /* CONFIG_RWNX_AMSDUS_TX */
 
+    headroom = sw_txhdr->headroom;
     kmem_cache_free(rwnx_hw->sw_txhdr_cache, sw_txhdr);
-    skb_pull(skb, sw_txhdr->headroom);
+    skb_pull(skb, headroom);
     consume_skb(skb);
 
     return 0;
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_txq.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_txq.c
index 7ffb99e845e4..5b7159725f3d 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_txq.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_txq.c
@@ -1256,7 +1256,9 @@ void rwnx_hwq_process(struct rwnx_hw *rwnx_hw, struct rwnx_hwq *hwq)
         /* sanity check for debug */
         BUG_ON(!(txq->status & RWNX_TXQ_IN_HWQ_LIST));
 		if(txq->idx == TXQ_INACTIVE){
-			printk("%s txq->idx == TXQ_INACTIVE \r\n", __func__);
+			AICWFDBG(LOGERROR, "%s txq->idx == TXQ_INACTIVE \r\n", __func__);
+            rwnx_txq_del_from_hw_list(txq);
+            rwnx_txq_flush(rwnx_hw, txq);            
 			continue;
 		}
         BUG_ON(txq->idx == TXQ_INACTIVE);
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_utils.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_utils.h
index e41185bd4a88..402fb3905269 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_utils.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_utils.h
@@ -15,12 +15,6 @@
 #include "lmac_msg.h"
 #include "aicwf_debug.h"
 
-#ifdef ANDROID_PLATFORM 
-#define HIGH_KERNEL_VERSION KERNEL_VERSION(5, 15, 41)
-#else
-#define HIGH_KERNEL_VERSION KERNEL_VERSION(6, 0, 0)
-#endif
-
 
 #if 0
 #ifdef CONFIG_RWNX_DBG
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_version_gen.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_version_gen.h
index 6d51acfb5c5b..0025c8a06322 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_version_gen.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_version_gen.h
@@ -1,5 +1,5 @@
 #define RWNX_VERS_REV "1a4b0054d2M (master)"
 #define RWNX_VERS_MOD "6.4.3.0"
 #define RWNX_VERS_BANNER "rwnx v6.4.3.0 - 1a4b0054d2M (master)"
-#define RELEASE_DATE "2023_0707_1001"
+#define RELEASE_DATE "2024_0712_e2a932c1"
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_wakelock.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_wakelock.c
new file mode 100644
index 000000000000..90e7ad8729a3
--- /dev/null
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_wakelock.c
@@ -0,0 +1,92 @@
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/platform_device.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 2, 0)
+#include <linux/pm_wakeirq.h>
+#else
+#include <linux/pm_wakeup.h>
+#endif
+#include "rwnx_defs.h"
+#include "rwnx_wakelock.h"
+
+struct wakeup_source *rwnx_wakeup_init(const char *name)
+{
+	struct wakeup_source *ws;
+	ws = wakeup_source_create(name);
+	wakeup_source_add(ws);
+	return ws;
+}
+
+void rwnx_wakeup_deinit(struct wakeup_source *ws)
+{
+	if (ws && ws->active)
+		__pm_relax(ws);
+	wakeup_source_remove(ws);
+	wakeup_source_destroy(ws);
+}
+
+struct wakeup_source *rwnx_wakeup_register(struct device *dev, const char *name)
+{
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0)
+	return wakeup_source_register(dev, name);
+#else
+
+#if defined(CONFIG_PLATFORM_ROCKCHIP2) || defined(CONFIG_PLATFORM_ROCKCHIP)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)
+    return wakeup_source_register(dev, name);
+#else
+    return wakeup_source_register(name);
+#endif
+
+#else
+	return wakeup_source_register(name);
+#endif//#if defined(CONFIG_PLATFORM_ROCKCHIP2) || defined(CONFIG_PLATFORM_ROCKCHIP)
+
+#endif//LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0)
+}
+
+void rwnx_wakeup_unregister(struct wakeup_source *ws)
+{
+	if (ws && ws->active)
+		__pm_relax(ws);
+	wakeup_source_unregister(ws);
+}
+
+void rwnx_wakeup_lock(struct wakeup_source *ws)
+{
+    AICWFDBG(LOGDEBUG, "%s enter \r\n", __func__);
+	__pm_stay_awake(ws);
+}
+
+void rwnx_wakeup_unlock(struct wakeup_source *ws)
+{
+    AICWFDBG(LOGDEBUG, "%s enter \r\n", __func__);
+	__pm_relax(ws);
+}
+
+void rwnx_wakeup_lock_timeout(struct wakeup_source *ws, unsigned int msec)
+{
+	__pm_wakeup_event(ws, msec);
+}
+
+void aicwf_wakeup_lock_init(struct rwnx_hw *rwnx_hw)
+{
+	rwnx_hw->ws_tx = rwnx_wakeup_init("rwnx_tx_wakelock");
+	rwnx_hw->ws_rx = rwnx_wakeup_init("rwnx_rx_wakelock");
+    rwnx_hw->ws_irqrx = rwnx_wakeup_init("rwnx_irqrx_wakelock");
+	rwnx_hw->ws_pwrctrl = rwnx_wakeup_init("rwnx_pwrcrl_wakelock");
+}
+
+void aicwf_wakeup_lock_deinit(struct rwnx_hw *rwnx_hw)
+{
+	rwnx_wakeup_deinit(rwnx_hw->ws_tx);
+	rwnx_wakeup_deinit(rwnx_hw->ws_rx);
+	rwnx_wakeup_deinit(rwnx_hw->ws_irqrx);
+	rwnx_wakeup_deinit(rwnx_hw->ws_pwrctrl);
+	rwnx_hw->ws_tx = NULL;
+	rwnx_hw->ws_rx = NULL;
+	rwnx_hw->ws_irqrx = NULL;
+	rwnx_hw->ws_pwrctrl = NULL;
+}
+
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_wakelock.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_wakelock.h
new file mode 100644
index 000000000000..9c9655a46be2
--- /dev/null
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_wakelock.h
@@ -0,0 +1,21 @@
+#ifndef __RWNX_WAKELOCK_H
+#define __RWNX_WAKELOCK_H
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/platform_device.h>
+
+struct wakeup_source *rwnx_wakeup_init(const char *name);
+void rwnx_wakeup_deinit(struct wakeup_source *ws);
+
+struct wakeup_source *rwnx_wakeup_register(struct device *dev, const char *name);
+void rwnx_wakeup_unregister(struct wakeup_source *ws);
+
+void rwnx_wakeup_lock(struct wakeup_source *ws);
+void rwnx_wakeup_unlock(struct wakeup_source *ws);
+void rwnx_wakeup_lock_timeout(struct wakeup_source *ws, unsigned int msec);
+
+void aicwf_wakeup_lock_init(struct rwnx_hw *rwnx_hw);
+void aicwf_wakeup_lock_deinit(struct rwnx_hw *rwnx_hw);
+
+#endif
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/.gitignore b/drivers/net/wireless/aic8800/aic_load_fw/.gitignore
new file mode 100644
index 000000000000..6ebacd59953a
--- /dev/null
+++ b/drivers/net/wireless/aic8800/aic_load_fw/.gitignore
@@ -0,0 +1,11 @@
+*.o
+*.ko
+*.order
+*.symvers
+*.o.d
+*.o.cmd
+*.ko.cmd
+*.mod
+*.mod.c*
+
+.tmp_versions/
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/Makefile b/drivers/net/wireless/aic8800/aic_load_fw/Makefile
index e6444e8ce23d..482318c1865a 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/Makefile
+++ b/drivers/net/wireless/aic8800/aic_load_fw/Makefile
@@ -5,16 +5,22 @@ CONFIG_USB_MSG_EP = y
 CONFIG_USB_NO_TRANS_DMA_MAP = n
 CONFIG_M2D_OTA_AUTO_SUPPORT = n
 CONFIG_LINK_DET_5G = y
+CONFIG_FOR_IPCAM = n
+CONFIG_USB_SUSPEND_REBOOT_TIME = n
+CONFIG_SUPPORT_USB_SUSP = n
+
+
 # Need to set fw path in BOARD_KERNEL_CMDLINE
-CONFIG_USE_FW_REQUEST = n
-CONFIG_PREALLOC_RX_SKB = n
-CONFIG_PREALLOC_TXQ = n
+CONFIG_USE_FW_REQUEST ?= n
+CONFIG_PREALLOC_RX_SKB ?= n
+CONFIG_PREALLOC_TXQ ?= y
 
 # Platform support list
-CONFIG_PLATFORM_ROCKCHIP ?= y
+CONFIG_PLATFORM_ROCKCHIP ?= n
 CONFIG_PLATFORM_ALLWINNER ?= n
 CONFIG_PLATFORM_AMLOGIC ?= n
-CONFIG_PLATFORM_UBUNTU ?= n
+CONFIG_PLATFORM_HI ?= n
+CONFIG_PLATFORM_UBUNTU ?= y
 
 CONFIG_AIC_LOADFW_SUPPORT = m
 MODULE_NAME = aic_load_fw
@@ -30,9 +36,12 @@ ccflags-$(CONFIG_USB_MSG_EP) += -DCONFIG_USB_MSG_EP
 ccflags-$(CONFIG_USB_NO_TRANS_DMA_MAP) += -DCONFIG_USB_NO_TRANS_DMA_MAP
 ccflags-$(CONFIG_M2D_OTA_AUTO_SUPPORT) += -DCONFIG_M2D_OTA_AUTO_SUPPORT
 ccflags-$(CONFIG_LINK_DET_5G) += -DCONFIG_LINK_DET_5G
+ccflags-$(CONFIG_FOR_IPCAM) += -DCONFIG_FOR_IPCAM
 ccflags-$(CONFIG_USE_FW_REQUEST) += -DCONFIG_USE_FW_REQUEST
 ccflags-$(CONFIG_PREALLOC_RX_SKB) += -DCONFIG_PREALLOC_RX_SKB
 ccflags-$(CONFIG_PREALLOC_TXQ) += -DCONFIG_PREALLOC_TXQ
+ccflags-$(CONFIG_USB_SUSPEND_REBOOT_TIME) += -DCONFIG_USB_SUSPEND_REBOOT_TIME
+ccflags-$(CONFIG_SUPPORT_USB_SUSP) += -DCONFIG_SUPPORT_USB_SUSP
 
 
 obj-$(CONFIG_AIC_LOADFW_SUPPORT) := $(MODULE_NAME).o
@@ -42,6 +51,7 @@ $(MODULE_NAME)-y := 	aic_bluetooth_main.o \
 					aic_txrxif.o \
 					aicbluetooth_cmds.o \
 					aic_compat_8800d80.o \
+					aic_compat_8800d80x2.o \
 					md5.o
 
 $(MODULE_NAME)-$(CONFIG_PREALLOC_RX_SKB)	 += aicwf_rx_prealloc.o
@@ -83,7 +93,8 @@ KDIR  := /lib/modules/$(shell uname -r)/build
 PWD   := $(shell pwd)
 KVER := $(shell uname -r)
 MODDESTDIR := /lib/modules/$(KVER)/kernel/drivers/net/wireless/aic8800
-ARCH := x86_64
+SUBARCH = $(shell uname -m | sed -e s/i.86/i386/ -e s/armv.l/arm/ -e s/aarch64/arm64/)
+ARCH ?= $(SUBARCH)
 CROSS_COMPILE :=
 endif
 
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aic_bluetooth_main.c b/drivers/net/wireless/aic8800/aic_load_fw/aic_bluetooth_main.c
index 8eed551d5437..be05052bb891 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aic_bluetooth_main.c
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aic_bluetooth_main.c
@@ -1,71 +1,81 @@
-#include <linux/module.h>
-#include <linux/inetdevice.h>
-#include "aicwf_usb.h"
-#include "rwnx_version_gen.h"
-#include "aicwf_rx_prealloc.h"
-#include "aicwf_debug.h"
-#include "aicwf_txq_prealloc.h"
-
-
-#define DRV_CONFIG_FW_NAME             "fw.bin"
-#define DRV_DESCRIPTION  "AIC BLUETOOTH"
-#define DRV_COPYRIGHT    "Copyright(c) 2015-2020 AICSemi"
-#define DRV_AUTHOR       "AICSemi"
-#define DRV_VERS_MOD "1.0"
-
-int testmode = FW_NORMAL_MODE;
-int adap_test = 0;
-char paringid[100];
-int n_para = 1;
-int ble_scan_wakeup_reboot_time = 1000;
-int aicwf_dbg_level = LOGERROR|LOGINFO|LOGDEBUG|LOGTRACE;
-uint32_t ad_data_filter_mask = 0;
-
-module_param(aicwf_dbg_level, int, 0660);
-module_param(ble_scan_wakeup_reboot_time, int, 0660);
-module_param(testmode, int, 0660);
-module_param(adap_test, int, 0660);
-module_param_string(paringid, paringid, 100, 0660);
-
-
-static void aicsmac_driver_register(void)
-{
-    aicwf_usb_register();
-}
-
-static int __init aic_bluetooth_mod_init(void)
-{
-    printk("%s \n", __func__);
-    printk("RELEASE DATE:%s \r\n", RELEASE_DATE);
-#ifdef CONFIG_PREALLOC_RX_SKB
-    aicwf_prealloc_init();
-#endif
-
-    aicsmac_driver_register();
-    return 0;
-}
-
-static void __exit aic_bluetooth_mod_exit(void)
-{
-    printk("%s\n", __func__);
-    aicwf_usb_exit();
-    
-#ifdef CONFIG_PREALLOC_RX_SKB
-    aicwf_prealloc_exit();
-#endif
-
-#ifdef CONFIG_PREALLOC_TXQ
-    aicwf_prealloc_txq_free();
-#endif
-}
-
-
-module_init(aic_bluetooth_mod_init);
-module_exit(aic_bluetooth_mod_exit);
-
-MODULE_FIRMWARE(DRV_CONFIG_FW_NAME);
-MODULE_DESCRIPTION(DRV_DESCRIPTION);
-MODULE_VERSION(DRV_VERS_MOD);
-MODULE_AUTHOR(DRV_COPYRIGHT " " DRV_AUTHOR);
-MODULE_LICENSE("GPL");
-
+#include <linux/module.h>
+#include <linux/inetdevice.h>
+#include <linux/version.h>
+
+#include "aicwf_usb.h"
+#include "rwnx_version_gen.h"
+#include "aicwf_rx_prealloc.h"
+#include "aicwf_debug.h"
+#include "aicwf_txq_prealloc.h"
+
+
+#define DRV_CONFIG_FW_NAME             "fw.bin"
+#define DRV_DESCRIPTION  "AIC BLUETOOTH"
+#define DRV_COPYRIGHT    "Copyright(c) 2015-2020 AICSemi"
+#define DRV_AUTHOR       "AICSemi"
+#define DRV_VERS_MOD "1.0"
+
+int testmode = FW_NORMAL_MODE;
+int adap_test = 0;
+char paringid[100];
+int n_para = 1;
+int ble_scan_wakeup_reboot_time = 1000;
+int aicwf_dbg_level = LOGERROR|LOGINFO|LOGDEBUG|LOGTRACE;
+int flash_erase_len = 0x400000;
+uint32_t ad_data_filter_mask = 0;
+uint32_t gpio_num = 2;//default select gpiob2 for fw_wakeup_host
+uint32_t gpio_dft_lvl = 0;//0:defalut pull down,  1:default pull up
+
+module_param(aicwf_dbg_level, int, 0660);
+module_param(ble_scan_wakeup_reboot_time, int, 0660);
+module_param(testmode, int, 0660);
+module_param(adap_test, int, 0660);
+module_param_string(paringid, paringid, 100, 0660);
+module_param(flash_erase_len, int, 0660);
+
+
+static void aicsmac_driver_register(void)
+{
+    aicwf_usb_register();
+}
+
+static int __init aic_bluetooth_mod_init(void)
+{
+    printk("%s \n", __func__);
+    printk("RELEASE DATE:%s \r\n", RELEASE_DATE);
+#ifdef CONFIG_PREALLOC_RX_SKB
+    aicwf_prealloc_init();
+#endif
+
+    aicsmac_driver_register();
+    return 0;
+}
+
+static void __exit aic_bluetooth_mod_exit(void)
+{
+    printk("%s\n", __func__);
+    aicwf_usb_exit();
+    
+#ifdef CONFIG_PREALLOC_RX_SKB
+    aicwf_prealloc_exit();
+#endif
+
+#ifdef CONFIG_PREALLOC_TXQ
+    aicwf_prealloc_txq_free();
+#endif
+}
+
+
+module_init(aic_bluetooth_mod_init);
+module_exit(aic_bluetooth_mod_exit);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0)
+MODULE_IMPORT_NS(VFS_internal_I_am_really_a_filesystem_and_am_NOT_a_driver);
+#endif
+
+MODULE_FIRMWARE(DRV_CONFIG_FW_NAME);
+MODULE_DESCRIPTION(DRV_DESCRIPTION);
+MODULE_VERSION(DRV_VERS_MOD);
+MODULE_AUTHOR(DRV_COPYRIGHT " " DRV_AUTHOR);
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80.c b/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80.c
index b37ad772bcd6..3c12d2b04bb1 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80.c
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80.c
@@ -3,6 +3,10 @@
 #include "aicbluetooth.h"
 #include "aic_compat_8800d80.h"
 #include "aicwf_debug.h"
+extern int ble_scan_wakeup_reboot_time;
+extern uint32_t ad_data_filter_mask;
+extern uint32_t gpio_num;//default select gpiob2 for fw_wakeup_host
+extern uint32_t gpio_dft_lvl;//0:defalut pull down,  1:default pull up
 
 int rwnx_plat_bin_fw_upload_2(struct aic_usb_dev *usbdev, u32 fw_addr,
                                char *filename);
@@ -12,7 +16,8 @@ void rwnx_plat_userconfig_parsing(char *buffer, int size);
 void rwnx_release_firmware_common(u32** buffer);
 
 extern int testmode;
-extern int chip_id;
+extern u8 chip_id;
+extern u8 chip_mcu_id;
 
 typedef u32 (*array2_tbl_t)[2];
 
@@ -34,6 +39,16 @@ typedef struct {
 #define AIC_PATCH_OFST(mem) ((size_t) &((aic_patch_t *)0)->mem)
 #define AIC_PATCH_ADDR(mem) ((u32) (aic_patch_str_base + AIC_PATCH_OFST(mem)))
 
+#define USER_PWROFST_COVER_CALIB_FLAG	0x01U
+#define USER_CHAN_MAX_TXPWR_EN_FLAG     (0x01U << 1)
+#define USER_TX_USE_ANA_F_FLAG          (0x01U << 2)
+
+#define CFG_PWROFST_COVER_CALIB     1
+#define CFG_USER_CHAN_MAX_TXPWR_EN  0
+#define CFG_USER_TX_USE_ANA_F       0
+
+#define CFG_USER_EXT_FLAGS_EN   (CFG_PWROFST_COVER_CALIB || CFG_USER_CHAN_MAX_TXPWR_EN || CFG_USER_TX_USE_ANA_F)
+
 u32 patch_tbl_d80[][2] =
 {
     #ifdef USE_5G
@@ -41,13 +56,32 @@ u32 patch_tbl_d80[][2] =
     #else
     {0x00b4, 0xf3010000},
     #endif
+#ifdef CONFIG_PLATFORM_HI
+    {0x0170, 0x00010001},//rx aggr counter
+#else
+    {0x0170, 0x0001000A},//rx aggr counter
+#endif
+
+    #if CFG_USER_EXT_FLAGS_EN
+    {0x0188, 0x00000000
+	#if CFG_PWROFST_COVER_CALIB
+	| USER_PWROFST_COVER_CALIB_FLAG
+	#endif
+        #if CFG_USER_CHAN_MAX_TXPWR_EN
+        | USER_CHAN_MAX_TXPWR_EN_FLAG
+        #endif
+        #if CFG_USER_TX_USE_ANA_F
+        | USER_TX_USE_ANA_F_FLAG
+        #endif
+    }, // user_ext_flags
+    #endif
 };
 
 //adap test
 u32 adaptivity_patch_tbl_d80[][2] = {
     {0x000C, 0x0000320A}, //linkloss_thd
     {0x009C, 0x00000000}, //ac_param_conf
-    {0x0154, 0x00010000}, //tx_adaptivity_en
+    {0x0168, 0x00010000}, //tx_adaptivity_en
 };
 
 u32 syscfg_tbl_masked_8800d80[][3] = {
@@ -61,11 +95,16 @@ u32 syscfg_tbl_8800d80[][2] = {
 
 extern int adap_test;
 
+#define NEW_PATCH_BUFFER_MAP    1
+
 int aicwf_patch_config_8800d80(struct aic_usb_dev *usb_dev)
 {
     u32 rd_patch_addr;
     u32 aic_patch_addr;
     u32 config_base, aic_patch_str_base;
+    #if (NEW_PATCH_BUFFER_MAP)
+    u32 patch_buff_addr, patch_buff_base, rd_version_addr, rd_version_val;
+    #endif
     uint32_t start_addr = 0x001D7000;
     u32 patch_addr = start_addr;
     u32 patch_cnt = sizeof(patch_tbl_d80) / 4 / 2;
@@ -76,6 +115,7 @@ int aicwf_patch_config_8800d80(struct aic_usb_dev *usb_dev)
     int adap_patch_cnt = 0;
 
     if (adap_test) {
+        AICWFDBG(LOGINFO, "%s adap test \r\n", __func__);
         adap_patch_cnt = sizeof(adaptivity_patch_tbl_d80)/sizeof(u32)/2;
     }
 
@@ -101,6 +141,32 @@ int aicwf_patch_config_8800d80(struct aic_usb_dev *usb_dev)
     AICWFDBG(LOGERROR, "%x=%x\n", rd_patch_addr_cfm.memaddr, rd_patch_addr_cfm.memdata);
     aic_patch_str_base = rd_patch_addr_cfm.memdata;
 
+    #if (NEW_PATCH_BUFFER_MAP)
+    if (chip_id == CHIP_REV_U01) {
+        rd_version_addr = RAM_FMAC_FW_ADDR_8800D80 + 0x01C;
+    } else {
+        rd_version_addr = RAM_FMAC_FW_ADDR_8800D80_U02 + 0x01C;
+    }
+    if ((ret = rwnx_send_dbg_mem_read_req(usb_dev, rd_version_addr, &rd_patch_addr_cfm))) {
+        AICWFDBG(LOGERROR, "version val[0x%x] rd fail: %d\n", rd_version_addr, ret);
+        return ret;
+    }
+    rd_version_val = rd_patch_addr_cfm.memdata;
+    AICWFDBG(LOGINFO, "rd_version_val=%08X\n", rd_version_val);
+    usb_dev->fw_version_uint = rd_version_val;
+    if (rd_version_val > 0x06090100) {
+        patch_buff_addr = rd_patch_addr + 12;
+        ret = rwnx_send_dbg_mem_read_req(usb_dev, patch_buff_addr, &rd_patch_addr_cfm);
+        if (ret) {
+            AICWFDBG(LOGERROR, "patch buf rd fail\n");
+            return ret;
+        }
+        AICWFDBG(LOGINFO, "%x=%x\n", rd_patch_addr_cfm.memaddr, rd_patch_addr_cfm.memdata);
+        patch_buff_base = rd_patch_addr_cfm.memdata;
+        patch_addr = start_addr = patch_buff_base;
+    }
+    #endif
+
     if ((ret = rwnx_send_dbg_mem_write_req(usb_dev, AIC_PATCH_ADDR(magic_num), AIC_PATCH_MAGIG_NUM))) {
         AICWFDBG(LOGERROR, "maigic_num[0x%x] write fail: %d\n", AIC_PATCH_ADDR(magic_num), ret);
         return ret;
@@ -225,8 +291,11 @@ int system_config_8800d80(struct aic_usb_dev *usb_dev){
 			printk("%x rd fail: %d\n", mem_addr, ret);
 			return ret;
 		}
+        if (((rd_mem_addr_cfm.memdata >> 25) & 0x01UL) == 0x00UL) {
+            chip_mcu_id = 1;
+        }
 		chip_id = (u8)(rd_mem_addr_cfm.memdata >> 16);
-		printk("chip_id=%x\n", chip_id);
+		printk("chip_id=%x, chip_mcu_id = %d\n", chip_id, chip_mcu_id);
     #if 1
 		syscfg_num = sizeof(syscfg_tbl_8800d80) / sizeof(u32) / 2;
 		for (cnt = 0; cnt < syscfg_num; cnt++) {
@@ -249,21 +318,77 @@ int system_config_8800d80(struct aic_usb_dev *usb_dev){
     return 0;
 }
 
-int aicfw_download_fw_8800d80(struct aic_usb_dev *usb_dev){
+
+int aicfw_download_fw_8800d80(struct aic_usb_dev *usb_dev)
+{
+    struct aicbt_patch_table *head = NULL;
+    struct aicbt_patch_info_t patch_info = {
+        .info_len          = 0,
+        .adid_addrinf      = 0,
+        .addr_adid         = 0,
+        .patch_addrinf     = 0,
+        .addr_patch        = 0,
+        .reset_addr        = 0,
+        .reset_val         = 0,
+        .adid_flag_addr    = 0,
+        .adid_flag         = 0,
+    };
+
+    int i = 0;
+
+    if (chip_id == CHIP_REV_U01) {
+        head = aicbt_patch_table_alloc(usb_dev, FW_PATCH_TABLE_NAME_8800D80);
+    } else {
+        head = aicbt_patch_table_alloc(usb_dev, FW_PATCH_TABLE_NAME_8800D80_U02);
+    }
+    if (head == NULL){
+        printk("aicbt_patch_table_alloc fail\n");
+        return -1;
+    }
+
+    if(head == NULL){
+        return -1;
+    }
+    if (chip_id == CHIP_REV_U01) {
+        patch_info.addr_adid = FW_RAM_ADID_BASE_ADDR_8800D80;
+        patch_info.addr_patch = FW_RAM_PATCH_BASE_ADDR_8800D80;
+    } else if (chip_id == CHIP_REV_U02 || chip_id == CHIP_REV_U03) {
+        patch_info.addr_adid = FW_RAM_ADID_BASE_ADDR_8800D80_U02;
+        patch_info.addr_patch = FW_RAM_PATCH_BASE_ADDR_8800D80_U02;
+    }
+    aicbt_patch_info_unpack(&patch_info, head);
+    if(patch_info.info_len == 0) {
+        printk("%s, aicbt_patch_info_unpack fail\n", __func__);
+        return -1;
+    }
+
+    printk("addr_adid 0x%x, addr_patch 0x%x\n", patch_info.addr_adid, patch_info.addr_patch);
+
     if(testmode == FW_NORMAL_MODE){
-		if (chip_id != CHIP_REV_U01){
-			if(rwnx_plat_bin_fw_upload_android(usb_dev, FW_RAM_ADID_BASE_ADDR_8800D80_U02, FW_ADID_BASE_NAME_8800D80_U02)) {
-				return -1;
-			}
-			if(rwnx_plat_bin_fw_upload_android(usb_dev, FW_RAM_PATCH_BASE_ADDR_8800D80_U02, FW_PATCH_BASE_NAME_8800D80_U02)) {
-				return -1;
-			}
-			if (rwnx_plat_bin_fw_patch_table_upload_android(usb_dev, FW_PATCH_TABLE_NAME_8800D80_U02)) {
-				return -1;
-			}
-			if(rwnx_plat_bin_fw_upload_android(usb_dev, RAM_FMAC_FW_ADDR_8800D80_U02, FW_BASE_NAME_8800D80_U02)) {
-				return -1;
-			}
+
+        if (chip_id != CHIP_REV_U01){
+            if(rwnx_plat_bin_fw_upload_android(usb_dev, patch_info.addr_adid, FW_ADID_BASE_NAME_8800D80_U02)) {
+                return -1;
+            }
+            if(rwnx_plat_bin_fw_upload_android(usb_dev, patch_info.addr_patch, FW_PATCH_BASE_NAME_8800D80_U02)) {
+                return -1;
+            }
+            #if 0
+            if (rwnx_plat_bin_fw_patch_table_upload_android(usb_dev, FW_PATCH_TABLE_NAME_8800D80_U02)) {
+                return -1;
+            }
+            #else
+            if (aicbt_patch_table_load(usb_dev, head)) {
+                return -1;
+            }
+            #endif
+            if (IS_CHIP_ID_H()){
+                if(rwnx_plat_bin_fw_upload_android(usb_dev, RAM_FMAC_FW_ADDR_8800D80_U02, FW_BASE_NAME_8800D80_H_U02))
+                    return -1;
+            } else {
+                if(rwnx_plat_bin_fw_upload_android(usb_dev, RAM_FMAC_FW_ADDR_8800D80_U02, FW_BASE_NAME_8800D80_U02))
+                    return -1;
+            }
             #if 0
             if(rwnx_plat_bin_fw_upload_android(usb_dev, FW_RAM_CALIBMODE_ADDR_8800D80_U02, FW_CALIBMODE_NAME_8800D80_U02)) {
                 return -1;
@@ -274,39 +399,60 @@ int aicfw_download_fw_8800d80(struct aic_usb_dev *usb_dev){
             if (aicwf_patch_config_8800d80(usb_dev)) {
                 return -1;
             }
-			if (rwnx_send_dbg_start_app_req(usb_dev, RAM_FMAC_FW_ADDR_8800D80_U02, HOST_START_APP_AUTO)) {
-				return -1;
-			}
-		}else {
-			if(rwnx_plat_bin_fw_upload_android(usb_dev, FW_RAM_ADID_BASE_ADDR_8800D80, FW_ADID_BASE_NAME_8800D80)) {
-				return -1;
-			}
-			if(rwnx_plat_bin_fw_upload_android(usb_dev, FW_RAM_PATCH_BASE_ADDR_8800D80, FW_PATCH_BASE_NAME_8800D80)) {
-				return -1;
-			}
-			if (rwnx_plat_bin_fw_patch_table_upload_android(usb_dev, FW_PATCH_TABLE_NAME_8800D80)) {
-				return -1;
-			}
-                        if(rwnx_plat_bin_fw_upload_android(usb_dev, RAM_FMAC_FW_ADDR_8800D80, FW_BASE_NAME_8800D80)) {
-				return -1;
-                        }
-		        if (rwnx_send_dbg_start_app_req(usb_dev, RAM_FMAC_FW_ADDR_8800D80, HOST_START_APP_AUTO)) {
-				return -1;
+            if (rwnx_send_dbg_start_app_req(usb_dev, RAM_FMAC_FW_ADDR_8800D80_U02, HOST_START_APP_AUTO)) {
+                return -1;
+            }
+        }else {
+            if(rwnx_plat_bin_fw_upload_android(usb_dev, patch_info.addr_adid, FW_ADID_BASE_NAME_8800D80)) {
+                return -1;
+            }
+            if(rwnx_plat_bin_fw_upload_android(usb_dev, patch_info.addr_patch, FW_PATCH_BASE_NAME_8800D80)) {
+                return -1;
+            }
+            #if 0
+            if (rwnx_plat_bin_fw_patch_table_upload_android(usb_dev, FW_PATCH_TABLE_NAME_8800D80)) {
+                return -1;
+            }
+            #else
+            if (aicbt_patch_table_load(usb_dev, head)) {
+                return -1;
+            }
+            #endif
+            if(rwnx_plat_bin_fw_upload_android(usb_dev, RAM_FMAC_FW_ADDR_8800D80, FW_BASE_NAME_8800D80)) {
+                return -1;
+             }
+            if (rwnx_send_dbg_start_app_req(usb_dev, RAM_FMAC_FW_ADDR_8800D80, HOST_START_APP_AUTO)) {
+                return -1;
+            }
         }
-		}
     }else if(testmode == FW_TEST_MODE){
-	    if (chip_id != CHIP_REV_U01){
+        if (chip_id != CHIP_REV_U01){
 
-			if(rwnx_plat_bin_fw_upload_android(usb_dev, FW_RAM_ADID_BASE_ADDR_8800D80_U02, FW_ADID_BASE_NAME_8800D80_U02)) {
-				return -1;
-			}
+            if(rwnx_plat_bin_fw_upload_android(usb_dev, patch_info.addr_adid, FW_ADID_BASE_NAME_8800D80_U02)) {
+                return -1;
+            }
 
-			if(rwnx_plat_bin_fw_upload_android(usb_dev, FW_RAM_PATCH_BASE_ADDR_8800D80_U02, FW_PATCH_BASE_NAME_8800D80_U02)) {
-				return -1;
-			}
-			if (rwnx_plat_bin_fw_patch_table_upload_android(usb_dev, FW_PATCH_TABLE_NAME_8800D80_U02)) {
-				return -1;
-			}
+            if(rwnx_plat_bin_fw_upload_android(usb_dev, patch_info.addr_patch, FW_PATCH_BASE_NAME_8800D80_U02)) {
+                return -1;
+            }
+#if 0
+            if (rwnx_plat_bin_fw_patch_table_upload_android(usb_dev, FW_PATCH_TABLE_NAME_8800D80_U02)) {
+                return -1;
+            }
+#else
+            if (aicbt_patch_table_load(usb_dev, head)) {
+                return -1;
+            }
+#endif
+
+            if (chip_mcu_id) {
+                int ret = 0;
+                ret = rwnx_plat_flash_bin_upload_android(usb_dev, FLASH_BIN_ADDR_8800M80, FLASH_BIN_8800M80);
+                if (ret && ret!= ENOENT) {
+                    AICWFDBG(LOGERROR,"%s flash bin download fail \r\n", __func__);
+                    return -1;
+                }
+            }
 
 			if(rwnx_plat_bin_fw_upload_android(usb_dev, RAM_FMAC_RF_FW_ADDR_8800D80_U02, FW_RF_BASE_NAME_8800D80_U02)) {
 				AICWFDBG(LOGERROR,"%s wifi fw download fail \r\n", __func__);
@@ -316,15 +462,109 @@ int aicfw_download_fw_8800d80(struct aic_usb_dev *usb_dev){
 				return -1;
 			}
 	    } else {
-                        if(rwnx_plat_bin_fw_upload_android(usb_dev, RAM_FMAC_RF_FW_ADDR_8800D80, FW_RF_BASE_NAME_8800D80)) {
-                         AICWFDBG(LOGERROR,"%s wifi fw download fail \r\n", __func__);
-                                return -1;
-                        }
-                        if (rwnx_send_dbg_start_app_req(usb_dev, RAM_FMAC_RF_FW_ADDR_8800D80, HOST_START_APP_AUTO)) {
-                                return -1;
-                        }
+            if(rwnx_plat_bin_fw_upload_android(usb_dev, RAM_FMAC_RF_FW_ADDR_8800D80, FW_RF_BASE_NAME_8800D80)) {
+             AICWFDBG(LOGERROR,"%s wifi fw download fail \r\n", __func__);
+                    return -1;
+            }
+            if (rwnx_send_dbg_start_app_req(usb_dev, RAM_FMAC_RF_FW_ADDR_8800D80, HOST_START_APP_AUTO)) {
+                    return -1;
+            }
 	    }
-    }
+    }else if(testmode == FW_BLE_SCAN_AD_FILTER_MODE){
+/*
+            data and ad_data_filter_mask instructions for use
+            ex.
+            data[18] = {0x46,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x30,0xff,0xff,0xff,0x43,0x52,0x45,0x4c,0x42};
+            mask = 1100 0000 0111 1111 1100 0000 0000 0000 = 0xc07fc000
+
+            data  = 0x46,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x30,0xff,0xff,0xff,0x43,0x52,0x45,0x4c,0x42
+            mask =  1      1       0     0     0    0     0     0    0     1      1     1    1    1      1      1      1      1      0     0...... fill 0
+
+            data & mask = "0x46 0x00" 0x00 0x00 0x00 0x00 0x00 0x00 0x00 "0x30 0xff 0xff 0x43 0x52 0x45 0x4c 0x42"
+            using data & mask value condition to wakeup host_wake_bt gpio
+*/
+            struct ble_wakeup_param_t* wakeup_param = (struct ble_wakeup_param_t*)kmalloc(sizeof(struct ble_wakeup_param_t), GFP_KERNEL);
+            uint32_t *write_blocks = (uint32_t *)wakeup_param;
+
+            printk("%s ble scan wakeup \r\n", __func__);
+
+            memset(wakeup_param, 0, sizeof(struct ble_wakeup_param_t));
+            rwnx_plat_bin_fw_upload_android(usb_dev, RAM_FW_BLE_SCAN_WAKEUP_ADDR_8800D80, FW_BLE_SCAN_AD_FILTER_NAME);
+            wakeup_param->magic_num = 0x53454C42;//magic_num
+            wakeup_param->delay_scan_to = 1000;//delay start scan time(ms)
+            wakeup_param->reboot_to = ble_scan_wakeup_reboot_time;//reboot time
+            /******************************************************************/
+            ///gpio_trigger_idx : 0    if wakeup_param->gpio_dft_lvl[0]=0xfe,this idx will be invalid.
+            wakeup_param->gpio_num[0] = gpio_num;////default select gpiob2 for fw_wakeup_host
+            wakeup_param->gpio_dft_lvl[0] = gpio_dft_lvl;////0:defalut pull down,  1:default pull up
+            ///gpio_trigger_idx : 1    if wakeup_param->gpio_dft_lvl[1]=0xfe,this idx will be invalid.
+            wakeup_param->gpio_num[1] = 3;////default select gpiob2 for fw_wakeup_host
+            wakeup_param->gpio_dft_lvl[1] = 1;////0:defalut pull down,  1:default pull up
+            /********************************************************************/
+            //MAX_AD_FILTER_NUM=5 :num 0
+            {
+                const uint8_t data[11] = {0x59,0x4B,0x32,0x42,0x41,0x5F,0x54,0x45,0x53,0x54,0x33};
+                wakeup_param->ad_filter[0].ad_len = 12;
+                wakeup_param->ad_filter[0].ad_type = 0x09;
+                memcpy(wakeup_param->ad_filter[0].ad_data, data,wakeup_param->ad_filter[0].ad_len-1);// 1111 1111 1110 0000 0000 0000 0000 0000 //0xffe00000
+                wakeup_param->ad_filter[0].ad_data_mask = 0xffe00000;
+                wakeup_param->ad_filter[0].ad_role = ROLE_COMBO|(COMBO_0<<4);
+                wakeup_param->ad_filter[0].gpio_trigger_idx = TG_IDX_0;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+            }
+            /********************************************************************/
+            //MAX_AD_FILTER_NUM=5 :num 1
+            {
+                const uint8_t data[2] = {0x12,0x18};
+                wakeup_param->ad_filter[1].ad_len = 3;
+                wakeup_param->ad_filter[1].ad_type = 0x3;
+                memcpy(wakeup_param->ad_filter[1].ad_data, data,wakeup_param->ad_filter[1].ad_len-1);// 1100 0000 0000 0000 0000 0000 0000 0000 //0xc0000000
+                wakeup_param->ad_filter[1].ad_data_mask = 0xc0000000;
+                wakeup_param->ad_filter[1].ad_role = ROLE_COMBO|(COMBO_0<<4);
+                wakeup_param->ad_filter[1].gpio_trigger_idx = TG_IDX_0;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+            }
+            /********************************************************************/
+            //MAX_AD_FILTER_NUM=5 :num 2
+            {
+                //const uint8_t data[11] = {0x59,0x4B,0x32,0x42,0x41,0x5F,0x54,0x45,0x53,0x54,0x33};
+                wakeup_param->ad_filter[2].ad_len = 0;
+                wakeup_param->ad_filter[2].ad_type = 0;
+                //memcpy(wakeup_param->ad_filter[2].ad_data, data,wakeup_param->ad_filter[2].ad_len-1);// 1100 0000 0111 1111 1100 0000 0000 0000 //0xc07fc000
+                wakeup_param->ad_filter[2].ad_data_mask = 0;
+                wakeup_param->ad_filter[2].ad_role = ROLE_ONLY;
+                wakeup_param->ad_filter[2].gpio_trigger_idx = TG_IDX_0;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+            }
+            /********************************************************************/
+            //MAX_AD_FILTER_NUM=5 :num 3
+            {
+                //const uint8_t data[11] = {0x59,0x4B,0x32,0x42,0x41,0x5F,0x54,0x45,0x53,0x54,0x33};
+                wakeup_param->ad_filter[3].ad_len = 0;
+                wakeup_param->ad_filter[3].ad_type = 0;
+                //memcpy(wakeup_param->ad_filter[2].ad_data, data,wakeup_param->ad_filter[2].ad_len-1);// 1100 0000 0111 1111 1100 0000 0000 0000 //0xc07fc000
+                wakeup_param->ad_filter[3].ad_data_mask = 0;
+                wakeup_param->ad_filter[3].ad_role = ROLE_COMBO|(COMBO_1<<4);
+                wakeup_param->ad_filter[3].gpio_trigger_idx = TG_IDX_0;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+            }
+            /********************************************************************/
+            //MAX_AD_FILTER_NUM=5 :num 4
+            {
+                //const uint8_t data[11] = {0x59,0x4B,0x32,0x42,0x41,0x5F,0x54,0x45,0x53,0x54,0x33};
+                wakeup_param->ad_filter[4].ad_len = 0;
+                wakeup_param->ad_filter[4].ad_type = 0x09;
+                //memcpy(wakeup_param->ad_filter[4].ad_data, data,wakeup_param->ad_filter[4].ad_len-1);// 1111 1111 1110 0000 0000 0000 0000 0000 //0xffe00000
+                wakeup_param->ad_filter[4].ad_data_mask = 0xffe00000;
+                wakeup_param->ad_filter[4].ad_role = ROLE_COMBO|(COMBO_1<<4);
+                wakeup_param->ad_filter[4].gpio_trigger_idx = TG_IDX_0|TG_IDX_1;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+            }
+
+            for(i = 0; i < (sizeof(struct ble_wakeup_param_t)/4 +1); i++){
+                printk("write_blocks[%d]:0x%08X \r\n", i, write_blocks[i]);
+                rwnx_send_dbg_mem_write_req(usb_dev, 0x15FF00 + (4 * i), write_blocks[i]);
+            }
+            rwnx_send_dbg_start_app_req(usb_dev, RAM_FW_BLE_SCAN_WAKEUP_ADDR_8800D80, HOST_START_APP_AUTO);
+            kfree(wakeup_param);
+
+            return -1;
+        }
     return 0;
 }
 
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80.h b/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80.h
index 0249f935235f..c32d9844e807 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80.h
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80.h
@@ -3,6 +3,8 @@
 
 #define USB_DEVICE_ID_AIC_8800D80       0x8D80
 #define USB_DEVICE_ID_AIC_8800D81       0x8D81
+#define USB_DEVICE_ID_AIC_8800D40       0x8D40
+#define USB_DEVICE_ID_AIC_8800D41       0x8D41
 
 #define FW_BASE_NAME_8800D80                "fmacfw_8800d80.bin"
 #define FW_RF_BASE_NAME_8800D80             "fmacfw_rf_8800d80.bin"
@@ -10,13 +12,22 @@
 #define FW_ADID_BASE_NAME_8800D80           "fw_adid_8800d80.bin"
 #define FW_PATCH_TABLE_NAME_8800D80         "fw_patch_table_8800d80.bin"
 
+#ifdef CONFIG_FOR_IPCAM
+#define FW_BASE_NAME_8800D80_U02            "fmacfw_8800d80_u02_ipc.bin"
+#define FW_BASE_NAME_8800D80_H_U02          "fmacfw_8800d80_h_u02_ipc.bin"
+
+#else
 #define FW_BASE_NAME_8800D80_U02            "fmacfw_8800d80_u02.bin"
+#define FW_BASE_NAME_8800D80_H_U02          "fmacfw_8800d80_h_u02.bin"
+#endif
 #define FW_RF_BASE_NAME_8800D80_U02         "lmacfw_rf_8800d80_u02.bin"
 #define FW_PATCH_BASE_NAME_8800D80_U02      "fw_patch_8800d80_u02.bin"
 #define FW_ADID_BASE_NAME_8800D80_U02       "fw_adid_8800d80_u02.bin"
 #define FW_CALIBMODE_NAME_8800D80_U02       "calibmode_8800d80.bin"
 #define FW_PATCH_TABLE_NAME_8800D80_U02     "fw_patch_table_8800d80_u02.bin"
 
+#define FLASH_BIN_8800M80                   "host_wb_8800m80.bin"
+
 #define FW_USERCONFIG_NAME_8800D80          "aic_userconfig_8800d80.txt"
 
 #define RAM_FMAC_FW_ADDR_8800D80           0x100000
@@ -30,6 +41,11 @@
 #define FW_RAM_CALIBMODE_ADDR_8800D80_U02  0x1e0000
 #define FW_RAM_PATCH_BASE_ADDR_8800D80_U02 0x0020B43c
 
+#define FLASH_BIN_ADDR_8800M80             0x8000000
+
+#define CHIP_ID_H_MASK  0xC0
+#define IS_CHIP_ID_H()  ((chip_id & CHIP_ID_H_MASK) == CHIP_ID_H_MASK)
+
 int aicwf_patch_config_8800d80(struct aic_usb_dev *usb_dev);
 int rwnx_plat_userconfig_load_8800d80(struct aic_usb_dev *usbdev);
 int system_config_8800d80(struct aic_usb_dev *usb_dev);
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80x2.c b/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80x2.c
new file mode 100644
index 000000000000..78ecb46e2496
--- /dev/null
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80x2.c
@@ -0,0 +1,598 @@
+#include "aic_txrxif.h"
+#include "aicwf_usb.h"
+#include "aicbluetooth.h"
+#include "aic_compat_8800d80x2.h"
+#include "aicwf_debug.h"
+extern int ble_scan_wakeup_reboot_time;
+extern uint32_t ad_data_filter_mask;
+extern uint32_t gpio_num;//default select gpiob2 for fw_wakeup_host
+extern uint32_t gpio_dft_lvl;//0:defalut pull down,  1:default pull up
+
+int rwnx_plat_bin_fw_upload_2(struct aic_usb_dev *usbdev, u32 fw_addr,
+                               char *filename);
+int rwnx_request_firmware_common(struct aic_usb_dev *usbdev,
+	u32** buffer, const char *filename);
+void rwnx_plat_userconfig_parsing(char *buffer, int size);
+void rwnx_release_firmware_common(u32** buffer);
+
+extern int testmode;
+extern u8 chip_id;
+extern u8 chip_mcu_id;
+
+typedef u32 (*array2_tbl_t)[2];
+
+#define AIC_PATCH_MAGIG_NUM     0x48435450 // "PTCH"
+#define AIC_PATCH_MAGIG_NUM_2   0x50544348 // "HCTP"
+#define AIC_PATCH_BLOCK_MAX     4
+
+typedef struct {
+    uint32_t magic_num;
+    uint32_t pair_start;
+    uint32_t magic_num_2;
+    uint32_t pair_count;
+    uint32_t block_dst[AIC_PATCH_BLOCK_MAX];
+    uint32_t block_src[AIC_PATCH_BLOCK_MAX];
+    uint32_t block_size[AIC_PATCH_BLOCK_MAX]; // word count
+} aic_patch_t;
+
+
+#define AIC_PATCH_OFST(mem) ((size_t) &((aic_patch_t *)0)->mem)
+#define AIC_PATCH_ADDR(mem) ((u32) (aic_patch_str_base + AIC_PATCH_OFST(mem)))
+
+#define USER_CHAN_MAX_TXPWR_EN_FLAG     (0x01U << 1)
+#define USER_TX_USE_ANA_F_FLAG          (0x01U << 2)
+
+#define CFG_USER_CHAN_MAX_TXPWR_EN  0
+#define CFG_USER_TX_USE_ANA_F       0
+
+#define CFG_USER_EXT_FLAGS_EN   (CFG_USER_CHAN_MAX_TXPWR_EN || CFG_USER_TX_USE_ANA_F)
+
+u32 patch_tbl_d80x2[][2] =
+{
+    #ifdef USE_5G
+    {0x00b4, 0xf3010001},
+    #else
+    {0x00b4, 0xf3010000},
+    #endif
+#ifdef CONFIG_PLATFORM_HI
+    {0x0170, 0x00000001},//rx aggr counter
+#else
+    {0x0170, 0x0000000A},//rx aggr counter
+#endif
+
+    #if CFG_USER_EXT_FLAGS_EN
+    {0x0188, 0x00000001
+        #if CFG_USER_CHAN_MAX_TXPWR_EN
+        | USER_CHAN_MAX_TXPWR_EN_FLAG
+        #endif
+        #if CFG_USER_TX_USE_ANA_F
+        | USER_TX_USE_ANA_F_FLAG
+        #endif
+    }, // user_ext_flags
+    #endif
+};
+
+//adap test
+u32 adaptivity_patch_tbl_d80x2[][2] = {
+    {0x000C, 0x0000320A}, //linkloss_thd
+    {0x009C, 0x00000000}, //ac_param_conf
+    {0x0168, 0x00010000}, //tx_adaptivity_en
+};
+
+u32 syscfg_tbl_masked_8800d80x2[][3] = {
+};
+
+u32 syscfg_tbl_8800d80x2[][2] = {
+    #ifdef CONFIG_PMIC_SETTING
+    {0x70001408, 0x00000000}, // stop wdg
+    #endif /* CONFIG_PMIC_SETTING */
+};
+
+extern int adap_test;
+
+#define NEW_PATCH_BUFFER_MAP    1
+
+int aicwf_patch_config_8800d80x2(struct aic_usb_dev *usb_dev)
+{
+#if 0
+    u32 rd_patch_addr;
+    u32 aic_patch_addr;
+    u32 config_base, aic_patch_str_base;
+    #if (NEW_PATCH_BUFFER_MAP)
+    u32 patch_buff_addr, patch_buff_base, rd_version_addr, rd_version_val;
+    #endif
+    uint32_t start_addr = 0x001D7000;
+    u32 patch_addr = start_addr;
+    u32 patch_cnt = sizeof(patch_tbl_d80x2) / 4 / 2;
+    struct dbg_mem_read_cfm rd_patch_addr_cfm;
+    int ret = 0;
+    int cnt = 0;
+    //adap test
+    int adap_patch_cnt = 0;
+
+    if (adap_test) {
+        AICWFDBG(LOGINFO, "%s adap test \r\n", __func__);
+        adap_patch_cnt = sizeof(adaptivity_patch_tbl_d80x2)/sizeof(u32)/2;
+    }
+
+    if (chip_id == CHIP_REV_U01) {
+        rd_patch_addr = RAM_FMAC_FW_ADDR_8800D80X2 + 0x0198;
+    } else {
+        rd_patch_addr = RAM_FMAC_FW_ADDR_8800D80X2_U02 + 0x0198;
+    }
+    aic_patch_addr = rd_patch_addr + 8;
+
+    AICWFDBG(LOGERROR, "Read FW mem: %08x\n", rd_patch_addr);
+    if ((ret = rwnx_send_dbg_mem_read_req(usb_dev, rd_patch_addr, &rd_patch_addr_cfm))) {
+        AICWFDBG(LOGERROR, "setting base[0x%x] rd fail: %d\n", rd_patch_addr, ret);
+        return ret;
+    }
+    AICWFDBG(LOGERROR, "%x=%x\n", rd_patch_addr_cfm.memaddr, rd_patch_addr_cfm.memdata);
+    config_base = rd_patch_addr_cfm.memdata;
+
+    if ((ret = rwnx_send_dbg_mem_read_req(usb_dev, aic_patch_addr, &rd_patch_addr_cfm))) {
+        AICWFDBG(LOGERROR, "patch_str_base[0x%x] rd fail: %d\n", aic_patch_addr, ret);
+        return ret;
+    }
+    AICWFDBG(LOGERROR, "%x=%x\n", rd_patch_addr_cfm.memaddr, rd_patch_addr_cfm.memdata);
+    aic_patch_str_base = rd_patch_addr_cfm.memdata;
+
+    #if (NEW_PATCH_BUFFER_MAP)
+    if (chip_id == CHIP_REV_U01) {
+        rd_version_addr = RAM_FMAC_FW_ADDR_8800D80X2 + 0x01C;
+    } else {
+        rd_version_addr = RAM_FMAC_FW_ADDR_8800D80X2_U02 + 0x01C;
+    }
+    if ((ret = rwnx_send_dbg_mem_read_req(usb_dev, rd_version_addr, &rd_patch_addr_cfm))) {
+        AICWFDBG(LOGERROR, "version val[0x%x] rd fail: %d\n", rd_version_addr, ret);
+        return ret;
+    }
+    rd_version_val = rd_patch_addr_cfm.memdata;
+    AICWFDBG(LOGINFO, "rd_version_val=%08X\n", rd_version_val);
+    usb_dev->fw_version_uint = rd_version_val;
+    if (rd_version_val > 0x06090100) {
+        patch_buff_addr = rd_patch_addr + 12;
+        ret = rwnx_send_dbg_mem_read_req(usb_dev, patch_buff_addr, &rd_patch_addr_cfm);
+        if (ret) {
+            AICWFDBG(LOGERROR, "patch buf rd fail\n");
+            return ret;
+        }
+        AICWFDBG(LOGINFO, "%x=%x\n", rd_patch_addr_cfm.memaddr, rd_patch_addr_cfm.memdata);
+        patch_buff_base = rd_patch_addr_cfm.memdata;
+        patch_addr = start_addr = patch_buff_base;
+    }
+    #endif
+
+    if ((ret = rwnx_send_dbg_mem_write_req(usb_dev, AIC_PATCH_ADDR(magic_num), AIC_PATCH_MAGIG_NUM))) {
+        AICWFDBG(LOGERROR, "maigic_num[0x%x] write fail: %d\n", AIC_PATCH_ADDR(magic_num), ret);
+        return ret;
+    }
+
+    if ((ret = rwnx_send_dbg_mem_write_req(usb_dev, AIC_PATCH_ADDR(magic_num_2), AIC_PATCH_MAGIG_NUM_2))) {
+        AICWFDBG(LOGERROR, "maigic_num[0x%x] write fail: %d\n", AIC_PATCH_ADDR(magic_num_2), ret);
+        return ret;
+    }
+
+    if ((ret = rwnx_send_dbg_mem_write_req(usb_dev, AIC_PATCH_ADDR(pair_start), patch_addr))) {
+        AICWFDBG(LOGERROR, "pair_start[0x%x] write fail: %d\n", AIC_PATCH_ADDR(pair_start), ret);
+        return ret;
+    }
+
+    if ((ret = rwnx_send_dbg_mem_write_req(usb_dev, AIC_PATCH_ADDR(pair_count), patch_cnt + adap_patch_cnt))) {
+        AICWFDBG(LOGERROR, "pair_count[0x%x] write fail: %d\n", AIC_PATCH_ADDR(pair_count), ret);
+        return ret;
+    }
+
+    for (cnt = 0; cnt < patch_cnt; cnt++) {
+        if ((ret = rwnx_send_dbg_mem_write_req(usb_dev, start_addr+8*cnt, patch_tbl_d80x2[cnt][0]+config_base))) {
+            AICWFDBG(LOGERROR, "%x write fail\n", start_addr+8*cnt);
+            return ret;
+        }
+        if ((ret = rwnx_send_dbg_mem_write_req(usb_dev, start_addr+8*cnt+4, patch_tbl_d80x2[cnt][1]))) {
+            AICWFDBG(LOGERROR, "%x write fail\n", start_addr+8*cnt+4);
+            return ret;
+        }
+    }
+
+    if (adap_test){
+        int tmp_cnt = patch_cnt + adap_patch_cnt;
+        for (cnt = patch_cnt; cnt < tmp_cnt; cnt++) {
+            int tbl_idx = cnt - patch_cnt;
+            if ((ret = rwnx_send_dbg_mem_write_req(usb_dev, start_addr+8*cnt, adaptivity_patch_tbl_d80x2[tbl_idx][0]+config_base))) {
+                AICWFDBG(LOGERROR, "%x write fail\n", start_addr+8*cnt);
+            return ret;
+            }
+            if ((ret = rwnx_send_dbg_mem_write_req(usb_dev, start_addr+8*cnt+4, adaptivity_patch_tbl_d80x2[tbl_idx][1]))) {
+                AICWFDBG(LOGERROR, "%x write fail\n", start_addr+8*cnt+4);
+            return ret;
+            }
+        }
+    }
+
+    /*
+     *  Patch block 0 ~ 3, that is void by default, can be set as:
+     *
+     *  const u32 patch_block_0[3] = {0x11223344, 0x55667788, 0xaabbccdd};
+     *  if ((ret = rwnx_send_dbg_mem_write_req(usb_dev, (u32)(&aic_patch->block_dst[0]), 0x160000))) {
+     *      printk("block_dst [0x%x] write fail: %d\n", (u32)(&aic_patch->block_dst[0]), ret);
+     *  }
+     *  if ((ret = rwnx_send_dbg_mem_write_req(usb_dev, (u32)(&aic_patch->block_src[0]), 0x307000))) {
+     *      printk("block_src [0x%x] write fail: %d\n", (u32)(&aic_patch->block_src[0]), ret);
+     *  }
+     *  if ((ret = rwnx_send_dbg_mem_write_req(usb_dev, (u32)(&aic_patch->block_size[0]), sizeof(patch_block_0) / sizeof(u32)))) {
+     *      printk("block_size[0x%x] write fail: %d\n", (u32)(&aic_patch->block_size[0]), ret);
+     *  }
+     *  if ((ret = rwnx_send_dbg_mem_block_write_req(usb_dev, 0x307000, sizeof(patch_block_0), patch_block_0))) {
+     *      printk("blk set fail: %d\n", ret);
+     *  }
+     */
+    if ((ret = rwnx_send_dbg_mem_write_req(usb_dev, AIC_PATCH_ADDR(block_size[0]), 0))) {
+        AICWFDBG(LOGERROR, "block_size[0x%x] write fail: %d\n", AIC_PATCH_ADDR(block_size[0]), ret);
+        return ret;
+    }
+    if ((ret = rwnx_send_dbg_mem_write_req(usb_dev, AIC_PATCH_ADDR(block_size[1]), 0))) {
+        AICWFDBG(LOGERROR, "block_size[0x%x] write fail: %d\n", AIC_PATCH_ADDR(block_size[1]), ret);
+        return ret;
+    }
+    if ((ret = rwnx_send_dbg_mem_write_req(usb_dev, AIC_PATCH_ADDR(block_size[2]), 0))) {
+        AICWFDBG(LOGERROR, "block_size[0x%x] write fail: %d\n", AIC_PATCH_ADDR(block_size[2]), ret);
+        return ret;
+    }
+    if ((ret = rwnx_send_dbg_mem_write_req(usb_dev, AIC_PATCH_ADDR(block_size[3]), 0))) {
+        AICWFDBG(LOGERROR, "block_size[0x%x] write fail: %d\n", AIC_PATCH_ADDR(block_size[3]), ret);
+        return ret;
+    }
+#endif
+
+    return 0;
+}
+
+
+#if 0
+extern char aic_fw_path[200];
+
+int rwnx_plat_userconfig_load_8800d80x2(struct aic_usb_dev *usb_dev){
+    int size;
+    u32 *dst=NULL;
+    char *filename = FW_USERCONFIG_NAME_8800D80X2;
+
+    AICWFDBG(LOGINFO, "userconfig file path:%s \r\n", filename);
+
+    /* load file */
+    size = rwnx_request_firmware_common(usb_dev, &dst, filename);
+    if (size <= 0) {
+            AICWFDBG(LOGERROR, "wrong size of firmware file\n");
+            dst = NULL;
+            return 0;
+    }
+
+	/* Copy the file on the Embedded side */
+    AICWFDBG(LOGINFO, "### Load file done: %s, size=%d\n", filename, size);
+
+	rwnx_plat_userconfig_parsing((char *)dst, size);
+
+    rwnx_release_firmware_common(&dst);
+
+    AICWFDBG(LOGINFO, "userconfig download complete\n\n");
+    return 0;
+
+}
+#endif
+int system_config_8800d80x2(struct aic_usb_dev *usb_dev){
+		//int syscfg_num;
+		int ret;//, cnt;
+		const u32 mem_addr = 0x40500000;
+		const u32 mem_addr2 = 0x40500004;
+		struct dbg_mem_read_cfm rd_mem_addr_cfm;
+		ret = rwnx_send_dbg_mem_read_req(usb_dev, mem_addr, &rd_mem_addr_cfm);
+		if (ret) {
+			printk("%x rd fail: %d\n", mem_addr, ret);
+			return ret;
+		}
+		chip_id = rd_mem_addr_cfm.memdata >> 16;
+
+		ret = rwnx_send_dbg_mem_read_req(usb_dev, mem_addr2, &rd_mem_addr_cfm);
+		if (ret) {
+			printk("%x rd fail: %d\n", mem_addr2, ret);
+			return ret;
+		}
+		if (((rd_mem_addr_cfm.memdata >> 17) & 0x01UL) == 0x00UL) {
+			chip_mcu_id = 1;
+		}
+
+		printk("chip_id=%x, chip_mcu_id = %d\n", chip_id, chip_mcu_id);
+	#if 0
+		syscfg_num = sizeof(syscfg_tbl_8800d80x2) / sizeof(u32) / 2;
+		for (cnt = 0; cnt < syscfg_num; cnt++) {
+			ret = rwnx_send_dbg_mem_write_req(usb_dev, syscfg_tbl_8800d80x2[cnt][0], syscfg_tbl_8800d80x2[cnt][1]);
+			if (ret) {
+				printk("%x write fail: %d\n", syscfg_tbl_8800d80x2[cnt][0], ret);
+				return ret;
+			}
+		}
+		syscfg_num = sizeof(syscfg_tbl_masked_8800d80x2) / sizeof(u32) / 3;
+		for (cnt = 0; cnt < syscfg_num; cnt++) {
+			ret = rwnx_send_dbg_mem_mask_write_req(usb_dev,
+				syscfg_tbl_masked_8800d80x2[cnt][0], syscfg_tbl_masked_8800d80x2[cnt][1], syscfg_tbl_masked_8800d80x2[cnt][2]);
+			if (ret) {
+				printk("%x mask write fail: %d\n", syscfg_tbl_masked_8800d80x2[cnt][0], ret);
+				return ret;
+			}
+		}
+	#endif
+
+	return 0;
+}
+
+
+int aicfw_download_fw_8800d80x2(struct aic_usb_dev *usb_dev)
+{
+    if (testmode == FW_NORMAL_MODE) {
+        if (rwnx_plat_bin_fw_upload_android(usb_dev, RAM_FMAC_FW_ADDR_8800D80X2, FW_BASE_NAME_8800D80X2)) {
+            return -1;
+        }
+
+        if (aicwf_patch_config_8800d80x2(usb_dev)) {
+            return -1;
+        }
+
+        if (rwnx_send_dbg_start_app_req(usb_dev, RAM_FMAC_FW_ADDR_8800D80X2_U02, HOST_START_APP_AUTO)) {
+            return -1;
+        }
+    } else if (testmode == FW_TEST_MODE) {
+        if(rwnx_plat_bin_fw_upload_android(usb_dev, RAM_FMAC_RF_FW_ADDR_8800D80X2, FW_RF_BASE_NAME_8800D80X2)) {
+            AICWFDBG(LOGERROR,"%s wifi fw download fail \r\n", __func__);
+            return -1;
+        }
+        if (rwnx_send_dbg_start_app_req(usb_dev, RAM_FMAC_RF_FW_ADDR_8800D80X2, HOST_START_APP_AUTO)) {
+            return -1;
+        }
+    }
+
+#if 0
+    struct aicbt_patch_table *head = NULL;
+    struct aicbt_patch_info_t patch_info = {
+        .info_len          = 0,
+        .adid_addrinf      = 0,
+        .addr_adid         = 0,
+        .patch_addrinf     = 0,
+        .addr_patch        = 0,
+        .reset_addr        = 0,
+        .reset_val         = 0,
+        .adid_flag_addr    = 0,
+        .adid_flag         = 0,
+    };
+
+    int i = 0;
+
+    if (chip_id == CHIP_REV_U01) {
+        head = aicbt_patch_table_alloc(usb_dev, FW_PATCH_TABLE_NAME_8800D80X2);
+    } else {
+        head = aicbt_patch_table_alloc(usb_dev, FW_PATCH_TABLE_NAME_8800D80X2_U02);
+    }
+    if (head == NULL){
+        printk("aicbt_patch_table_alloc fail\n");
+        return -1;
+    }
+
+    if(head == NULL){
+        return -1;
+    }
+    if (chip_id == CHIP_REV_U01) {
+        patch_info.addr_adid = FW_RAM_ADID_BASE_ADDR_8800D80X2;
+        patch_info.addr_patch = FW_RAM_PATCH_BASE_ADDR_8800D80X2;
+    } else if (chip_id == CHIP_REV_U02 || chip_id == CHIP_REV_U03) {
+        patch_info.addr_adid = FW_RAM_ADID_BASE_ADDR_8800D80X2_U02;
+        patch_info.addr_patch = FW_RAM_PATCH_BASE_ADDR_8800D80X2_U02;
+    }
+    aicbt_patch_info_unpack(&patch_info, head);
+    if(patch_info.info_len == 0) {
+        printk("%s, aicbt_patch_info_unpack fail\n", __func__);
+        return -1;
+    }
+
+    printk("addr_adid 0x%x, addr_patch 0x%x\n", patch_info.addr_adid, patch_info.addr_patch);
+
+    if(testmode == FW_NORMAL_MODE){
+
+        if (chip_id != CHIP_REV_U01){
+            if(rwnx_plat_bin_fw_upload_android(usb_dev, patch_info.addr_adid, FW_ADID_BASE_NAME_8800D80X2_U02)) {
+                return -1;
+            }
+            if(rwnx_plat_bin_fw_upload_android(usb_dev, patch_info.addr_patch, FW_PATCH_BASE_NAME_8800D80X2_U02)) {
+                return -1;
+            }
+            #if 0
+            if (rwnx_plat_bin_fw_patch_table_upload_android(usb_dev, FW_PATCH_TABLE_NAME_8800D80X2_U02)) {
+                return -1;
+            }
+            #else
+            if (aicbt_patch_table_load(usb_dev, head)) {
+                return -1;
+            }
+            #endif
+            if(rwnx_plat_bin_fw_upload_android(usb_dev, RAM_FMAC_FW_ADDR_8800D80X2_U02, FW_BASE_NAME_8800D80X2_U02)) {
+                return -1;
+            }
+            #if 0
+            if(rwnx_plat_bin_fw_upload_android(usb_dev, FW_RAM_CALIBMODE_ADDR_8800D80X2_U02, FW_CALIBMODE_NAME_8800D80X2_U02)) {
+                return -1;
+            }
+            if (rwnx_send_dbg_mem_write_req(usb_dev, 0x40500048, 0x1e0000))
+                return -1;
+            #endif
+            if (aicwf_patch_config_8800d80x2(usb_dev)) {
+                return -1;
+            }
+            if (rwnx_send_dbg_start_app_req(usb_dev, RAM_FMAC_FW_ADDR_8800D80X2_U02, HOST_START_APP_AUTO)) {
+                return -1;
+            }
+        }else {
+            if(rwnx_plat_bin_fw_upload_android(usb_dev, patch_info.addr_adid, FW_ADID_BASE_NAME_8800D80X2)) {
+                return -1;
+            }
+            if(rwnx_plat_bin_fw_upload_android(usb_dev, patch_info.addr_patch, FW_PATCH_BASE_NAME_8800D80X2)) {
+                return -1;
+            }
+            #if 0
+            if (rwnx_plat_bin_fw_patch_table_upload_android(usb_dev, FW_PATCH_TABLE_NAME_8800D80X2)) {
+                return -1;
+            }
+            #else
+            if (aicbt_patch_table_load(usb_dev, head)) {
+                return -1;
+            }
+            #endif
+            if(rwnx_plat_bin_fw_upload_android(usb_dev, RAM_FMAC_FW_ADDR_8800D80X2, FW_BASE_NAME_8800D80X2)) {
+                return -1;
+             }
+            if (rwnx_send_dbg_start_app_req(usb_dev, RAM_FMAC_FW_ADDR_8800D80X2, HOST_START_APP_AUTO)) {
+                return -1;
+            }
+        }
+    }else if(testmode == FW_TEST_MODE){
+        if (chip_id != CHIP_REV_U01){
+
+            if(rwnx_plat_bin_fw_upload_android(usb_dev, patch_info.addr_adid, FW_ADID_BASE_NAME_8800D80X2_U02)) {
+                return -1;
+            }
+
+            if(rwnx_plat_bin_fw_upload_android(usb_dev, patch_info.addr_patch, FW_PATCH_BASE_NAME_8800D80X2_U02)) {
+                return -1;
+            }
+#if 0
+            if (rwnx_plat_bin_fw_patch_table_upload_android(usb_dev, FW_PATCH_TABLE_NAME_8800D80X2_U02)) {
+                return -1;
+            }
+#else
+            if (aicbt_patch_table_load(usb_dev, head)) {
+                return -1;
+            }
+#endif
+
+            if (chip_mcu_id) {
+                int ret = 0;
+                ret = rwnx_plat_flash_bin_upload_android(usb_dev, FLASH_BIN_ADDR_8800M80X2, FLASH_BIN_8800M80X2);
+                if (ret && ret!= ENOENT) {
+                    AICWFDBG(LOGERROR,"%s flash bin download fail \r\n", __func__);
+                    return -1;
+                }
+            }
+
+			if(rwnx_plat_bin_fw_upload_android(usb_dev, RAM_FMAC_RF_FW_ADDR_8800D80X2_U02, FW_RF_BASE_NAME_8800D80X2_U02)) {
+				AICWFDBG(LOGERROR,"%s wifi fw download fail \r\n", __func__);
+				return -1;
+			}
+			if (rwnx_send_dbg_start_app_req(usb_dev, RAM_FMAC_RF_FW_ADDR_8800D80X2_U02, HOST_START_APP_AUTO)) {
+				return -1;
+			}
+	    } else {
+            if(rwnx_plat_bin_fw_upload_android(usb_dev, RAM_FMAC_RF_FW_ADDR_8800D80X2, FW_RF_BASE_NAME_8800D80X2)) {
+             AICWFDBG(LOGERROR,"%s wifi fw download fail \r\n", __func__);
+                    return -1;
+            }
+            if (rwnx_send_dbg_start_app_req(usb_dev, RAM_FMAC_RF_FW_ADDR_8800D80X2, HOST_START_APP_AUTO)) {
+                    return -1;
+            }
+	    }
+    }else if(testmode == FW_BLE_SCAN_AD_FILTER_MODE){
+/*
+            data and ad_data_filter_mask instructions for use
+            ex.
+            data[18] = {0x46,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x30,0xff,0xff,0xff,0x43,0x52,0x45,0x4c,0x42};
+            mask = 1100 0000 0111 1111 1100 0000 0000 0000 = 0xc07fc000
+
+            data  = 0x46,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x30,0xff,0xff,0xff,0x43,0x52,0x45,0x4c,0x42
+            mask =  1      1       0     0     0    0     0     0    0     1      1     1    1    1      1      1      1      1      0     0...... fill 0
+
+            data & mask = "0x46 0x00" 0x00 0x00 0x00 0x00 0x00 0x00 0x00 "0x30 0xff 0xff 0x43 0x52 0x45 0x4c 0x42"
+            using data & mask value condition to wakeup host_wake_bt gpio
+*/
+            struct ble_wakeup_param_t* wakeup_param = (struct ble_wakeup_param_t*)kmalloc(sizeof(struct ble_wakeup_param_t), GFP_KERNEL);
+            uint32_t *write_blocks = (uint32_t *)wakeup_param;
+
+            printk("%s ble scan wakeup \r\n", __func__);
+
+            memset(wakeup_param, 0, sizeof(struct ble_wakeup_param_t));
+            rwnx_plat_bin_fw_upload_android(usb_dev, RAM_FW_BLE_SCAN_WAKEUP_ADDR_8800D80X2, FW_BLE_SCAN_AD_FILTER_NAME);
+            wakeup_param->magic_num = 0x53454C42;//magic_num
+            wakeup_param->delay_scan_to = 1000;//delay start scan time(ms)
+            wakeup_param->reboot_to = ble_scan_wakeup_reboot_time;//reboot time
+            /******************************************************************/
+            ///gpio_trigger_idx : 0    if wakeup_param->gpio_dft_lvl[0]=0xfe,this idx will be invalid.
+            wakeup_param->gpio_num[0] = gpio_num;////default select gpiob2 for fw_wakeup_host
+            wakeup_param->gpio_dft_lvl[0] = gpio_dft_lvl;////0:defalut pull down,  1:default pull up
+            ///gpio_trigger_idx : 1    if wakeup_param->gpio_dft_lvl[1]=0xfe,this idx will be invalid.
+            wakeup_param->gpio_num[1] = 3;////default select gpiob2 for fw_wakeup_host
+            wakeup_param->gpio_dft_lvl[1] = 1;////0:defalut pull down,  1:default pull up
+            /********************************************************************/
+            //MAX_AD_FILTER_NUM=5 :num 0
+            {
+                const uint8_t data[11] = {0x59,0x4B,0x32,0x42,0x41,0x5F,0x54,0x45,0x53,0x54,0x33};
+                wakeup_param->ad_filter[0].ad_len = 12;
+                wakeup_param->ad_filter[0].ad_type = 0x09;
+                memcpy(wakeup_param->ad_filter[0].ad_data, data,wakeup_param->ad_filter[0].ad_len-1);// 1111 1111 1110 0000 0000 0000 0000 0000 //0xffe00000
+                wakeup_param->ad_filter[0].ad_data_mask = 0xffe00000;
+                wakeup_param->ad_filter[0].ad_role = ROLE_COMBO|(COMBO_0<<4);
+                wakeup_param->ad_filter[0].gpio_trigger_idx = TG_IDX_0;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+            }
+            /********************************************************************/
+            //MAX_AD_FILTER_NUM=5 :num 1
+            {
+                const uint8_t data[2] = {0x12,0x18};
+                wakeup_param->ad_filter[1].ad_len = 3;
+                wakeup_param->ad_filter[1].ad_type = 0x3;
+                memcpy(wakeup_param->ad_filter[1].ad_data, data,wakeup_param->ad_filter[1].ad_len-1);// 1100 0000 0000 0000 0000 0000 0000 0000 //0xc0000000
+                wakeup_param->ad_filter[1].ad_data_mask = 0xc0000000;
+                wakeup_param->ad_filter[1].ad_role = ROLE_COMBO|(COMBO_0<<4);
+                wakeup_param->ad_filter[1].gpio_trigger_idx = TG_IDX_0;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+            }
+            /********************************************************************/
+            //MAX_AD_FILTER_NUM=5 :num 2
+            {
+                //const uint8_t data[11] = {0x59,0x4B,0x32,0x42,0x41,0x5F,0x54,0x45,0x53,0x54,0x33};
+                wakeup_param->ad_filter[2].ad_len = 0;
+                wakeup_param->ad_filter[2].ad_type = 0;
+                //memcpy(wakeup_param->ad_filter[2].ad_data, data,wakeup_param->ad_filter[2].ad_len-1);// 1100 0000 0111 1111 1100 0000 0000 0000 //0xc07fc000
+                wakeup_param->ad_filter[2].ad_data_mask = 0;
+                wakeup_param->ad_filter[2].ad_role = ROLE_ONLY;
+                wakeup_param->ad_filter[2].gpio_trigger_idx = TG_IDX_0;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+            }
+            /********************************************************************/
+            //MAX_AD_FILTER_NUM=5 :num 3
+            {
+                //const uint8_t data[11] = {0x59,0x4B,0x32,0x42,0x41,0x5F,0x54,0x45,0x53,0x54,0x33};
+                wakeup_param->ad_filter[3].ad_len = 0;
+                wakeup_param->ad_filter[3].ad_type = 0;
+                //memcpy(wakeup_param->ad_filter[2].ad_data, data,wakeup_param->ad_filter[2].ad_len-1);// 1100 0000 0111 1111 1100 0000 0000 0000 //0xc07fc000
+                wakeup_param->ad_filter[3].ad_data_mask = 0;
+                wakeup_param->ad_filter[3].ad_role = ROLE_COMBO|(COMBO_1<<4);
+                wakeup_param->ad_filter[3].gpio_trigger_idx = TG_IDX_0;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+            }
+            /********************************************************************/
+            //MAX_AD_FILTER_NUM=5 :num 4
+            {
+                //const uint8_t data[11] = {0x59,0x4B,0x32,0x42,0x41,0x5F,0x54,0x45,0x53,0x54,0x33};
+                wakeup_param->ad_filter[4].ad_len = 0;
+                wakeup_param->ad_filter[4].ad_type = 0x09;
+                //memcpy(wakeup_param->ad_filter[4].ad_data, data,wakeup_param->ad_filter[4].ad_len-1);// 1111 1111 1110 0000 0000 0000 0000 0000 //0xffe00000
+                wakeup_param->ad_filter[4].ad_data_mask = 0xffe00000;
+                wakeup_param->ad_filter[4].ad_role = ROLE_COMBO|(COMBO_1<<4);
+                wakeup_param->ad_filter[4].gpio_trigger_idx = TG_IDX_0|TG_IDX_1;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+            }
+
+            for(i = 0; i < (sizeof(struct ble_wakeup_param_t)/4 +1); i++){
+                printk("write_blocks[%d]:0x%08X \r\n", i, write_blocks[i]);
+                rwnx_send_dbg_mem_write_req(usb_dev, 0x15FF00 + (4 * i), write_blocks[i]);
+            }
+            rwnx_send_dbg_start_app_req(usb_dev, RAM_FW_BLE_SCAN_WAKEUP_ADDR_8800D80X2, HOST_START_APP_AUTO);
+            kfree(wakeup_param);
+
+            return -1;
+        }
+#endif
+
+    return 0;
+}
+
+
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80x2.h b/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80x2.h
new file mode 100644
index 000000000000..45dc7467f2c5
--- /dev/null
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aic_compat_8800d80x2.h
@@ -0,0 +1,46 @@
+#include <linux/types.h>
+#include "aicwf_usb.h"
+
+#define USB_DEVICE_ID_AIC_8800D80X2       0x8D90
+#define USB_DEVICE_ID_AIC_8800D81X2       0x8D91
+
+#define FW_BASE_NAME_8800D80X2                "fmacfw_8800d80x2.bin"
+#define FW_RF_BASE_NAME_8800D80X2             "fmacfw_rf_8800d80x2.bin"
+#define FW_PATCH_BASE_NAME_8800D80X2          "fw_patch_8800d80x2.bin"
+#define FW_ADID_BASE_NAME_8800D80X2           "fw_adid_8800d80x2.bin"
+#define FW_PATCH_TABLE_NAME_8800D80X2         "fw_patch_table_8800d80x2.bin"
+
+#ifdef CONFIG_FOR_IPCAM
+#define FW_BASE_NAME_8800D80X2_U02            "fmacfw_8800d80x2_u02_ipc.bin"
+#else
+#define FW_BASE_NAME_8800D80X2_U02            "fmacfw_8800d80x2_u02.bin"
+#endif
+#define FW_RF_BASE_NAME_8800D80X2_U02         "lmacfw_rf_8800d80x2_u02.bin"
+#define FW_PATCH_BASE_NAME_8800D80X2_U02      "fw_patch_8800d80x2_u02.bin"
+#define FW_ADID_BASE_NAME_8800D80X2_U02       "fw_adid_8800d80x2_u02.bin"
+#define FW_CALIBMODE_NAME_8800D80X2_U02       "calibmode_8800d80x2.bin"
+#define FW_PATCH_TABLE_NAME_8800D80X2_U02     "fw_patch_table_8800d80x2_u02.bin"
+
+#define FLASH_BIN_8800M80X2                   "host_wb_8800m80x2.bin"
+
+#define FW_USERCONFIG_NAME_8800D80X2          "aic_userconfig_8800d80x2.txt"
+
+#define RAM_FMAC_FW_ADDR_8800D80X2           0x120000
+#define RAM_FMAC_RF_FW_ADDR_8800D80X2        0x120000
+#define FW_RAM_ADID_BASE_ADDR_8800D80X2      0x002017E0
+#define FW_RAM_PATCH_BASE_ADDR_8800D80X2     0x0020B2B0
+
+#define RAM_FMAC_FW_ADDR_8800D80X2_U02       0x120000
+#define RAM_FMAC_RF_FW_ADDR_8800D80X2_U02    0x120000
+#define FW_RAM_ADID_BASE_ADDR_8800D80X2_U02  0x00201940
+#define FW_RAM_CALIBMODE_ADDR_8800D80X2_U02  0x1e0000
+#define FW_RAM_PATCH_BASE_ADDR_8800D80X2_U02 0x0020B43c
+
+#define FLASH_BIN_ADDR_8800M80X2             0x8000000
+
+
+int aicwf_patch_config_8800d80x2(struct aic_usb_dev *usb_dev);
+int rwnx_plat_userconfig_load_8800d80x2(struct aic_usb_dev *usbdev);
+int system_config_8800d80x2(struct aic_usb_dev *usb_dev);
+int aicfw_download_fw_8800d80x2(struct aic_usb_dev *usb_dev);
+
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aic_txrxif.c b/drivers/net/wireless/aic8800/aic_load_fw/aic_txrxif.c
index a892b68ec521..6bbe19f4c0c4 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aic_txrxif.c
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aic_txrxif.c
@@ -245,6 +245,7 @@ int aicwf_process_rxframes(struct aicwf_rx_priv *rx_priv)
             }
         }
 
+		dev_kfree_skb(skb_inblock);
         dev_kfree_skb(skb);
         atomic_dec(&rx_priv->rx_cnt);
     }
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth.c b/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth.c
index c4e7cd1c3266..e93c24b7749f 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth.c
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth.c
@@ -1,1125 +1,1315 @@
-#include <linux/version.h>
-#include <linux/vmalloc.h>
-#include "aicbluetooth_cmds.h"
-#include "aicwf_usb.h"
-#include "aic_txrxif.h"
-#include "md5.h"
-#ifdef CONFIG_USE_FW_REQUEST
-#include <linux/firmware.h>
-#endif
-
-//Parser state
-#define INIT 0
-#define CMD 1
-#define PRINT 2
-#define GET_VALUE 3
-
-typedef struct
-{
-    int8_t enable;
-    int8_t dsss;
-    int8_t ofdmlowrate_2g4;
-    int8_t ofdm64qam_2g4;
-    int8_t ofdm256qam_2g4;
-    int8_t ofdm1024qam_2g4;
-    int8_t ofdmlowrate_5g;
-    int8_t ofdm64qam_5g;
-    int8_t ofdm256qam_5g;
-    int8_t ofdm1024qam_5g;
-} txpwr_idx_conf_t;
-
-
-txpwr_idx_conf_t userconfig_txpwr_idx = {
-	.enable 		  = 1,
-	.dsss			  = 9,
-	.ofdmlowrate_2g4  = 8,
-	.ofdm64qam_2g4	  = 8,
-	.ofdm256qam_2g4   = 8,
-	.ofdm1024qam_2g4  = 8,
-	.ofdmlowrate_5g   = 11,
-	.ofdm64qam_5g	  = 10,
-	.ofdm256qam_5g	  = 9,
-	.ofdm1024qam_5g   = 9
-
-};
-
-typedef struct
-{
-    int8_t enable;
-    int8_t chan_1_4;
-    int8_t chan_5_9;
-    int8_t chan_10_13;
-    int8_t chan_36_64;
-    int8_t chan_100_120;
-    int8_t chan_122_140;
-    int8_t chan_142_165;
-} txpwr_ofst_conf_t;
-
-txpwr_ofst_conf_t userconfig_txpwr_ofst = {
-	.enable = 1,
-	.chan_1_4 = 0,
-	.chan_5_9 = 0,
-	.chan_10_13 = 0,
-	.chan_36_64 = 0,
-	.chan_100_120 = 0,
-	.chan_122_140 = 0,
-	.chan_142_165 = 0
-};
-
-typedef struct
-{
-    int8_t enable;
-    int8_t xtal_cap;
-    int8_t xtal_cap_fine;
-} xtal_cap_conf_t;
-
-
-xtal_cap_conf_t userconfig_xtal_cap = {
-	.enable = 0,
-	.xtal_cap = 24,
-	.xtal_cap_fine = 31,
-};
-
-
-struct aicbt_patch_table {
-	char     *name;
-	uint32_t type;
-	uint32_t *data;
-	uint32_t len;
-	struct aicbt_patch_table *next;
-};
-
-struct aicbt_info_t {
-    uint32_t btmode;
-    uint32_t btport;
-    uint32_t uart_baud;
-    uint32_t uart_flowctrl;
-	uint32_t lpm_enable;
-	uint32_t txpwr_lvl;
-};
-
-struct aicbsp_info_t {
-    int hwinfo;
-    uint32_t cpmode;
-};
-
-#define AICBT_PT_TAG          "AICBT_PT_TAG"
-#define AICBT_PT_TRAP         0x01
-#define AICBT_PT_B4           0x02
-#define AICBT_PT_BTMODE       0x03
-#define AICBT_PT_PWRON        0x04
-#define AICBT_PT_AF           0x05
-
-enum aicbt_btport_type {
-    AICBT_BTPORT_NULL,
-    AICBT_BTPORT_MB,
-    AICBT_BTPORT_UART,
-};
-
-/*  btmode
- * used for force bt mode,if not AICBSP_MODE_NULL
- * efuse valid and vendor_info will be invalid, even has beed set valid
-*/
-enum aicbt_btmode_type {
-    AICBT_BTMODE_BT_ONLY_SW = 0x0,    // bt only mode with switch
-    AICBT_BTMODE_BT_WIFI_COMBO,       // wifi/bt combo mode
-    AICBT_BTMODE_BT_ONLY,             // bt only mode without switch
-    AICBT_BTMODE_BT_ONLY_TEST,        // bt only test mode
-    AICBT_BTMODE_BT_WIFI_COMBO_TEST,  // wifi/bt combo test mode
-    AICBT_BTMODE_BT_ONLY_COANT,       // bt only mode with no external switch
-    AICBT_MODE_NULL = 0xFF,           // invalid value
-};
-
-/*  uart_baud
- * used for config uart baud when btport set to uart,
- * otherwise meaningless
-*/
-enum aicbt_uart_baud_type {
-    AICBT_UART_BAUD_115200     = 115200,
-    AICBT_UART_BAUD_921600     = 921600,
-    AICBT_UART_BAUD_1_5M       = 1500000,
-    AICBT_UART_BAUD_3_25M      = 3250000,
-};
-
-enum aicbt_uart_flowctrl_type {
-    AICBT_UART_FLOWCTRL_DISABLE = 0x0,    // uart without flow ctrl
-    AICBT_UART_FLOWCTRL_ENABLE,           // uart with flow ctrl
-};
-
-enum aicbsp_cpmode_type {
-    AICBSP_CPMODE_WORK,
-    AICBSP_CPMODE_TEST,
-};
-#define AIC_M2D_OTA_INFO_ADDR       0x88000020
-#define AIC_M2D_OTA_DATA_ADDR       0x88000040
-#define AIC_M2D_OTA_FLASH_ADDR      0x08004000
-#define AIC_M2D_OTA_CODE_START_ADDR 0x08004188
-#define AIC_M2D_OTA_VER_ADDR        0x0800418c
-///aic bt tx pwr lvl :lsb->msb: first byte, min pwr lvl; second byte, max pwr lvl;
-///pwr lvl:20(min), 30 , 40 , 50 , 60(max)
-#define AICBT_TXPWR_LVL            0x00006020
-#define AICBT_TXPWR_LVL_D80        0x00006F2F
-
-#define AICBSP_MODE_BT_HCI_MODE_NULL              0
-#define AICBSP_MODE_BT_HCI_MODE_MB                1
-#define AICBSP_MODE_BT_HCI_MODE_UART              2
-
-#define AICBSP_HWINFO_DEFAULT       (-1)
-#define AICBSP_CPMODE_DEFAULT       AICBSP_CPMODE_WORK
-
-#define AICBT_BTMODE_DEFAULT        AICBT_BTMODE_BT_ONLY
-#define AICBT_BTPORT_DEFAULT        AICBT_BTPORT_MB
-#define AICBT_UART_BAUD_DEFAULT     AICBT_UART_BAUD_1_5M
-#define AICBT_UART_FC_DEFAULT       AICBT_UART_FLOWCTRL_ENABLE
-#define AICBT_LPM_ENABLE_DEFAULT    0
-#define AICBT_TXPWR_LVL_DEFAULT     AICBT_TXPWR_LVL
-
-#define AIC_HW_INFO 0x21
-
-#define FW_PATH_MAX 200
-#if defined(CONFIG_PLATFORM_UBUNTU)
-static const char* aic_default_fw_path = "/lib/firmware";
-#else
-static const char* aic_default_fw_path = "/lib/firmware/aic8800";
-#endif
-char aic_fw_path[FW_PATH_MAX];
-module_param_string(aic_fw_path, aic_fw_path, FW_PATH_MAX, 0660);
-#ifdef CONFIG_M2D_OTA_AUTO_SUPPORT
-char saved_sdk_ver[64];
-module_param_string(saved_sdk_ver, saved_sdk_ver,64, 0660);
-#endif
-
-
-int aic_bt_platform_init(struct aic_usb_dev *usbdev)
-{
-    rwnx_cmd_mgr_init(&usbdev->cmd_mgr);
-    usbdev->cmd_mgr.usbdev = (void *)usbdev;
-    return 0;
-
-}
-
-void aic_bt_platform_deinit(struct aic_usb_dev *usbdev)
-{
-
-}
-
-#define MD5(x) x[0],x[1],x[2],x[3],x[4],x[5],x[6],x[7],x[8],x[9],x[10],x[11],x[12],x[13],x[14],x[15]
-#define MD5PINRT "file md5:%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\r\n"
-
-static int aic_load_firmware(u32 ** fw_buf, const char *name, struct device *device)
-{
-
-#ifdef CONFIG_USE_FW_REQUEST
-	const struct firmware *fw = NULL;
-	u32 *dst = NULL;
-	void *buffer=NULL;
-	MD5_CTX md5;
-	unsigned char decrypt[16];
-	int size = 0;
-	int ret = 0;
-
-	printk("%s: request firmware = %s \n", __func__ ,name);
-
-
-	ret = request_firmware(&fw, name, NULL);
-	
-	if (ret < 0) {
-		printk("Load %s fail\n", name);
-		release_firmware(fw);
-		return -1;
-	}
-	
-	size = fw->size;
-	dst = (u32 *)fw->data;
-
-	if (size <= 0) {
-		printk("wrong size of firmware file\n");
-		release_firmware(fw);
-		return -1;
-	}
-
-
-	buffer = vmalloc(size);
-	memset(buffer, 0, size);
-	memcpy(buffer, dst, size);
-	
-	*fw_buf = buffer;
-
-	MD5Init(&md5);
-	MD5Update(&md5, (unsigned char *)buffer, size);
-	MD5Final(&md5, decrypt);
-	printk(MD5PINRT, MD5(decrypt));
-	
-	release_firmware(fw);
-	
-	return size;
-#else
-    void *buffer=NULL;
-    char *path=NULL;
-    struct file *fp=NULL;
-    int size = 0, len=0, i=0;
-    ssize_t rdlen=0;
-    u32 *src=NULL, *dst = NULL;
-	MD5_CTX md5;
-	unsigned char decrypt[16];
-#if defined(CONFIG_PLATFORM_UBUNTU)
-    struct aicwf_bus *bus_if = dev_get_drvdata(device);
-    struct aic_usb_dev *usb_dev = bus_if->bus_priv.usb;
-#endif
-
-    /* get the firmware path */
-    path = __getname();
-    if (!path){
-            *fw_buf=NULL;
-            return -1;
-    }
-
-    if (strlen(aic_fw_path) > 0) {
-		printk("%s: use customer define fw_path\n", __func__);
-		len = snprintf(path, FW_PATH_MAX, "%s/%s", aic_fw_path, name);
-    } else {
-    #if defined(CONFIG_PLATFORM_UBUNTU)
-        if (usb_dev->chipid == PRODUCT_ID_AIC8800) {
-            len = snprintf(path, FW_PATH_MAX, "%s/%s/%s",aic_default_fw_path, "aic8800", name);
-        } else if (usb_dev->chipid == PRODUCT_ID_AIC8800D80) {
-            len = snprintf(path, FW_PATH_MAX, "%s/%s/%s",aic_default_fw_path, "aic8800D80", name);
-        } else {
-            printk("%s unknown chipid %d\n", __func__, usb_dev->chipid);
-        }
-	#else
-		len = snprintf(path, FW_PATH_MAX, "%s/%s",aic_default_fw_path, name);
-	#endif
-    }
-
-    if (len >= FW_PATH_MAX) {
-    	printk("%s: %s file's path too long\n", __func__, name);
-        *fw_buf=NULL;
-        __putname(path);
-        return -1;
-    }
-
-    printk("%s :firmware path = %s  \n", __func__ ,path);
-
-
-    /* open the firmware file */
-    fp=filp_open(path, O_RDONLY, 0);
-    if(IS_ERR(fp) || (!fp)){
-            printk("%s: %s file failed to open\n", __func__, name);
-            if(IS_ERR(fp))
-		printk("is_Err\n");
-	if((!fp))
-		printk("null\n");
-	*fw_buf=NULL;
-            __putname(path);
-            fp=NULL;
-            return -1;
-    }
-
-    size = i_size_read(file_inode(fp));
-    if(size<=0){
-            printk("%s: %s file size invalid %d\n", __func__, name, size);
-            *fw_buf=NULL;
-            __putname(path);
-            filp_close(fp,NULL);
-            fp=NULL;
-            return -1;
-}
-
-    /* start to read from firmware file */
-    buffer = vmalloc(size);
-    memset(buffer, 0, size);
-    if(!buffer){
-            *fw_buf=NULL;
-            __putname(path);
-            filp_close(fp,NULL);
-            fp=NULL;
-            return -1;
-    }
-
-
-    #if LINUX_VERSION_CODE > KERNEL_VERSION(4, 13, 16)
-    rdlen = kernel_read(fp, buffer, size, &fp->f_pos);
-    #else
-    rdlen = kernel_read(fp, fp->f_pos, buffer, size);
-    #endif
-
-    if(size != rdlen){
-            printk("%s: %s file rdlen invalid %d %d\n", __func__, name, (int)rdlen, size);
-            *fw_buf=NULL;
-            __putname(path);
-            filp_close(fp,NULL);
-            fp=NULL;
-            vfree(buffer);
-            buffer=NULL;
-            return -1;
-    }
-    if(rdlen > 0){
-            fp->f_pos += rdlen;
-            //printk("f_pos=%d\n", (int)fp->f_pos);
-    }
-
-
-   /*start to transform the data format*/
-    src = (u32*)buffer;
-    //printk("malloc dst\n");
-    dst = (u32*)vmalloc(size);
-    memset(dst, 0, size);
-
-    if(!dst){
-            *fw_buf=NULL;
-            __putname(path);
-            filp_close(fp,NULL);
-            fp=NULL;
-            vfree(buffer);
-            buffer=NULL;
-            return -1;
-    }
-
-    for(i=0;i<(size/4);i++){
-            dst[i] = src[i];
-    }
-
-    __putname(path);
-    filp_close(fp,NULL);
-    fp=NULL;
-    vfree(buffer);
-    buffer=NULL;
-    *fw_buf = dst;
-
-	MD5Init(&md5);
-	MD5Update(&md5, (unsigned char *)dst, size);
-	MD5Final(&md5, decrypt);
-
-	printk(MD5PINRT, MD5(decrypt));
-
-    return size;
-#endif
-
-}
-
-int rwnx_plat_bin_fw_upload_android(struct aic_usb_dev *usbdev, u32 fw_addr,
-                               char *filename)
-{
-    struct device *dev = usbdev->dev;
-    unsigned int i=0;
-    int size;
-    u32 *dst=NULL;
-    int err=0;
-
-    /* load aic firmware */
-    size = aic_load_firmware(&dst, filename, dev);
-    if(size<=0){
-            printk("wrong size of firmware file\n");
-            vfree(dst);
-            dst = NULL;
-            return -1;
-    }
-
-    /* Copy the file on the Embedded side */
-    printk("### Upload %s firmware, @ = %x  size=%d\n", filename, fw_addr, size);
-
-    if (size > 1024) {// > 1KB data
-        for (i = 0; i < (size - 1024); i += 1024) {//each time write 1KB
-            err = rwnx_send_dbg_mem_block_write_req(usbdev, fw_addr + i, 1024, dst + i / 4);
-                if (err) {
-                printk("bin upload fail: %x, err:%d\r\n", fw_addr + i, err);
-                break;
-            }
-        }
-    }
-
-    if (!err && (i < size)) {// <1KB data
-        err = rwnx_send_dbg_mem_block_write_req(usbdev, fw_addr + i, size - i, dst + i / 4);
-        if (err) {
-            printk("bin upload fail: %x, err:%d\r\n", fw_addr + i, err);
-        }
-    }
-
-    if (dst) {
-        vfree(dst);
-        dst = NULL;
-    }
-
-    printk("fw download complete\n\n");
-
-    return err;
-}
-
-extern int testmode;
-#ifdef CONFIG_M2D_OTA_AUTO_SUPPORT
-int rwnx_plat_m2d_flash_ota_android(struct aic_usb_dev *usbdev, char *filename)
-{
-    struct device *dev = usbdev->dev;
-    unsigned int i=0;
-    int size;
-    u32 *dst=NULL;
-    int err=0;
-	int ret;
-	u8 bond_id;
-    const u32 mem_addr = 0x40500000;
-    struct dbg_mem_read_cfm rd_mem_addr_cfm;
-
-    ret = rwnx_send_dbg_mem_read_req(usbdev, mem_addr, &rd_mem_addr_cfm);
-    if (ret) {
-        printk("m2d %x rd fail: %d\n", mem_addr, ret);
-        return ret;
-    }
-    bond_id = (u8)(rd_mem_addr_cfm.memdata >> 24);
-    printk("%x=%x\n", rd_mem_addr_cfm.memaddr, rd_mem_addr_cfm.memdata);
-	if (bond_id & (1<<1)) {
-		//flash is invalid
-		printk("m2d flash is invalid\n");
-		return -1;
-	}
-
-    /* load aic firmware */
-    size = aic_load_firmware(&dst, filename, dev);
-    if(size<=0){
-            printk("wrong size of m2d file\n");
-            vfree(dst);
-            dst = NULL;
-            return -1;
-    }
-
-    /* Copy the file on the Embedded side */
-    printk("### Upload m2d %s flash, size=%d\n", filename, size);
-
-	/*send info first*/
-	err = rwnx_send_dbg_mem_block_write_req(usbdev, AIC_M2D_OTA_INFO_ADDR, 4, (u32 *)&size);
-	
-	/*send data first*/
-    if (size > 1024) {// > 1KB data
-        for (i = 0; i < (size - 1024); i += 1024) {//each time write 1KB
-            err = rwnx_send_dbg_mem_block_write_req(usbdev, AIC_M2D_OTA_DATA_ADDR, 1024, dst + i / 4);
-                if (err) {
-                printk("m2d upload fail: %x, err:%d\r\n", AIC_M2D_OTA_DATA_ADDR, err);
-                break;
-            }
-        }
-    }
-
-    if (!err && (i < size)) {// <1KB data
-        err = rwnx_send_dbg_mem_block_write_req(usbdev, AIC_M2D_OTA_DATA_ADDR, size - i, dst + i / 4);
-        if (err) {
-            printk("m2d upload fail: %x, err:%d\r\n", AIC_M2D_OTA_DATA_ADDR, err);
-        }
-    }
-
-    if (dst) {
-        vfree(dst);
-        dst = NULL;
-    }
-	testmode = FW_NORMAL_MODE;
-
-    printk("m2d flash update complete\n\n");
-
-    return err;
-}
-
-int rwnx_plat_m2d_flash_ota_check(struct aic_usb_dev *usbdev, char *filename)
-{
-    struct device *dev = usbdev->dev;
-    unsigned int i=0,j=0;
-    int size;
-    u32 *dst=NULL;
-    int err=0;
-	int ret=0;
-	u8 bond_id;
-    const u32 mem_addr = 0x40500000;
-	const u32 mem_addr_code_start = AIC_M2D_OTA_CODE_START_ADDR;
-	const u32 mem_addr_sdk_ver = AIC_M2D_OTA_VER_ADDR;
-	const u32 driver_code_start_idx = (AIC_M2D_OTA_CODE_START_ADDR-AIC_M2D_OTA_FLASH_ADDR)/4;
-	const u32 driver_sdk_ver_idx = (AIC_M2D_OTA_VER_ADDR-AIC_M2D_OTA_FLASH_ADDR)/4;
-	u32 driver_sdk_ver_addr_idx = 0;
-	u32 code_start_addr = 0xffffffff;
-	u32 sdk_ver_addr = 0xffffffff;
-	u32 drv_code_start_addr = 0xffffffff;
-	u32 drv_sdk_ver_addr = 0xffffffff;
-    struct dbg_mem_read_cfm rd_mem_addr_cfm;
-	char m2d_sdk_ver[64];
-	char flash_sdk_ver[64];
-	u32 flash_ver[16];
-	u32 ota_ver[16];
-
-    ret = rwnx_send_dbg_mem_read_req(usbdev, mem_addr, &rd_mem_addr_cfm);
-    if (ret) {
-        printk("m2d %x rd fail: %d\n", mem_addr, ret);
-        return ret;
-    }
-    bond_id = (u8)(rd_mem_addr_cfm.memdata >> 24);
-    printk("%x=%x\n", rd_mem_addr_cfm.memaddr, rd_mem_addr_cfm.memdata);
-	if (bond_id & (1<<1)) {
-		//flash is invalid
-		printk("m2d flash is invalid\n");
-		return -1;
-	}
-    ret = rwnx_send_dbg_mem_read_req(usbdev, mem_addr_code_start, &rd_mem_addr_cfm);
-	if (ret){
-        printk("mem_addr_code_start %x rd fail: %d\n", mem_addr_code_start, ret);
-        return ret;
-	}
-	code_start_addr = rd_mem_addr_cfm.memdata;
-
-    ret = rwnx_send_dbg_mem_read_req(usbdev, mem_addr_sdk_ver, &rd_mem_addr_cfm);
-	if (ret){
-        printk("mem_addr_sdk_ver %x rd fail: %d\n", mem_addr_code_start, ret);
-        return ret;
-	}
-	sdk_ver_addr = rd_mem_addr_cfm.memdata;
-	printk("code_start_addr: 0x%x,  sdk_ver_addr: 0x%x\n", code_start_addr,sdk_ver_addr);
-
-	/* load aic firmware */
-	size = aic_load_firmware(&dst, filename, dev);
-	if(size<=0){
-			printk("wrong size of m2d file\n");
-			vfree(dst);
-			dst = NULL;
-			return -1;
-	}
-	if(code_start_addr == 0xffffffff && sdk_ver_addr == 0xffffffff) {
-		printk("########m2d flash old version , must be upgrade\n");
-		drv_code_start_addr = dst[driver_code_start_idx];
-		drv_sdk_ver_addr = dst[driver_sdk_ver_idx];
-
-		printk("drv_code_start_addr: 0x%x,	drv_sdk_ver_addr: 0x%x\n", drv_code_start_addr,drv_sdk_ver_addr);
-
-		if(drv_sdk_ver_addr == 0xffffffff){
-			printk("########driver m2d_ota.bin is old ,not need upgrade\n");
-			return -1;
-		}
-
-	} else {
-		for(i=0;i<16;i++){
-			ret = rwnx_send_dbg_mem_read_req(usbdev, (sdk_ver_addr+i*4), &rd_mem_addr_cfm);
-			if (ret){
-				printk("mem_addr_sdk_ver %x rd fail: %d\n", mem_addr_code_start, ret);
-				return ret;
-			}
-			flash_ver[i] = rd_mem_addr_cfm.memdata;
-		}
-		memcpy((u8 *)flash_sdk_ver,(u8 *)flash_ver,64);
-        memcpy((u8 *)saved_sdk_ver,(u8 *)flash_sdk_ver,64);
-		printk("flash SDK Version: %s\r\n\r\n", flash_sdk_ver);
-				
-		drv_code_start_addr = dst[driver_code_start_idx];
-		drv_sdk_ver_addr = dst[driver_sdk_ver_idx];
-
-		printk("drv_code_start_addr: 0x%x,	drv_sdk_ver_addr: 0x%x\n", drv_code_start_addr,drv_sdk_ver_addr);
-
-		if(drv_sdk_ver_addr == 0xffffffff){
-			printk("########driver m2d_ota.bin is old ,not need upgrade\n");
-			return -1;
-		}
-
-		driver_sdk_ver_addr_idx = (drv_sdk_ver_addr-drv_code_start_addr)/4;
-		printk("driver_sdk_ver_addr_idx %d\n",driver_sdk_ver_addr_idx);
-
-		if (driver_sdk_ver_addr_idx){
-			for(j = 0; j < 16; j++){
-				ota_ver[j] = dst[driver_sdk_ver_addr_idx+j];
-			}
-			memcpy((u8 *)m2d_sdk_ver,(u8 *)ota_ver,64);
-			printk("m2d_ota SDK Version: %s\r\n\r\n", m2d_sdk_ver);
-		} else {
-			return -1;
-		}
-		
-		if(!strcmp(m2d_sdk_ver,flash_sdk_ver)){
-			printk("######## m2d %s flash is not need upgrade\r\n", filename);
-			return -1;
-		}
-	}
-
-    /* Copy the file on the Embedded side */
-    printk("### Upload m2d %s flash, size=%d\n", filename, size);
-
-	/*send info first*/
-	err = rwnx_send_dbg_mem_block_write_req(usbdev, AIC_M2D_OTA_INFO_ADDR, 4, (u32 *)&size);
-	
-	/*send data first*/
-    if (size > 1024) {// > 1KB data
-        for (i = 0; i < (size - 1024); i += 1024) {//each time write 1KB
-            err = rwnx_send_dbg_mem_block_write_req(usbdev, AIC_M2D_OTA_DATA_ADDR, 1024, dst + i / 4);
-                if (err) {
-                printk("m2d upload fail: %x, err:%d\r\n", AIC_M2D_OTA_DATA_ADDR, err);
-                break;
-            }
-        }
-    }
-
-    if (!err && (i < size)) {// <1KB data
-        err = rwnx_send_dbg_mem_block_write_req(usbdev, AIC_M2D_OTA_DATA_ADDR, size - i, dst + i / 4);
-        if (err) {
-            printk("m2d upload fail: %x, err:%d\r\n", AIC_M2D_OTA_DATA_ADDR, err);
-        }
-    }
-
-    if (dst) {
-        vfree(dst);
-        dst = NULL;
-    }
-	testmode = FW_NORMAL_MODE;
-
-    printk("m2d flash update complete\n\n");
-
-    return err;
-}
-#endif//CONFIG_M2D_OTA_AUTO_SUPPORT
-
-uint32_t rwnx_atoli(char *value){
-	int len = 0;
-	int temp_len = 0;
-	int i = 0;
-	uint32_t result = 0;
-	
-	temp_len = strlen(value);
-
-	for(i = 0;i < temp_len; i++){
-		if((value[i] >= 48 && value[i] <= 57) ||
-			(value[i] >= 65 && value[i] <= 70) ||
-			(value[i] >= 97 && value[i] <= 102)){
-			len++;
-		}
-	}
-
-	//printk("%s len:%d \r\n", __func__, len);
-	
-	for(i = 0; i < len; i++){
-		result = result * 16;
-		if(value[i] >= 48 && value[i] <= 57){
-			result += value[i] - 48;
-		}else if(value[i] >= 65 && value[i] <= 70){
-			result += (value[i] - 65) + 10;
-		}else if(value[i] >= 97 && value[i] <= 102){
-			result += (value[i] - 97) + 10;
-		}
-	}
-	
-	return result;
-}
-
-int8_t rwnx_atoi(char *value){
-	int len = 0;
-	int i = 0;
-	int8_t result = 0;
-	int8_t signal = 1;
-
-	len = strlen(value);
-	//printk("%s len:%d \r\n", __func__, len);
-
-	for(i = 0;i < len ;i++){
-		if(i == 0 && value[0] == '-'){
-			signal = -1;
-			continue;
-		}
-
-		result = result * 10;
-		if(value[i] >= 48 && value[i] <= 57){
-			result += value[i] - 48;
-		}else{
-			result = 0;
-			break;
-		}
-	}
-
-	result = result * signal;
-	//printk("%s result:%d \r\n", __func__, result);
-
-	return result;
-}
-
-void get_fw_path(char* fw_path){
-	if (strlen(aic_fw_path) > 0) {
-		memcpy(fw_path, aic_fw_path, strlen(aic_fw_path));
-	}else{
-		memcpy(fw_path, aic_default_fw_path, strlen(aic_default_fw_path));
-	}
-} 
-
-void set_testmode(int val){
-	testmode = val;
-}
-
-int get_testmode(void){
-	return testmode;
-}
-
-int get_hardware_info(void){
-	return AIC_HW_INFO;
-}
-
-extern int adap_test;
-int get_adap_test(void){
-    return adap_test;
-}
-
-EXPORT_SYMBOL(get_fw_path);
-
-EXPORT_SYMBOL(get_testmode);
-
-EXPORT_SYMBOL(set_testmode);
-
-EXPORT_SYMBOL(get_hardware_info);
-
-EXPORT_SYMBOL(get_adap_test);
-
-
-void get_userconfig_xtal_cap(xtal_cap_conf_t *xtal_cap)
-{
-	xtal_cap->enable = userconfig_xtal_cap.enable;
-	xtal_cap->xtal_cap = userconfig_xtal_cap.xtal_cap;
-	xtal_cap->xtal_cap_fine = userconfig_xtal_cap.xtal_cap_fine;
-
-    printk("%s:enable       :%d\r\n", __func__, xtal_cap->enable);
-    printk("%s:xtal_cap     :%d\r\n", __func__, xtal_cap->xtal_cap);
-    printk("%s:xtal_cap_fine:%d\r\n", __func__, xtal_cap->xtal_cap_fine);
-}
-
-EXPORT_SYMBOL(get_userconfig_xtal_cap);
-
-void get_userconfig_txpwr_idx(txpwr_idx_conf_t *txpwr_idx){
-	txpwr_idx->enable = userconfig_txpwr_idx.enable;
-	txpwr_idx->dsss = userconfig_txpwr_idx.dsss;
-	txpwr_idx->ofdmlowrate_2g4 = userconfig_txpwr_idx.ofdmlowrate_2g4;
-	txpwr_idx->ofdm64qam_2g4 = userconfig_txpwr_idx.ofdm64qam_2g4;
-	txpwr_idx->ofdm256qam_2g4 = userconfig_txpwr_idx.ofdm256qam_2g4;
-	txpwr_idx->ofdm1024qam_2g4 = userconfig_txpwr_idx.ofdm1024qam_2g4;
-	txpwr_idx->ofdmlowrate_5g = userconfig_txpwr_idx.ofdmlowrate_5g;
-	txpwr_idx->ofdm64qam_5g = userconfig_txpwr_idx.ofdm64qam_5g;
-	txpwr_idx->ofdm256qam_5g = userconfig_txpwr_idx.ofdm256qam_5g;
-	txpwr_idx->ofdm1024qam_5g = userconfig_txpwr_idx.ofdm1024qam_5g;
-
-	printk("%s:enable:%d\r\n", __func__, txpwr_idx->enable);
-	printk("%s:dsss:%d\r\n", __func__, txpwr_idx->dsss);
-	printk("%s:ofdmlowrate_2g4:%d\r\n", __func__, txpwr_idx->ofdmlowrate_2g4);
-	printk("%s:ofdm64qam_2g4:%d\r\n", __func__, txpwr_idx->ofdm64qam_2g4);
-	printk("%s:ofdm256qam_2g4:%d\r\n", __func__, txpwr_idx->ofdm256qam_2g4);
-	printk("%s:ofdm1024qam_2g4:%d\r\n", __func__, txpwr_idx->ofdm1024qam_2g4);
-	printk("%s:ofdmlowrate_5g:%d\r\n", __func__, txpwr_idx->ofdmlowrate_5g);
-	printk("%s:ofdm64qam_5g:%d\r\n", __func__, txpwr_idx->ofdm64qam_5g);
-	printk("%s:ofdm256qam_5g:%d\r\n", __func__, txpwr_idx->ofdm256qam_5g);
-	printk("%s:ofdm1024qam_5g:%d\r\n", __func__, txpwr_idx->ofdm1024qam_5g);
-
-}
-
-EXPORT_SYMBOL(get_userconfig_txpwr_idx);
-
-void get_userconfig_txpwr_ofst(txpwr_ofst_conf_t *txpwr_ofst){
-	txpwr_ofst->enable = userconfig_txpwr_ofst.enable;
-	txpwr_ofst->chan_1_4 = userconfig_txpwr_ofst.chan_1_4;
-	txpwr_ofst->chan_5_9 = userconfig_txpwr_ofst.chan_5_9;
-	txpwr_ofst->chan_10_13 = userconfig_txpwr_ofst.chan_10_13;
-	txpwr_ofst->chan_36_64 = userconfig_txpwr_ofst.chan_36_64;
-	txpwr_ofst->chan_100_120 = userconfig_txpwr_ofst.chan_100_120;
-	txpwr_ofst->chan_122_140 = userconfig_txpwr_ofst.chan_122_140;
-	txpwr_ofst->chan_142_165 = userconfig_txpwr_ofst.chan_142_165;
-
-	printk("%s:ofst_enable:%d\r\n", __func__, txpwr_ofst->enable);
-	printk("%s:ofst_chan_1_4:%d\r\n", __func__, txpwr_ofst->chan_1_4);
-	printk("%s:ofst_chan_5_9:%d\r\n", __func__, txpwr_ofst->chan_5_9);
-	printk("%s:ofst_chan_10_13:%d\r\n", __func__, txpwr_ofst->chan_10_13);
-	printk("%s:ofst_chan_36_64:%d\r\n", __func__, txpwr_ofst->chan_36_64);
-	printk("%s:ofst_chan_100_120:%d\r\n", __func__, txpwr_ofst->chan_100_120);
-	printk("%s:ofst_chan_122_140:%d\r\n", __func__, txpwr_ofst->chan_122_140);
-	printk("%s:ofst_chan_142_165:%d\r\n", __func__, txpwr_ofst->chan_142_165);
-
-}
-
-EXPORT_SYMBOL(get_userconfig_txpwr_ofst);
-
-void rwnx_plat_userconfig_set_value(char *command, char *value){	
-	//TODO send command
-	printk("%s:command=%s value=%s \r\n", __func__, command, value);
-	if(!strcmp(command, "enable")){
-		userconfig_txpwr_idx.enable = rwnx_atoi(value);
-	}else if(!strcmp(command, "dsss")){
-		userconfig_txpwr_idx.dsss = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofdmlowrate_2g4")){
-		userconfig_txpwr_idx.ofdmlowrate_2g4 = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofdm64qam_2g4")){
-		userconfig_txpwr_idx.ofdm64qam_2g4 = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofdm256qam_2g4")){
-		userconfig_txpwr_idx.ofdm256qam_2g4 = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofdm1024qam_2g4")){
-		userconfig_txpwr_idx.ofdm1024qam_2g4 = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofdmlowrate_5g")){
-		userconfig_txpwr_idx.ofdmlowrate_5g = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofdm64qam_5g")){
-		userconfig_txpwr_idx.ofdm64qam_5g = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofdm256qam_5g")){
-		userconfig_txpwr_idx.ofdm256qam_5g = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofdm1024qam_5g")){
-		userconfig_txpwr_idx.ofdm1024qam_5g = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofst_enable")){
-		userconfig_txpwr_ofst.enable = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofst_chan_1_4")){
-		userconfig_txpwr_ofst.chan_1_4 = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofst_chan_5_9")){
-		userconfig_txpwr_ofst.chan_5_9 = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofst_chan_10_13")){
-		userconfig_txpwr_ofst.chan_10_13 = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofst_chan_36_64")){
-		userconfig_txpwr_ofst.chan_36_64 = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofst_chan_100_120")){
-		userconfig_txpwr_ofst.chan_100_120 = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofst_chan_122_140")){
-		userconfig_txpwr_ofst.chan_122_140 = rwnx_atoi(value);
-	}else if(!strcmp(command, "ofst_chan_142_165")){
-		userconfig_txpwr_ofst.chan_142_165 = rwnx_atoi(value);
-	}else if(!strcmp(command, "xtal_enable")){
-		userconfig_xtal_cap.enable = rwnx_atoi(value);
-	}else if(!strcmp(command, "xtal_cap")){
-		userconfig_xtal_cap.xtal_cap = rwnx_atoi(value);
-	}else if(!strcmp(command, "xtal_cap_fine")){
-		userconfig_xtal_cap.xtal_cap_fine = rwnx_atoi(value);
-	}
-}
-
-void rwnx_plat_userconfig_parsing(char *buffer, int size){
-    int i = 0;
-	int parse_state = 0;
-	char command[30];
-	char value[100];
-	int char_counter = 0;
-
-	memset(command, 0, 30);
-	memset(value, 0, 100);
-
-    for(i = 0; i < size; i++){
-
-		//Send command or print nvram log when char is \r or \n
-		if(buffer[i] == 0x0a || buffer[i] == 0x0d){
-			if(command[0] != 0 && value[0] != 0){
-				if(parse_state == PRINT){
-					printk("%s:%s\r\n", __func__, value);
-				}else if(parse_state == GET_VALUE){
-					rwnx_plat_userconfig_set_value(command, value);
-				}
-			}
-			//Reset command value and char_counter
-			memset(command, 0, 30);
-			memset(value, 0, 100);
-			char_counter = 0;
-			parse_state = INIT;
-			continue;
-		}
-
-		//Switch parser state
-		if(parse_state == INIT){
-			if(buffer[i] == '#'){
-				parse_state = PRINT;
-				continue;
-			}else if(buffer[i] == 0x0a || buffer[i] == 0x0d){
-				parse_state = INIT;
-				continue;
-			}else{
-				parse_state = CMD;
-			}
-		}
-
-		//Fill data to command and value
-		if(parse_state == PRINT){
-			command[0] = 0x01;
-			value[char_counter] = buffer[i];
-			char_counter++;
-		}else if(parse_state == CMD){
-			if(command[0] != 0 && buffer[i] == '='){
-				parse_state = GET_VALUE;
-				char_counter = 0;
-				continue;
-			}
-			command[char_counter] = buffer[i];
-			char_counter++;
-		}else if(parse_state == GET_VALUE){
-			value[char_counter] = buffer[i];
-			char_counter++;
-		}
-	}
-
-
-}
-
-int rwnx_plat_userconfig_upload_android(struct aic_usb_dev *usbdev, char *filename){
-    int size;
-    u32 *dst=NULL;
-    struct device *dev = usbdev->dev;
-
-	printk("userconfig file path:%s \r\n", filename);
-
-    /* load aic firmware */
-    size = aic_load_firmware(&dst, filename, dev);
-    if(size <= 0){
-            printk("wrong size of firmware file\n");
-            vfree(dst);
-            dst = NULL;
-            return 0;
-    }
-
-	/* Copy the file on the Embedded side */
-    printk("### Upload %s userconfig, size=%d\n", filename, size);
-
-	rwnx_plat_userconfig_parsing((char *)dst, size);
-
-	if (dst) {
-        vfree(dst);
-        dst = NULL;
-    }
-
-	printk("userconfig download complete\n\n");
-	return 0;
-}
-
-
-
-int aicbt_patch_table_free(struct aicbt_patch_table **head)
-{
-	struct aicbt_patch_table *p = *head, *n = NULL;
-	while (p) {
-		n = p->next;
-		vfree(p->name);
-		vfree(p->data);
-		vfree(p);
-		p = n;
-	}
-	*head = NULL;
-	return 0;
-}
-
-struct aicbsp_info_t aicbsp_info = {
-    .hwinfo   = AICBSP_HWINFO_DEFAULT,
-    .cpmode   = AICBSP_CPMODE_DEFAULT,
-};
-
-static struct aicbt_info_t aicbt_info = {
-    .btmode        = AICBT_BTMODE_DEFAULT,
-    .btport        = AICBT_BTPORT_DEFAULT,
-    .uart_baud     = AICBT_UART_BAUD_DEFAULT,
-    .uart_flowctrl = AICBT_UART_FC_DEFAULT,
-    .lpm_enable    = AICBT_LPM_ENABLE_DEFAULT,
-    .txpwr_lvl     = AICBT_TXPWR_LVL_DEFAULT,
-};
-
-int aicbt_patch_table_load(struct aic_usb_dev *usbdev, struct aicbt_patch_table *_head)
-{
-	struct aicbt_patch_table *head, *p;
-	int ret = 0, i;
-	uint32_t *data = NULL;
-
-	head = _head;
-	if (usbdev->chipid == PRODUCT_ID_AIC8800D80) {
-		//aicbt_info.btmode = AICBT_BTMODE_BT_ONLY_COANT;
-		aicbt_info.txpwr_lvl = AICBT_TXPWR_LVL_D80;
-	}
-	for (p = head; p != NULL; p = p->next) {
-		data = p->data;
-		if(AICBT_PT_BTMODE == p->type){
-			*(data + 1)  = aicbsp_info.hwinfo < 0;
-			*(data + 3) = aicbsp_info.hwinfo;
-			*(data + 5)  = aicbsp_info.cpmode;
-
-			*(data + 7) = aicbt_info.btmode;
-			*(data + 9) = aicbt_info.btport;
-			*(data + 11) = aicbt_info.uart_baud;
-			*(data + 13) = aicbt_info.uart_flowctrl;
-			*(data + 15) = aicbt_info.lpm_enable;
-			*(data + 17) = aicbt_info.txpwr_lvl;
-
-		}
-		if (p->type == 0x06) {
-			char *data_s = (char *)p->data;
-			printk("patch version %s\n", data_s);
-			continue;
-		}
-		for (i = 0; i < p->len; i++) {
-			ret = rwnx_send_dbg_mem_write_req(usbdev, *data, *(data + 1));
-			if (ret != 0)
-				return ret;
-			data += 2;
-		}
-		if (p->type == AICBT_PT_PWRON)
-			udelay(500);
-	}
-	aicbt_patch_table_free(&head);
-	return 0;
-}
-
-
-int rwnx_plat_bin_fw_patch_table_upload_android(struct aic_usb_dev *usbdev, char *filename){
-    struct device *dev = usbdev->dev;
-	struct aicbt_patch_table *head = NULL;
-	struct aicbt_patch_table *new = NULL;
-	struct aicbt_patch_table *cur = NULL;
-   	 int size;
-	int ret = 0;
-   	uint8_t *rawdata=NULL;
-	uint8_t *p = NULL;
-
-    /* load aic firmware */
-    size = aic_load_firmware((u32 **)&rawdata, filename, dev);
-
-	/* Copy the file on the Embedded side */
-    printk("### Upload %s fw_patch_table, size=%d\n", filename, size);
-
-	if (size <= 0) {
-		printk("wrong size of firmware file\n");
-		ret = -1;
-		goto err;
-	}
-
-	p = rawdata;
-
-	if (memcmp(p, AICBT_PT_TAG, sizeof(AICBT_PT_TAG) < 16 ? sizeof(AICBT_PT_TAG) : 16)) {
-		printk("TAG err\n");
-		ret = -1;
-		goto err;
-	}
-	p += 16;
-
-	while (p - rawdata < size) {
-		//printk("size = %d  p - rawdata = %d \r\n", size, p - rawdata);
-		new = (struct aicbt_patch_table *)vmalloc(sizeof(struct aicbt_patch_table));
-		memset(new, 0, sizeof(struct aicbt_patch_table));
-		if (head == NULL) {
-			head = new;
-			cur  = new;
-		} else {
-			cur->next = new;
-			cur = cur->next;
-		}
-
-		cur->name = (char *)vmalloc(sizeof(char) * 16);
-		memset(cur->name, 0, sizeof(char) * 16);
-		memcpy(cur->name, p, 16);
-		p += 16;
-
-		cur->type = *(uint32_t *)p;
-		p += 4;
-
-		cur->len = *(uint32_t *)p;
-		p += 4;
-
-		if((cur->type )  >= 1000 || cur->len == 0) {//Temp Workaround
-			cur->len = 0;
-		}else{
-			cur->data = (uint32_t *)vmalloc(sizeof(uint8_t) * cur->len * 8);
-			memset(cur->data, 0, sizeof(uint8_t) * cur->len * 8);
-			memcpy(cur->data, p, cur->len * 8);
-			p += cur->len * 8;
-		}
-	}
-
-	vfree(rawdata);
-	aicbt_patch_table_load(usbdev, head);
-	printk("fw_patch_table download complete\n\n");
-
-	return ret;
-err:
-	//aicbt_patch_table_free(&head);
-
-	if (rawdata){
-		vfree(rawdata);
-	}
-	return ret;
-}
-
-
+#include <linux/version.h>
+#include <linux/vmalloc.h>
+#include "aicbluetooth_cmds.h"
+#include "aicwf_usb.h"
+#include "aic_txrxif.h"
+#include "md5.h"
+#include "aicbluetooth.h"
+#ifdef CONFIG_USE_FW_REQUEST
+#include <linux/firmware.h>
+#endif
+
+//Parser state
+#define INIT 0
+#define CMD 1
+#define PRINT 2
+#define GET_VALUE 3
+
+extern int flash_erase_len;
+
+typedef struct
+{
+    int8_t enable;
+    int8_t dsss;
+    int8_t ofdmlowrate_2g4;
+    int8_t ofdm64qam_2g4;
+    int8_t ofdm256qam_2g4;
+    int8_t ofdm1024qam_2g4;
+    int8_t ofdmlowrate_5g;
+    int8_t ofdm64qam_5g;
+    int8_t ofdm256qam_5g;
+    int8_t ofdm1024qam_5g;
+} txpwr_idx_conf_t;
+
+
+txpwr_idx_conf_t userconfig_txpwr_idx = {
+	.enable 		  = 1,
+	.dsss			  = 9,
+	.ofdmlowrate_2g4  = 8,
+	.ofdm64qam_2g4	  = 8,
+	.ofdm256qam_2g4   = 8,
+	.ofdm1024qam_2g4  = 8,
+	.ofdmlowrate_5g   = 11,
+	.ofdm64qam_5g	  = 10,
+	.ofdm256qam_5g	  = 9,
+	.ofdm1024qam_5g   = 9
+
+};
+
+typedef struct
+{
+    int8_t enable;
+    int8_t chan_1_4;
+    int8_t chan_5_9;
+    int8_t chan_10_13;
+    int8_t chan_36_64;
+    int8_t chan_100_120;
+    int8_t chan_122_140;
+    int8_t chan_142_165;
+} txpwr_ofst_conf_t;
+
+txpwr_ofst_conf_t userconfig_txpwr_ofst = {
+	.enable = 1,
+	.chan_1_4 = 0,
+	.chan_5_9 = 0,
+	.chan_10_13 = 0,
+	.chan_36_64 = 0,
+	.chan_100_120 = 0,
+	.chan_122_140 = 0,
+	.chan_142_165 = 0
+};
+
+typedef struct
+{
+    int8_t enable;
+    int8_t xtal_cap;
+    int8_t xtal_cap_fine;
+} xtal_cap_conf_t;
+
+
+xtal_cap_conf_t userconfig_xtal_cap = {
+	.enable = 0,
+	.xtal_cap = 24,
+	.xtal_cap_fine = 31,
+};
+
+struct aicbt_info_t {
+    uint32_t btmode;
+    uint32_t btport;
+    uint32_t uart_baud;
+    uint32_t uart_flowctrl;
+	uint32_t lpm_enable;
+	uint32_t txpwr_lvl;
+};
+
+struct aicbsp_info_t {
+    int hwinfo;
+    uint32_t cpmode;
+};
+
+
+enum aicbt_btport_type {
+    AICBT_BTPORT_NULL,
+    AICBT_BTPORT_MB,
+    AICBT_BTPORT_UART,
+};
+
+/*  btmode
+ * used for force bt mode,if not AICBSP_MODE_NULL
+ * efuse valid and vendor_info will be invalid, even has beed set valid
+*/
+enum aicbt_btmode_type {
+    AICBT_BTMODE_BT_ONLY_SW = 0x0,    // bt only mode with switch
+    AICBT_BTMODE_BT_WIFI_COMBO,       // wifi/bt combo mode
+    AICBT_BTMODE_BT_ONLY,             // bt only mode without switch
+    AICBT_BTMODE_BT_ONLY_TEST,        // bt only test mode
+    AICBT_BTMODE_BT_WIFI_COMBO_TEST,  // wifi/bt combo test mode
+    AICBT_BTMODE_BT_ONLY_COANT,       // bt only mode with no external switch
+    AICBT_MODE_NULL = 0xFF,           // invalid value
+};
+
+/*  uart_baud
+ * used for config uart baud when btport set to uart,
+ * otherwise meaningless
+*/
+enum aicbt_uart_baud_type {
+    AICBT_UART_BAUD_115200     = 115200,
+    AICBT_UART_BAUD_921600     = 921600,
+    AICBT_UART_BAUD_1_5M       = 1500000,
+    AICBT_UART_BAUD_3_25M      = 3250000,
+};
+
+enum aicbt_uart_flowctrl_type {
+    AICBT_UART_FLOWCTRL_DISABLE = 0x0,    // uart without flow ctrl
+    AICBT_UART_FLOWCTRL_ENABLE,           // uart with flow ctrl
+};
+
+enum aicbsp_cpmode_type {
+    AICBSP_CPMODE_WORK,
+    AICBSP_CPMODE_TEST,
+};
+#define AIC_M2D_OTA_INFO_ADDR       0x88000020
+#define AIC_M2D_OTA_DATA_ADDR       0x88000040
+#define AIC_M2D_OTA_FLASH_ADDR      0x08004000
+#define AIC_M2D_OTA_CODE_START_ADDR 0x08004188
+#define AIC_M2D_OTA_VER_ADDR        0x0800418c
+///aic bt tx pwr lvl :lsb->msb: first byte, min pwr lvl; second byte, max pwr lvl;
+///pwr lvl:20(min), 30 , 40 , 50 , 60(max)
+#define AICBT_TXPWR_LVL            0x00006020
+#define AICBT_TXPWR_LVL_8800d80     0x00006F2F
+
+#define AICBSP_MODE_BT_HCI_MODE_NULL              0
+#define AICBSP_MODE_BT_HCI_MODE_MB                1
+#define AICBSP_MODE_BT_HCI_MODE_UART              2
+
+#define AICBSP_HWINFO_DEFAULT       (-1)
+#define AICBSP_CPMODE_DEFAULT       AICBSP_CPMODE_WORK
+
+#define AICBT_BTMODE_DEFAULT_8800d80        AICBT_BTMODE_BT_ONLY_COANT
+#define AICBT_BTMODE_DEFAULT                AICBT_BTMODE_BT_ONLY
+#define AICBT_BTPORT_DEFAULT                AICBT_BTPORT_MB
+#define AICBT_UART_BAUD_DEFAULT             AICBT_UART_BAUD_1_5M
+#define AICBT_UART_FC_DEFAULT               AICBT_UART_FLOWCTRL_ENABLE
+#define AICBT_LPM_ENABLE_DEFAULT            0
+#define AICBT_TXPWR_LVL_DEFAULT             AICBT_TXPWR_LVL
+#define AICBT_TXPWR_LVL_DEFAULT_8800d80     AICBT_TXPWR_LVL_8800d80
+
+
+#define AIC_HW_INFO 0x21
+
+#define FW_PATH_MAX 200
+#if defined(CONFIG_PLATFORM_UBUNTU)
+static const char* aic_default_fw_path = "/lib/firmware";
+#else
+static const char* aic_default_fw_path = "/vendor/etc/firmware";
+#endif
+char aic_fw_path[FW_PATH_MAX];
+module_param_string(aic_fw_path, aic_fw_path, FW_PATH_MAX, 0660);
+#ifdef CONFIG_M2D_OTA_AUTO_SUPPORT
+char saved_sdk_ver[64];
+module_param_string(saved_sdk_ver, saved_sdk_ver,64, 0660);
+#endif
+
+
+int aic_bt_platform_init(struct aic_usb_dev *usbdev)
+{
+    rwnx_cmd_mgr_init(&usbdev->cmd_mgr);
+    usbdev->cmd_mgr.usbdev = (void *)usbdev;
+    return 0;
+
+}
+
+void aic_bt_platform_deinit(struct aic_usb_dev *usbdev)
+{
+	rwnx_cmd_mgr_deinit(&usbdev->cmd_mgr);
+}
+
+#define MD5(x) x[0],x[1],x[2],x[3],x[4],x[5],x[6],x[7],x[8],x[9],x[10],x[11],x[12],x[13],x[14],x[15]
+#define MD5PINRT "file md5:%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\r\n"
+
+static int aic_load_firmware(u32 ** fw_buf, const char *name, struct device *device)
+{
+
+#ifdef CONFIG_USE_FW_REQUEST
+	const struct firmware *fw = NULL;
+	u32 *dst = NULL;
+	void *buffer=NULL;
+	MD5_CTX md5;
+	unsigned char decrypt[16];
+	int size = 0;
+	int ret = 0;
+
+	printk("%s: request firmware = %s \n", __func__ ,name);
+
+
+	ret = request_firmware(&fw, name, NULL);
+	
+	if (ret < 0) {
+		printk("Load %s fail\n", name);
+		release_firmware(fw);
+		return -1;
+	}
+	
+	size = fw->size;
+	dst = (u32 *)fw->data;
+
+	if (size <= 0) {
+		printk("wrong size of firmware file\n");
+		release_firmware(fw);
+		return -1;
+	}
+
+
+	buffer = vmalloc(size);
+	memset(buffer, 0, size);
+	memcpy(buffer, dst, size);
+	
+	*fw_buf = buffer;
+
+	MD5Init(&md5);
+	MD5Update(&md5, (unsigned char *)buffer, size);
+	MD5Final(&md5, decrypt);
+	printk(MD5PINRT, MD5(decrypt));
+	
+	release_firmware(fw);
+	
+	return size;
+#else
+    void *buffer=NULL;
+    char *path=NULL;
+    struct file *fp=NULL;
+    int size = 0, len=0;//, i=0;
+    ssize_t rdlen=0;
+    //u32 *src=NULL, *dst = NULL;
+	MD5_CTX md5;
+	unsigned char decrypt[16];
+#if defined(CONFIG_PLATFORM_UBUNTU)
+    struct aicwf_bus *bus_if = dev_get_drvdata(device);
+    struct aic_usb_dev *usb_dev = bus_if->bus_priv.usb;
+#endif
+
+    /* get the firmware path */
+    path = __getname();
+    if (!path){
+            *fw_buf=NULL;
+            return -1;
+    }
+
+    if (strlen(aic_fw_path) > 0) {
+		printk("%s: use customer define fw_path\n", __func__);
+		len = snprintf(path, FW_PATH_MAX, "%s/%s", aic_fw_path, name);
+    } else {
+    #if defined(CONFIG_PLATFORM_UBUNTU)
+        if (usb_dev->chipid == PRODUCT_ID_AIC8800) {
+            len = snprintf(path, FW_PATH_MAX, "%s/%s/%s",aic_default_fw_path, "aic8800", name);
+        } else if (usb_dev->chipid == PRODUCT_ID_AIC8800D80) {
+            len = snprintf(path, FW_PATH_MAX, "%s/%s/%s",aic_default_fw_path, "aic8800D80", name);
+        } else if (usb_dev->chipid == PRODUCT_ID_AIC8800D80X2) {
+            len = snprintf(path, FW_PATH_MAX, "%s/%s/%s",aic_default_fw_path, "aic8800D80X2", name);
+        }else {
+            printk("%s unknown chipid %d\n", __func__, usb_dev->chipid);
+        }
+	#else
+		len = snprintf(path, FW_PATH_MAX, "%s/%s",aic_default_fw_path, name);
+	#endif
+    }
+
+    if (len >= FW_PATH_MAX) {
+    	printk("%s: %s file's path too long\n", __func__, name);
+        *fw_buf=NULL;
+        __putname(path);
+        return -1;
+    }
+
+    printk("%s :firmware path = %s  \n", __func__ ,path);
+
+
+    /* open the firmware file */
+    fp=filp_open(path, O_RDONLY, 0);
+    if(IS_ERR(fp) || (!fp)){
+            printk("%s: %s file failed to open\n", __func__, name);
+            if(IS_ERR(fp))
+		printk("is_Err\n");
+	if((!fp))
+		printk("null\n");
+	*fw_buf=NULL;
+            __putname(path);
+            fp=NULL;
+            return -1;
+    }
+
+    size = i_size_read(file_inode(fp));
+    if(size<=0){
+            printk("%s: %s file size invalid %d\n", __func__, name, size);
+            *fw_buf=NULL;
+            __putname(path);
+            filp_close(fp,NULL);
+            fp=NULL;
+            return -1;
+}
+
+    /* start to read from firmware file */
+    buffer = vmalloc(size);
+    memset(buffer, 0, size);
+    if(!buffer){
+            *fw_buf=NULL;
+            __putname(path);
+            filp_close(fp,NULL);
+            fp=NULL;
+            return -1;
+    }
+
+
+    #if LINUX_VERSION_CODE > KERNEL_VERSION(4, 13, 16)
+    rdlen = kernel_read(fp, buffer, size, &fp->f_pos);
+    #else
+    rdlen = kernel_read(fp, fp->f_pos, buffer, size);
+    #endif
+
+    if(size != rdlen){
+            printk("%s: %s file rdlen invalid %d %d\n", __func__, name, (int)rdlen, size);
+            *fw_buf=NULL;
+            __putname(path);
+            filp_close(fp,NULL);
+            fp=NULL;
+            vfree(buffer);
+            buffer=NULL;
+            return -1;
+    }
+    if(rdlen > 0){
+            fp->f_pos += rdlen;
+            //printk("f_pos=%d\n", (int)fp->f_pos);
+    }
+
+
+#if 0
+   /*start to transform the data format*/
+    src = (u32*)buffer;
+    //printk("malloc dst\n");
+    dst = (u32*)vmalloc(size);
+    memset(dst, 0, size);
+
+    if(!dst){
+            *fw_buf=NULL;
+            __putname(path);
+            filp_close(fp,NULL);
+            fp=NULL;
+            vfree(buffer);
+            buffer=NULL;
+            return -1;
+    }
+
+    for(i=0;i<(size/4);i++){
+            dst[i] = src[i];
+    }
+#endif
+
+    __putname(path);
+    filp_close(fp,NULL);
+    fp=NULL;
+    //vfree(buffer);
+    //buffer=NULL;
+    //*fw_buf = dst;
+	*fw_buf = (u32 *)buffer;
+
+	MD5Init(&md5);
+	//MD5Update(&md5, (unsigned char *)dst, size);
+	MD5Update(&md5, (unsigned char *)buffer, size);
+	MD5Final(&md5, decrypt);
+
+	printk(MD5PINRT, MD5(decrypt));
+
+    return size;
+#endif
+
+}
+
+int rwnx_plat_bin_fw_upload_android(struct aic_usb_dev *usbdev, u32 fw_addr,
+                               char *filename)
+{
+    struct device *dev = usbdev->dev;
+    unsigned int i=0;
+    int size;
+    u32 *dst=NULL;
+    int err=0;
+
+    /* load aic firmware */
+    size = aic_load_firmware(&dst, filename, dev);
+    if(size<=0){
+            printk("wrong size of firmware file\n");
+            vfree(dst);
+            dst = NULL;
+            return -1;
+    }
+
+    /* Copy the file on the Embedded side */
+    printk("### Upload %s firmware, @ = %x  size=%d\n", filename, fw_addr, size);
+
+    if (size > 1024) {// > 1KB data
+        for (i = 0; i < (size - 1024); i += 1024) {//each time write 1KB
+            err = rwnx_send_dbg_mem_block_write_req(usbdev, fw_addr + i, 1024, dst + i / 4);
+                if (err) {
+                printk("bin upload fail: %x, err:%d\r\n", fw_addr + i, err);
+                break;
+            }
+        }
+    }
+
+    if (!err && (i < size)) {// <1KB data
+        err = rwnx_send_dbg_mem_block_write_req(usbdev, fw_addr + i, size - i, dst + i / 4);
+        if (err) {
+            printk("bin upload fail: %x, err:%d\r\n", fw_addr + i, err);
+        }
+    }
+
+    if (dst) {
+        vfree(dst);
+        dst = NULL;
+    }
+
+    printk("fw download complete\n\n");
+
+    return err;
+}
+
+extern int testmode;
+#ifdef CONFIG_M2D_OTA_AUTO_SUPPORT
+int rwnx_plat_m2d_flash_ota_android(struct aic_usb_dev *usbdev, char *filename)
+{
+    struct device *dev = usbdev->dev;
+    unsigned int i=0;
+    int size;
+    u32 *dst=NULL;
+    int err=0;
+	int ret;
+	u8 bond_id;
+    const u32 mem_addr = 0x40500000;
+    struct dbg_mem_read_cfm rd_mem_addr_cfm;
+
+    ret = rwnx_send_dbg_mem_read_req(usbdev, mem_addr, &rd_mem_addr_cfm);
+    if (ret) {
+        printk("m2d %x rd fail: %d\n", mem_addr, ret);
+        return ret;
+    }
+    bond_id = (u8)(rd_mem_addr_cfm.memdata >> 24);
+    printk("%x=%x\n", rd_mem_addr_cfm.memaddr, rd_mem_addr_cfm.memdata);
+	if (bond_id & (1<<1)) {
+		//flash is invalid
+		printk("m2d flash is invalid\n");
+		return -1;
+	}
+
+    /* load aic firmware */
+    size = aic_load_firmware(&dst, filename, dev);
+    if(size<=0){
+            printk("wrong size of m2d file\n");
+            vfree(dst);
+            dst = NULL;
+            return -1;
+    }
+
+    /* Copy the file on the Embedded side */
+    printk("### Upload m2d %s flash, size=%d\n", filename, size);
+
+	/*send info first*/
+	err = rwnx_send_dbg_mem_block_write_req(usbdev, AIC_M2D_OTA_INFO_ADDR, 4, (u32 *)&size);
+	
+	/*send data first*/
+    if (size > 1024) {// > 1KB data
+        for (i = 0; i < (size - 1024); i += 1024) {//each time write 1KB
+            err = rwnx_send_dbg_mem_block_write_req(usbdev, AIC_M2D_OTA_DATA_ADDR, 1024, dst + i / 4);
+                if (err) {
+                printk("m2d upload fail: %x, err:%d\r\n", AIC_M2D_OTA_DATA_ADDR, err);
+                break;
+            }
+        }
+    }
+
+    if (!err && (i < size)) {// <1KB data
+        err = rwnx_send_dbg_mem_block_write_req(usbdev, AIC_M2D_OTA_DATA_ADDR, size - i, dst + i / 4);
+        if (err) {
+            printk("m2d upload fail: %x, err:%d\r\n", AIC_M2D_OTA_DATA_ADDR, err);
+        }
+    }
+
+    if (dst) {
+        vfree(dst);
+        dst = NULL;
+    }
+	testmode = FW_NORMAL_MODE;
+
+    printk("m2d flash update complete\n\n");
+
+    return err;
+}
+
+int rwnx_plat_m2d_flash_ota_check(struct aic_usb_dev *usbdev, char *filename)
+{
+    struct device *dev = usbdev->dev;
+    unsigned int i=0,j=0;
+    int size;
+    u32 *dst=NULL;
+    int err=0;
+	int ret=0;
+	u8 bond_id;
+    const u32 mem_addr = 0x40500000;
+	const u32 mem_addr_code_start = AIC_M2D_OTA_CODE_START_ADDR;
+	const u32 mem_addr_sdk_ver = AIC_M2D_OTA_VER_ADDR;
+	const u32 driver_code_start_idx = (AIC_M2D_OTA_CODE_START_ADDR-AIC_M2D_OTA_FLASH_ADDR)/4;
+	const u32 driver_sdk_ver_idx = (AIC_M2D_OTA_VER_ADDR-AIC_M2D_OTA_FLASH_ADDR)/4;
+	u32 driver_sdk_ver_addr_idx = 0;
+	u32 code_start_addr = 0xffffffff;
+	u32 sdk_ver_addr = 0xffffffff;
+	u32 drv_code_start_addr = 0xffffffff;
+	u32 drv_sdk_ver_addr = 0xffffffff;
+    struct dbg_mem_read_cfm rd_mem_addr_cfm;
+	char m2d_sdk_ver[64];
+	char flash_sdk_ver[64];
+	u32 flash_ver[16];
+	u32 ota_ver[16];
+
+    ret = rwnx_send_dbg_mem_read_req(usbdev, mem_addr, &rd_mem_addr_cfm);
+    if (ret) {
+        printk("m2d %x rd fail: %d\n", mem_addr, ret);
+        return ret;
+    }
+    bond_id = (u8)(rd_mem_addr_cfm.memdata >> 24);
+    printk("%x=%x\n", rd_mem_addr_cfm.memaddr, rd_mem_addr_cfm.memdata);
+	if (bond_id & (1<<1)) {
+		//flash is invalid
+		printk("m2d flash is invalid\n");
+		return -1;
+	}
+    ret = rwnx_send_dbg_mem_read_req(usbdev, mem_addr_code_start, &rd_mem_addr_cfm);
+	if (ret){
+        printk("mem_addr_code_start %x rd fail: %d\n", mem_addr_code_start, ret);
+        return ret;
+	}
+	code_start_addr = rd_mem_addr_cfm.memdata;
+
+    ret = rwnx_send_dbg_mem_read_req(usbdev, mem_addr_sdk_ver, &rd_mem_addr_cfm);
+	if (ret){
+        printk("mem_addr_sdk_ver %x rd fail: %d\n", mem_addr_code_start, ret);
+        return ret;
+	}
+	sdk_ver_addr = rd_mem_addr_cfm.memdata;
+	printk("code_start_addr: 0x%x,  sdk_ver_addr: 0x%x\n", code_start_addr,sdk_ver_addr);
+
+	/* load aic firmware */
+	size = aic_load_firmware(&dst, filename, dev);
+	if(size<=0){
+			printk("wrong size of m2d file\n");
+			vfree(dst);
+			dst = NULL;
+			return -1;
+	}
+	if(code_start_addr == 0xffffffff && sdk_ver_addr == 0xffffffff) {
+		printk("########m2d flash old version , must be upgrade\n");
+		drv_code_start_addr = dst[driver_code_start_idx];
+		drv_sdk_ver_addr = dst[driver_sdk_ver_idx];
+
+		printk("drv_code_start_addr: 0x%x,	drv_sdk_ver_addr: 0x%x\n", drv_code_start_addr,drv_sdk_ver_addr);
+
+		if(drv_sdk_ver_addr == 0xffffffff){
+			printk("########driver m2d_ota.bin is old ,not need upgrade\n");
+			return -1;
+		}
+
+	} else {
+		for(i=0;i<16;i++){
+			ret = rwnx_send_dbg_mem_read_req(usbdev, (sdk_ver_addr+i*4), &rd_mem_addr_cfm);
+			if (ret){
+				printk("mem_addr_sdk_ver %x rd fail: %d\n", mem_addr_code_start, ret);
+				return ret;
+			}
+			flash_ver[i] = rd_mem_addr_cfm.memdata;
+		}
+		memcpy((u8 *)flash_sdk_ver,(u8 *)flash_ver,64);
+        memcpy((u8 *)saved_sdk_ver,(u8 *)flash_sdk_ver,64);
+		printk("flash SDK Version: %s\r\n\r\n", flash_sdk_ver);
+				
+		drv_code_start_addr = dst[driver_code_start_idx];
+		drv_sdk_ver_addr = dst[driver_sdk_ver_idx];
+
+		printk("drv_code_start_addr: 0x%x,	drv_sdk_ver_addr: 0x%x\n", drv_code_start_addr,drv_sdk_ver_addr);
+
+		if(drv_sdk_ver_addr == 0xffffffff){
+			printk("########driver m2d_ota.bin is old ,not need upgrade\n");
+			return -1;
+		}
+
+		driver_sdk_ver_addr_idx = (drv_sdk_ver_addr-drv_code_start_addr)/4;
+		printk("driver_sdk_ver_addr_idx %d\n",driver_sdk_ver_addr_idx);
+
+		if (driver_sdk_ver_addr_idx){
+			for(j = 0; j < 16; j++){
+				ota_ver[j] = dst[driver_sdk_ver_addr_idx+j];
+			}
+			memcpy((u8 *)m2d_sdk_ver,(u8 *)ota_ver,64);
+			printk("m2d_ota SDK Version: %s\r\n\r\n", m2d_sdk_ver);
+		} else {
+			return -1;
+		}
+		
+		if(!strcmp(m2d_sdk_ver,flash_sdk_ver)){
+			printk("######## m2d %s flash is not need upgrade\r\n", filename);
+			return -1;
+		}
+	}
+
+    /* Copy the file on the Embedded side */
+    printk("### Upload m2d %s flash, size=%d\n", filename, size);
+
+	/*send info first*/
+	err = rwnx_send_dbg_mem_block_write_req(usbdev, AIC_M2D_OTA_INFO_ADDR, 4, (u32 *)&size);
+	
+	/*send data first*/
+    if (size > 1024) {// > 1KB data
+        for (i = 0; i < (size - 1024); i += 1024) {//each time write 1KB
+            err = rwnx_send_dbg_mem_block_write_req(usbdev, AIC_M2D_OTA_DATA_ADDR, 1024, dst + i / 4);
+                if (err) {
+                printk("m2d upload fail: %x, err:%d\r\n", AIC_M2D_OTA_DATA_ADDR, err);
+                break;
+            }
+        }
+    }
+
+    if (!err && (i < size)) {// <1KB data
+        err = rwnx_send_dbg_mem_block_write_req(usbdev, AIC_M2D_OTA_DATA_ADDR, size - i, dst + i / 4);
+        if (err) {
+            printk("m2d upload fail: %x, err:%d\r\n", AIC_M2D_OTA_DATA_ADDR, err);
+        }
+    }
+
+    if (dst) {
+        vfree(dst);
+        dst = NULL;
+    }
+	testmode = FW_NORMAL_MODE;
+
+    printk("m2d flash update complete\n\n");
+
+    return err;
+}
+#endif//CONFIG_M2D_OTA_AUTO_SUPPORT
+
+int rwnx_plat_flash_bin_upload_android(struct aic_usb_dev *usbdev, u32 fw_addr,
+                               char *filename)
+{
+    struct device *dev = usbdev->dev;
+    unsigned int i=0;
+    int size;
+    u32 *dst=NULL;
+    int err=0;
+    const u32 mem_addr = fw_addr;
+    struct dbg_mem_read_cfm rd_mem_addr_cfm;
+
+    /* load aic firmware */
+    size = aic_load_firmware(&dst, filename, dev);
+    if(size<=0){
+            printk("wrong size of firmware file\n");
+            vfree(dst);
+            dst = NULL;
+            return ENOENT;
+    }
+
+    printk("size %x, flash_erase_len %x\n", size, flash_erase_len);
+    if (size != flash_erase_len || (flash_erase_len & 0xFFF)) {
+        printk("wrong size of flash_erase_len %d\n", flash_erase_len);
+        vfree(dst);
+        dst = NULL;
+        return -1;
+    }
+
+    err = rwnx_send_dbg_mem_read_req(usbdev, mem_addr, &rd_mem_addr_cfm);
+    if (err) {
+        printk("%x rd fail: %d\n", mem_addr, err);
+        return err;
+    }
+
+    if (rd_mem_addr_cfm.memdata != 0xffffffff) {
+        //erase flash
+        if (size > 0x40000) {
+            for (i = 0; i < (size - 0x40000); i +=0x40000) {//each time erase 256K
+                err = rwnx_send_dbg_mem_mask_write_req(usbdev, fw_addr+i, 0xf150e250, 0x40000);
+                if (err) {
+                    printk("flash erase fail: %x, err:%d\r\n", fw_addr + i, err);
+                    return err;
+                }
+            }
+        }
+        if (!err && (i < size)) {// <256KB data
+            err = rwnx_send_dbg_mem_mask_write_req(usbdev, fw_addr + i, 0xf150e250, size - i);
+            if (err) {
+                printk("flash erase fail: %x, err:%d\r\n", fw_addr + i, err);
+            }
+        }
+    }
+
+    /* Copy the file on the Embedded side */
+    printk("### Upload %s firmware, @ = %x  size=%d\n", filename, fw_addr, size);
+
+    if (size > 1024) {// > 1KB data
+        for (i = 0; i < (size - 1024); i += 1024) {//each time write 1KB
+            err = rwnx_send_dbg_mem_block_write_req(usbdev, fw_addr + i, 1024, dst + i / 4);
+                if (err) {
+                printk("bin upload fail: %x, err:%d\r\n", fw_addr + i, err);
+                break;
+            }
+        }
+    }
+
+    if (!err && (i < size)) {// <1KB data
+        err = rwnx_send_dbg_mem_block_write_req(usbdev, fw_addr + i, size - i, dst + i / 4);
+        if (err) {
+            printk("bin upload fail: %x, err:%d\r\n", fw_addr + i, err);
+        }
+    }
+
+    if (dst) {
+        vfree(dst);
+        dst = NULL;
+    }
+
+    printk("fw download complete\n\n");
+
+    return err;
+}
+
+
+uint32_t rwnx_atoli(char *value){
+	int len = 0;
+	int temp_len = 0;
+	int i = 0;
+	uint32_t result = 0;
+	
+	temp_len = strlen(value);
+
+	for(i = 0;i < temp_len; i++){
+		if((value[i] >= 48 && value[i] <= 57) ||
+			(value[i] >= 65 && value[i] <= 70) ||
+			(value[i] >= 97 && value[i] <= 102)){
+			len++;
+		}
+	}
+
+	//printk("%s len:%d \r\n", __func__, len);
+	
+	for(i = 0; i < len; i++){
+		result = result * 16;
+		if(value[i] >= 48 && value[i] <= 57){
+			result += value[i] - 48;
+		}else if(value[i] >= 65 && value[i] <= 70){
+			result += (value[i] - 65) + 10;
+		}else if(value[i] >= 97 && value[i] <= 102){
+			result += (value[i] - 97) + 10;
+		}
+	}
+	
+	return result;
+}
+
+int8_t rwnx_atoi(char *value){
+	int len = 0;
+	int i = 0;
+	int8_t result = 0;
+	int8_t signal = 1;
+
+	len = strlen(value);
+	//printk("%s len:%d \r\n", __func__, len);
+
+	for(i = 0;i < len ;i++){
+		if(i == 0 && value[0] == '-'){
+			signal = -1;
+			continue;
+		}
+
+		result = result * 10;
+		if(value[i] >= 48 && value[i] <= 57){
+			result += value[i] - 48;
+		}else{
+			result = 0;
+			break;
+		}
+	}
+
+	result = result * signal;
+	//printk("%s result:%d \r\n", __func__, result);
+
+	return result;
+}
+
+void get_fw_path(char* fw_path){
+	if (strlen(aic_fw_path) > 0) {
+		memcpy(fw_path, aic_fw_path, strlen(aic_fw_path));
+	}else{
+		memcpy(fw_path, aic_default_fw_path, strlen(aic_default_fw_path));
+	}
+} 
+
+void set_testmode(int val){
+	testmode = val;
+}
+
+int get_testmode(void){
+	return testmode;
+}
+
+int get_hardware_info(void){
+	return AIC_HW_INFO;
+}
+
+extern int adap_test;
+int get_adap_test(void){
+    return adap_test;
+}
+
+EXPORT_SYMBOL(get_fw_path);
+
+EXPORT_SYMBOL(get_testmode);
+
+EXPORT_SYMBOL(set_testmode);
+
+EXPORT_SYMBOL(get_hardware_info);
+
+EXPORT_SYMBOL(get_adap_test);
+
+
+void get_userconfig_xtal_cap(xtal_cap_conf_t *xtal_cap)
+{
+	xtal_cap->enable = userconfig_xtal_cap.enable;
+	xtal_cap->xtal_cap = userconfig_xtal_cap.xtal_cap;
+	xtal_cap->xtal_cap_fine = userconfig_xtal_cap.xtal_cap_fine;
+
+    printk("%s:enable       :%d\r\n", __func__, xtal_cap->enable);
+    printk("%s:xtal_cap     :%d\r\n", __func__, xtal_cap->xtal_cap);
+    printk("%s:xtal_cap_fine:%d\r\n", __func__, xtal_cap->xtal_cap_fine);
+}
+
+EXPORT_SYMBOL(get_userconfig_xtal_cap);
+
+void get_userconfig_txpwr_idx(txpwr_idx_conf_t *txpwr_idx){
+	txpwr_idx->enable = userconfig_txpwr_idx.enable;
+	txpwr_idx->dsss = userconfig_txpwr_idx.dsss;
+	txpwr_idx->ofdmlowrate_2g4 = userconfig_txpwr_idx.ofdmlowrate_2g4;
+	txpwr_idx->ofdm64qam_2g4 = userconfig_txpwr_idx.ofdm64qam_2g4;
+	txpwr_idx->ofdm256qam_2g4 = userconfig_txpwr_idx.ofdm256qam_2g4;
+	txpwr_idx->ofdm1024qam_2g4 = userconfig_txpwr_idx.ofdm1024qam_2g4;
+	txpwr_idx->ofdmlowrate_5g = userconfig_txpwr_idx.ofdmlowrate_5g;
+	txpwr_idx->ofdm64qam_5g = userconfig_txpwr_idx.ofdm64qam_5g;
+	txpwr_idx->ofdm256qam_5g = userconfig_txpwr_idx.ofdm256qam_5g;
+	txpwr_idx->ofdm1024qam_5g = userconfig_txpwr_idx.ofdm1024qam_5g;
+
+	printk("%s:enable:%d\r\n", __func__, txpwr_idx->enable);
+	printk("%s:dsss:%d\r\n", __func__, txpwr_idx->dsss);
+	printk("%s:ofdmlowrate_2g4:%d\r\n", __func__, txpwr_idx->ofdmlowrate_2g4);
+	printk("%s:ofdm64qam_2g4:%d\r\n", __func__, txpwr_idx->ofdm64qam_2g4);
+	printk("%s:ofdm256qam_2g4:%d\r\n", __func__, txpwr_idx->ofdm256qam_2g4);
+	printk("%s:ofdm1024qam_2g4:%d\r\n", __func__, txpwr_idx->ofdm1024qam_2g4);
+	printk("%s:ofdmlowrate_5g:%d\r\n", __func__, txpwr_idx->ofdmlowrate_5g);
+	printk("%s:ofdm64qam_5g:%d\r\n", __func__, txpwr_idx->ofdm64qam_5g);
+	printk("%s:ofdm256qam_5g:%d\r\n", __func__, txpwr_idx->ofdm256qam_5g);
+	printk("%s:ofdm1024qam_5g:%d\r\n", __func__, txpwr_idx->ofdm1024qam_5g);
+
+}
+
+EXPORT_SYMBOL(get_userconfig_txpwr_idx);
+
+void get_userconfig_txpwr_ofst(txpwr_ofst_conf_t *txpwr_ofst){
+	txpwr_ofst->enable = userconfig_txpwr_ofst.enable;
+	txpwr_ofst->chan_1_4 = userconfig_txpwr_ofst.chan_1_4;
+	txpwr_ofst->chan_5_9 = userconfig_txpwr_ofst.chan_5_9;
+	txpwr_ofst->chan_10_13 = userconfig_txpwr_ofst.chan_10_13;
+	txpwr_ofst->chan_36_64 = userconfig_txpwr_ofst.chan_36_64;
+	txpwr_ofst->chan_100_120 = userconfig_txpwr_ofst.chan_100_120;
+	txpwr_ofst->chan_122_140 = userconfig_txpwr_ofst.chan_122_140;
+	txpwr_ofst->chan_142_165 = userconfig_txpwr_ofst.chan_142_165;
+
+	printk("%s:ofst_enable:%d\r\n", __func__, txpwr_ofst->enable);
+	printk("%s:ofst_chan_1_4:%d\r\n", __func__, txpwr_ofst->chan_1_4);
+	printk("%s:ofst_chan_5_9:%d\r\n", __func__, txpwr_ofst->chan_5_9);
+	printk("%s:ofst_chan_10_13:%d\r\n", __func__, txpwr_ofst->chan_10_13);
+	printk("%s:ofst_chan_36_64:%d\r\n", __func__, txpwr_ofst->chan_36_64);
+	printk("%s:ofst_chan_100_120:%d\r\n", __func__, txpwr_ofst->chan_100_120);
+	printk("%s:ofst_chan_122_140:%d\r\n", __func__, txpwr_ofst->chan_122_140);
+	printk("%s:ofst_chan_142_165:%d\r\n", __func__, txpwr_ofst->chan_142_165);
+
+}
+
+EXPORT_SYMBOL(get_userconfig_txpwr_ofst);
+
+void rwnx_plat_userconfig_set_value(char *command, char *value){	
+	//TODO send command
+	printk("%s:command=%s value=%s \r\n", __func__, command, value);
+	if(!strcmp(command, "enable")){
+		userconfig_txpwr_idx.enable = rwnx_atoi(value);
+	}else if(!strcmp(command, "dsss")){
+		userconfig_txpwr_idx.dsss = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofdmlowrate_2g4")){
+		userconfig_txpwr_idx.ofdmlowrate_2g4 = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofdm64qam_2g4")){
+		userconfig_txpwr_idx.ofdm64qam_2g4 = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofdm256qam_2g4")){
+		userconfig_txpwr_idx.ofdm256qam_2g4 = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofdm1024qam_2g4")){
+		userconfig_txpwr_idx.ofdm1024qam_2g4 = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofdmlowrate_5g")){
+		userconfig_txpwr_idx.ofdmlowrate_5g = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofdm64qam_5g")){
+		userconfig_txpwr_idx.ofdm64qam_5g = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofdm256qam_5g")){
+		userconfig_txpwr_idx.ofdm256qam_5g = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofdm1024qam_5g")){
+		userconfig_txpwr_idx.ofdm1024qam_5g = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofst_enable")){
+		userconfig_txpwr_ofst.enable = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofst_chan_1_4")){
+		userconfig_txpwr_ofst.chan_1_4 = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofst_chan_5_9")){
+		userconfig_txpwr_ofst.chan_5_9 = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofst_chan_10_13")){
+		userconfig_txpwr_ofst.chan_10_13 = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofst_chan_36_64")){
+		userconfig_txpwr_ofst.chan_36_64 = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofst_chan_100_120")){
+		userconfig_txpwr_ofst.chan_100_120 = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofst_chan_122_140")){
+		userconfig_txpwr_ofst.chan_122_140 = rwnx_atoi(value);
+	}else if(!strcmp(command, "ofst_chan_142_165")){
+		userconfig_txpwr_ofst.chan_142_165 = rwnx_atoi(value);
+	}else if(!strcmp(command, "xtal_enable")){
+		userconfig_xtal_cap.enable = rwnx_atoi(value);
+	}else if(!strcmp(command, "xtal_cap")){
+		userconfig_xtal_cap.xtal_cap = rwnx_atoi(value);
+	}else if(!strcmp(command, "xtal_cap_fine")){
+		userconfig_xtal_cap.xtal_cap_fine = rwnx_atoi(value);
+	}
+}
+
+void rwnx_plat_userconfig_parsing(char *buffer, int size){
+    int i = 0;
+	int parse_state = 0;
+	char command[30];
+	char value[100];
+	int char_counter = 0;
+
+	memset(command, 0, 30);
+	memset(value, 0, 100);
+
+    for(i = 0; i < size; i++){
+
+		//Send command or print nvram log when char is \r or \n
+		if(buffer[i] == 0x0a || buffer[i] == 0x0d){
+			if(command[0] != 0 && value[0] != 0){
+				if(parse_state == PRINT){
+					printk("%s:%s\r\n", __func__, value);
+				}else if(parse_state == GET_VALUE){
+					rwnx_plat_userconfig_set_value(command, value);
+				}
+			}
+			//Reset command value and char_counter
+			memset(command, 0, 30);
+			memset(value, 0, 100);
+			char_counter = 0;
+			parse_state = INIT;
+			continue;
+		}
+
+		//Switch parser state
+		if(parse_state == INIT){
+			if(buffer[i] == '#'){
+				parse_state = PRINT;
+				continue;
+			}else if(buffer[i] == 0x0a || buffer[i] == 0x0d){
+				parse_state = INIT;
+				continue;
+			}else{
+				parse_state = CMD;
+			}
+		}
+
+		//Fill data to command and value
+		if(parse_state == PRINT){
+			command[0] = 0x01;
+			value[char_counter] = buffer[i];
+			char_counter++;
+		}else if(parse_state == CMD){
+			if(command[0] != 0 && buffer[i] == '='){
+				parse_state = GET_VALUE;
+				char_counter = 0;
+				continue;
+			}
+			command[char_counter] = buffer[i];
+			char_counter++;
+		}else if(parse_state == GET_VALUE){
+			value[char_counter] = buffer[i];
+			char_counter++;
+		}
+	}
+
+
+}
+
+int rwnx_plat_userconfig_upload_android(struct aic_usb_dev *usbdev, char *filename){
+    int size;
+    u32 *dst=NULL;
+    struct device *dev = usbdev->dev;
+
+	printk("userconfig file path:%s \r\n", filename);
+
+    /* load aic firmware */
+    size = aic_load_firmware(&dst, filename, dev);
+    if(size <= 0){
+            printk("wrong size of firmware file\n");
+            vfree(dst);
+            dst = NULL;
+            return 0;
+    }
+
+	/* Copy the file on the Embedded side */
+    printk("### Upload %s userconfig, size=%d\n", filename, size);
+
+	rwnx_plat_userconfig_parsing((char *)dst, size);
+
+	if (dst) {
+        vfree(dst);
+        dst = NULL;
+    }
+
+	printk("userconfig download complete\n\n");
+	return 0;
+}
+
+
+
+int aicbt_patch_table_free(struct aicbt_patch_table *head)
+{
+	struct aicbt_patch_table *p = head, *n = NULL;
+	while (p) {
+		n = p->next;
+		vfree(p->name);
+		vfree(p->data);
+		vfree(p);
+		p = n;
+	}
+	head = NULL;
+	return 0;
+}
+
+struct aicbt_patch_table *aicbt_patch_table_alloc(struct aic_usb_dev *usbdev,const char *filename)
+{
+	struct device *dev = usbdev->dev;
+	struct aicbt_patch_table *head = NULL;
+	struct aicbt_patch_table *new = NULL;
+	struct aicbt_patch_table *cur = NULL;
+	int size;
+	int ret = 0;
+	uint8_t *rawdata=NULL;
+	uint8_t *p = NULL;
+
+	/* load aic firmware */
+	size = aic_load_firmware((u32 **)&rawdata, filename, dev);
+
+	/* Copy the file on the Embedded side */
+	printk("### Upload %s fw_patch_table, size=%d\n", filename, size);
+
+	if (size <= 0) {
+		printk("wrong size of firmware file\n");
+		ret = -1;
+		goto err;
+	}
+
+	p = rawdata;
+
+	if (memcmp(p, AICBT_PT_TAG, sizeof(AICBT_PT_TAG) < 16 ? sizeof(AICBT_PT_TAG) : 16)) {
+		printk("TAG err\n");
+		ret = -1;
+		goto err;
+	}
+	p += 16;
+
+	while (p - rawdata < size) {
+		//printk("size = %d  p - rawdata = %d \r\n", size, p - rawdata);
+		new = (struct aicbt_patch_table *)vmalloc(sizeof(struct aicbt_patch_table));
+		memset(new, 0, sizeof(struct aicbt_patch_table));
+		if (head == NULL) {
+			head = new;
+			cur  = new;
+		} else {
+			cur->next = new;
+			cur = cur->next;
+		}
+
+		cur->name = (char *)vmalloc(sizeof(char) * 16);
+		memset(cur->name, 0, sizeof(char) * 16);
+		memcpy(cur->name, p, 16);
+		p += 16;
+
+		cur->type = *(uint32_t *)p;
+		p += 4;
+
+		cur->len = *(uint32_t *)p;
+		p += 4;
+
+		if((cur->type )  >= 1000 || cur->len == 0) {//Temp Workaround
+			cur->len = 0;
+		}else{
+			cur->data = (uint32_t *)vmalloc(sizeof(uint8_t) * cur->len * 8);
+			memset(cur->data, 0, sizeof(uint8_t) * cur->len * 8);
+			memcpy(cur->data, p, cur->len * 8);
+			p += cur->len * 8;
+		}
+	}
+
+	vfree(rawdata);
+
+	return head;
+
+err:
+	aicbt_patch_table_free(head);
+	if (rawdata)
+		vfree(rawdata);
+	return NULL;
+}
+
+struct aicbsp_info_t aicbsp_info = {
+    .hwinfo   = AICBSP_HWINFO_DEFAULT,
+    .cpmode   = AICBSP_CPMODE_DEFAULT,
+};
+
+
+
+static struct aicbt_info_t aicbt_info[] = {
+    {   
+        .btmode        = AICBT_BTMODE_DEFAULT,
+        .btport        = AICBT_BTPORT_DEFAULT,
+        .uart_baud     = AICBT_UART_BAUD_DEFAULT,
+        .uart_flowctrl = AICBT_UART_FC_DEFAULT,
+        .lpm_enable    = AICBT_LPM_ENABLE_DEFAULT,
+        .txpwr_lvl     = AICBT_TXPWR_LVL_DEFAULT,
+    },//PRODUCT_ID_AIC8800
+    {
+    },//PRODUCT_ID_AIC8801
+    {
+    },//PRODUCT_ID_AIC8800DC
+    {
+    },//PRODUCT_ID_AIC8800DW
+    {
+        .btmode        = AICBT_BTMODE_DEFAULT_8800d80,
+        .btport        = AICBT_BTPORT_DEFAULT,
+        .uart_baud     = AICBT_UART_BAUD_DEFAULT,
+        .uart_flowctrl = AICBT_UART_FC_DEFAULT,
+        .lpm_enable    = AICBT_LPM_ENABLE_DEFAULT,
+        .txpwr_lvl     = AICBT_TXPWR_LVL_DEFAULT_8800d80,
+    },//PRODUCT_ID_AIC8800D80
+    {
+    },//PRODUCT_ID_AIC8800D81
+};
+
+int aicbt_patch_table_load(struct aic_usb_dev *usbdev, struct aicbt_patch_table *_head)
+{
+	struct aicbt_patch_table *head, *p;
+	int ret = 0, i;
+	uint32_t *data = NULL;
+
+	head = _head;
+
+	for (p = head; p != NULL; p = p->next) {
+		data = p->data;
+		if(AICBT_PT_BTMODE == p->type){
+			*(data + 1)  = aicbsp_info.hwinfo < 0;
+			*(data + 3) = aicbsp_info.hwinfo;
+			*(data + 5)  = aicbsp_info.cpmode;
+
+			*(data + 7) = aicbt_info[usbdev->chipid].btmode;
+			*(data + 9) = aicbt_info[usbdev->chipid].btport;
+			*(data + 11) = aicbt_info[usbdev->chipid].uart_baud;
+			*(data + 13) = aicbt_info[usbdev->chipid].uart_flowctrl;
+			*(data + 15) = aicbt_info[usbdev->chipid].lpm_enable;
+			*(data + 17) = aicbt_info[usbdev->chipid].txpwr_lvl;
+            
+            printk("%s bt btmode[%d]:%d \r\n", __func__, usbdev->chipid, aicbt_info[usbdev->chipid].btmode);
+    		printk("%s bt uart_baud[%d]:%d \r\n", __func__, usbdev->chipid, aicbt_info[usbdev->chipid].uart_baud);
+    		printk("%s bt uart_flowctrl[%d]:%d \r\n", __func__, usbdev->chipid, aicbt_info[usbdev->chipid].uart_flowctrl);
+    		printk("%s bt lpm_enable[%d]:%d \r\n", __func__, usbdev->chipid, aicbt_info[usbdev->chipid].lpm_enable);
+    		printk("%s bt tx_pwr[%d]:%d \r\n", __func__, usbdev->chipid, aicbt_info[usbdev->chipid].txpwr_lvl);
+
+		}
+		if (p->type == 0x06) {
+			char *data_s = (char *)p->data;
+			printk("patch version %s\n", data_s);
+			continue;
+		}
+		for (i = 0; i < p->len; i++) {
+			ret = rwnx_send_dbg_mem_write_req(usbdev, *data, *(data + 1));
+			if (ret != 0)
+				return ret;
+			data += 2;
+		}
+		if (p->type == AICBT_PT_PWRON)
+			udelay(500);
+	}
+	aicbt_patch_table_free(head);
+	return 0;
+}
+
+int aicbt_patch_info_unpack(struct aicbt_patch_info_t *patch_info, struct aicbt_patch_table *head_t)
+{
+    if (AICBT_PT_INF == head_t->type) {
+        patch_info->info_len = head_t->len;
+        if(patch_info->info_len == 0)
+            return 0;
+        memcpy(&patch_info->adid_addrinf, head_t->data, patch_info->info_len * sizeof(uint32_t) * 2);
+    }
+    return 0;
+}
+
+int rwnx_plat_bin_fw_patch_table_upload_android(struct aic_usb_dev *usbdev, char *filename){
+    struct device *dev = usbdev->dev;
+	struct aicbt_patch_table *head = NULL;
+	struct aicbt_patch_table *new = NULL;
+	struct aicbt_patch_table *cur = NULL;
+   	 int size;
+	int ret = 0;
+   	uint8_t *rawdata=NULL;
+	uint8_t *p = NULL;
+
+    /* load aic firmware */
+    size = aic_load_firmware((u32 **)&rawdata, filename, dev);
+
+	/* Copy the file on the Embedded side */
+    printk("### Upload %s fw_patch_table, size=%d\n", filename, size);
+
+	if (size <= 0) {
+		printk("wrong size of firmware file\n");
+		ret = -1;
+		goto err;
+	}
+
+	p = rawdata;
+
+	if (memcmp(p, AICBT_PT_TAG, sizeof(AICBT_PT_TAG) < 16 ? sizeof(AICBT_PT_TAG) : 16)) {
+		printk("TAG err\n");
+		ret = -1;
+		goto err;
+	}
+	p += 16;
+
+	while (p - rawdata < size) {
+		//printk("size = %d  p - rawdata = %d \r\n", size, p - rawdata);
+		new = (struct aicbt_patch_table *)vmalloc(sizeof(struct aicbt_patch_table));
+		memset(new, 0, sizeof(struct aicbt_patch_table));
+		if (head == NULL) {
+			head = new;
+			cur  = new;
+		} else {
+			cur->next = new;
+			cur = cur->next;
+		}
+
+		cur->name = (char *)vmalloc(sizeof(char) * 16);
+		memset(cur->name, 0, sizeof(char) * 16);
+		memcpy(cur->name, p, 16);
+		p += 16;
+
+		cur->type = *(uint32_t *)p;
+		p += 4;
+
+		cur->len = *(uint32_t *)p;
+		p += 4;
+
+		if((cur->type )  >= 1000 || cur->len == 0) {//Temp Workaround
+			cur->len = 0;
+		}else{
+			cur->data = (uint32_t *)vmalloc(sizeof(uint8_t) * cur->len * 8);
+			memset(cur->data, 0, sizeof(uint8_t) * cur->len * 8);
+			memcpy(cur->data, p, cur->len * 8);
+			p += cur->len * 8;
+		}
+	}
+
+	vfree(rawdata);
+	aicbt_patch_table_load(usbdev, head);
+	printk("fw_patch_table download complete\n\n");
+
+	return ret;
+err:
+	//aicbt_patch_table_free(&head);
+
+	if (rawdata){
+		vfree(rawdata);
+	}
+	return ret;
+}
+
+
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth.h b/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth.h
index d6fe5eacfe70..5451358d967b 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth.h
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth.h
@@ -1,22 +1,36 @@
-#ifndef _AICBLUETOOTH_H
-#define _AICBLUETOOTH_H
-
-int aic_bt_platform_init(struct aic_usb_dev *sdiodev);
-
-void aic_bt_platform_deinit(struct aic_usb_dev *sdiodev);
-
-int rwnx_plat_bin_fw_upload_android(struct aic_usb_dev *sdiodev, u32 fw_addr,
-                               char *filename);
-
-int rwnx_plat_m2d_flash_ota_android(struct aic_usb_dev *usbdev, char *filename);
-
-int rwnx_plat_m2d_flash_ota_check(struct aic_usb_dev *usbdev, char *filename);
-
-int rwnx_plat_bin_fw_patch_table_upload_android(struct aic_usb_dev *usbdev, char *filename);
-
-int rwnx_plat_userconfig_upload_android(struct aic_usb_dev *usbdev, char *filename);
-
-uint8_t rwnx_atoi(char *value);
-uint32_t rwnx_atoli(char *value);
-
-#endif
+#ifndef _AICBLUETOOTH_H
+#define _AICBLUETOOTH_H
+
+struct aicbt_patch_table {
+	char     *name;
+	uint32_t type;
+	uint32_t *data;
+	uint32_t len;
+	struct aicbt_patch_table *next;
+};
+
+
+int aic_bt_platform_init(struct aic_usb_dev *sdiodev);
+
+void aic_bt_platform_deinit(struct aic_usb_dev *sdiodev);
+
+int rwnx_plat_bin_fw_upload_android(struct aic_usb_dev *sdiodev, u32 fw_addr,
+                               char *filename);
+
+int rwnx_plat_m2d_flash_ota_android(struct aic_usb_dev *usbdev, char *filename);
+
+int rwnx_plat_m2d_flash_ota_check(struct aic_usb_dev *usbdev, char *filename);
+
+int rwnx_plat_bin_fw_patch_table_upload_android(struct aic_usb_dev *usbdev, char *filename);
+
+int rwnx_plat_userconfig_upload_android(struct aic_usb_dev *usbdev, char *filename);
+int rwnx_plat_flash_bin_upload_android(struct aic_usb_dev *usbdev, u32 fw_addr, char *filename);
+
+int8_t rwnx_atoi(char *value);
+uint32_t rwnx_atoli(char *value);
+int aicbt_patch_table_free(struct aicbt_patch_table *head);
+struct aicbt_patch_table *aicbt_patch_table_alloc(struct aic_usb_dev *usbdev, const char *filename);
+int aicbt_patch_info_unpack(struct aicbt_patch_info_t *patch_info, struct aicbt_patch_table *head_t);
+int aicbt_patch_table_load(struct aic_usb_dev *usbdev, struct aicbt_patch_table *_head);
+
+#endif
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth_cmds.c b/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth_cmds.c
index 67078a447c44..229b5ceab712 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth_cmds.c
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth_cmds.c
@@ -12,10 +12,7 @@
  */
 
 #include <linux/list.h>
-#if 0
-#include <linux/stddef.h>
-#endif
-#include <linux/version.h>
+//#include <stddef.h>
 #include "aicbluetooth_cmds.h"
 #include "aic_txrxif.h"
 #include "aicwf_usb.h"
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth_cmds.h b/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth_cmds.h
index 585f40fc0969..352258b6a1eb 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth_cmds.h
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aicbluetooth_cmds.h
@@ -57,6 +57,27 @@ struct lmac_msg
     u32        param[];   ///< Parameter embedded struct. Must be word-aligned.
 };
 
+struct aicbt_patch_info_t {
+    uint32_t info_len;
+    uint32_t adid_addrinf;
+    uint32_t addr_adid;
+    uint32_t patch_addrinf;
+    uint32_t addr_patch;
+    uint32_t reset_addr;
+    uint32_t reset_val;
+    uint32_t adid_flag_addr;
+    uint32_t adid_flag;
+};
+
+
+#define AICBT_PT_TAG          "AICBT_PT_TAG"
+#define AICBT_PT_INF          0x0
+#define AICBT_PT_TRAP         0x01
+#define AICBT_PT_B4           0x02
+#define AICBT_PT_BTMODE       0x03
+#define AICBT_PT_PWRON        0x04
+#define AICBT_PT_AF           0x05
+
 #define rwnx_cmd_e2amsg ipc_e2a_msg
 #define rwnx_cmd_a2emsg lmac_msg
 #define RWNX_CMD_A2EMSG_LEN(m) (sizeof(struct lmac_msg) + m->param_len)
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aicwf_rx_prealloc.c b/drivers/net/wireless/aic8800/aic_load_fw/aicwf_rx_prealloc.c
index 886d34a8023d..d29edfd4166b 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aicwf_rx_prealloc.c
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aicwf_rx_prealloc.c
@@ -7,11 +7,15 @@
 #include "aicwf_debug.h"
 
 #ifdef CONFIG_PREALLOC_RX_SKB
+
 struct aicwf_rx_buff_list aic_rx_buff_list;
 
 int aic_rxbuff_num_max = 1000;
-
-int aic_rxbuff_size = (4 * 512);
+#ifdef CONFIG_PLATFORM_HI
+int aic_rxbuff_size = (4 * 512) * 1;
+#else
+int aic_rxbuff_size = (4 * 512) * 10;
+#endif
 
 int rx_buff_list_ava = 0;
 
@@ -32,6 +36,8 @@ struct rx_buff *aicwf_prealloc_rxbuff_alloc(spinlock_t *lock)
     if(rx_buff_list_ava < 10){
         AICWFDBG(LOGERROR, "%s WARNING rxbuff is running out %d\r\n", __func__,
             rx_buff_list_ava);
+        //msleep(10);
+        mdelay(10);
     }
 
     if (list_empty(&aic_rx_buff_list.rxbuff_list)) {
@@ -66,7 +72,7 @@ void aicwf_prealloc_rxbuff_free(struct rx_buff *rxbuff, spinlock_t *lock)
     spin_unlock_irqrestore(lock, flags);
 }
 
-int aicwf_prealloc_init()
+int aicwf_prealloc_init(void)
 {
     struct rx_buff *rxbuff;
     int i = 0;
@@ -97,7 +103,7 @@ int aicwf_prealloc_init()
     return 0;
 }
 
-void aicwf_prealloc_exit()
+void aicwf_prealloc_exit(void)
 {
     struct rx_buff *rxbuff;
     struct rx_buff *pos;
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aicwf_txq_prealloc.c b/drivers/net/wireless/aic8800/aic_load_fw/aicwf_txq_prealloc.c
index 585d48c11c20..cca065935f98 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aicwf_txq_prealloc.c
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aicwf_txq_prealloc.c
@@ -8,7 +8,7 @@ struct prealloc_txq{
 };
 
 struct prealloc_txq prealloc_txq;
-#define MAX_TXQ_SIZE 30 * 1024
+#define MAX_TXQ_SIZE 100 * 1024
 
 void *aicwf_prealloc_txq_alloc(size_t size)
 {
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aicwf_usb.c b/drivers/net/wireless/aic8800/aic_load_fw/aicwf_usb.c
index 52eaa7abcb6a..0723901cd3f0 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aicwf_usb.c
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aicwf_usb.c
@@ -25,6 +25,7 @@
 #include "aicbluetooth.h"
 #include "aicwf_debug.h"
 #include "aic_compat_8800d80.h"
+#include "aic_compat_8800d80x2.h"
 
 #define JUMP_TABLE_BASE   0x161928
 #define JUMP_TABLE_OFFSET(i) ((u32)(JUMP_TABLE_BASE+(i)*4))
@@ -33,8 +34,11 @@ extern int testmode;
 extern unsigned char paringid[100];
 extern int ble_scan_wakeup_reboot_time;
 extern uint32_t ad_data_filter_mask;
+extern uint32_t gpio_num;//default select gpiob2 for fw_wakeup_host
+extern uint32_t gpio_dft_lvl;//0:defalut pull down,  1:default pull up
 u8 chip_id = 0;
 u8 chip_sub_id = 0;
+u8 chip_mcu_id = 0;
 int fw_loaded = 0;
 
 void aicwf_usb_tx_flowctrl(struct aic_usb_dev *usb_dev, bool state)
@@ -665,6 +669,7 @@ static void aicwf_usb_deinit(struct aic_usb_dev *usbdev)
     cancel_work_sync(&usbdev->rx_urb_work);
     aicwf_usb_free_urb(&usbdev->rx_free_list, &usbdev->rx_free_lock);
     aicwf_usb_free_urb(&usbdev->tx_free_list, &usbdev->tx_free_lock);
+	aicwf_usb_free_urb(&usbdev->tx_post_list, &usbdev->tx_post_lock);
     usb_free_urb(usbdev->msg_out_urb);
 }
 
@@ -835,12 +840,11 @@ static int aicwf_parse_usb(struct aic_usb_dev *usb_dev, struct usb_interface *in
 #endif
 #endif
 
-
-    if (usb->speed == USB_SPEED_HIGH) {
-        printk("Aic high speed USB device detected\n");
-    } else {
-        printk("Aic full speed USB device detected\n");
-    }
+    printk("Aic %s speed USB device detected\n", 
+            (usb->speed == USB_SPEED_SUPER) ? "super" :
+            (usb->speed == USB_SPEED_HIGH)  ? "high"  :
+            (usb->speed == USB_SPEED_FULL)  ? "full"  :
+            (usb->speed == USB_SPEED_LOW)   ? "low"   : "NG");
     exit:
     return ret;
 }
@@ -976,6 +980,14 @@ u32 patch_tbl[][2] ={
 #if !defined(CONFIG_LINK_DET_5G)
 {0x0104, 0x00000000}, //link_det_5g
 #endif
+#ifdef CONFIG_USB_SUSPEND_REBOOT_TIME
+{0x0110, 0x03e80001}//reboot time when usb suspend,0001 enables reboot on suspend, default 0x3e8 = 1000ms reboot
+#else
+#ifdef CONFIG_SUPPORT_USB_SUSP
+//USB SUSP keep working 0x0100:enable 0x0000:disable
+{0x0110, 0x00000100}
+#endif
+#endif
 };
 
 
@@ -1078,7 +1090,7 @@ static int system_config_8800(struct aic_usb_dev *usb_dev){
         printk("%x rd fail: %d\n", mem_addr, ret);
         return ret;
     }
-    chip_id = (u8)(rd_mem_addr_cfm.memdata >> 16);
+    chip_id =(u8)(rd_mem_addr_cfm.memdata >> 16);
     //printk("%x=%x\n", rd_mem_addr_cfm.memaddr, rd_mem_addr_cfm.memdata);
     ret = rwnx_send_dbg_mem_read_req(usb_dev, 0x00000004, &rd_mem_addr_cfm);
     if (ret) {
@@ -1127,6 +1139,8 @@ static int system_config(struct aic_usb_dev *usb_dev)
         return system_config_8800(usb_dev);
     }else if(usb_dev->chipid == PRODUCT_ID_AIC8800D80){
         return system_config_8800d80(usb_dev);
+    }else if(usb_dev->chipid == PRODUCT_ID_AIC8800D80X2){
+        return system_config_8800d80x2(usb_dev);
     }else{
         return -1;
     }
@@ -1317,20 +1331,32 @@ static int aicloadfw_chipmatch(struct aic_usb_dev *usb_dev, u16 vid, u16 pid){
 
     if(pid == USB_DEVICE_ID_AIC){
         usb_dev->chipid = PRODUCT_ID_AIC8800;
-		AICWFDBG(LOGINFO, "%s USE AIC8800\r\n", __func__);
-		return 0;
-	}else if(pid == USB_DEVICE_ID_AIC_8801){
-		usb_dev->chipid = PRODUCT_ID_AIC8801;
-		AICWFDBG(LOGINFO, "%s USE AIC8801\r\n", __func__);
-		return 0;
-	}else if(pid == USB_DEVICE_ID_AIC_8800D80){
-		usb_dev->chipid = PRODUCT_ID_AIC8800D80;
-		AICWFDBG(LOGINFO, "%s USE AIC8800D80\r\n", __func__);
-		return 0;
-	}else if(pid == USB_DEVICE_ID_AIC_8800D81){
+	AICWFDBG(LOGINFO, "%s USE AIC8800\r\n", __func__);
+	return 0;
+    }else if(pid == USB_DEVICE_ID_AIC_8801){
+	usb_dev->chipid = PRODUCT_ID_AIC8801;
+	AICWFDBG(LOGINFO, "%s USE AIC8801\r\n", __func__);
+	return 0;
+    }else if(pid == USB_DEVICE_ID_AIC_8800D80){
+	usb_dev->chipid = PRODUCT_ID_AIC8800D80;
+	AICWFDBG(LOGINFO, "%s USE AIC8800D80\r\n", __func__);
+	return 0;
+    }else if(pid == USB_DEVICE_ID_AIC_8800D81){
         usb_dev->chipid = PRODUCT_ID_AIC8800D81;
-		AICWFDBG(LOGINFO, "%s USE AIC8800D81\r\n", __func__);
+	AICWFDBG(LOGINFO, "%s USE AIC8800D81\r\n", __func__);
         return 0;
+    }else if(pid == USB_DEVICE_ID_AIC_8800D40){
+        usb_dev->chipid = PRODUCT_ID_AIC8800D80;
+        AICWFDBG(LOGINFO, "%s USE AIC8800D40\r\n", __func__);
+        return 0;
+    }else if(pid == USB_DEVICE_ID_AIC_8800D41){
+	usb_dev->chipid = PRODUCT_ID_AIC8800D81;
+	AICWFDBG(LOGINFO, "%s USE AIC8800D41\r\n", __func__);
+	return 0;
+    }else if(pid == USB_DEVICE_ID_AIC_8800D80X2 && vid == USB_VENDOR_ID_AIC_V2){
+		usb_dev->chipid = PRODUCT_ID_AIC8800D80X2;
+		AICWFDBG(LOGINFO, "%s USE AIC8800D80X2\r\n", __func__);
+		return 0;
     }else{
         return -1;
     }
@@ -1408,10 +1434,9 @@ int aicfw_download_fw_8800(struct aic_usb_dev *usb_dev){
             return -1;
 
         } else if(testmode == FW_BLE_SCAN_AD_FILTER_MODE){
-        
 /*
             data and ad_data_filter_mask instructions for use
-            ex. 
+            ex.
             data[18] = {0x46,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x30,0xff,0xff,0xff,0x43,0x52,0x45,0x4c,0x42};
             mask = 1100 0000 0111 1111 1100 0000 0000 0000 = 0xc07fc000
 
@@ -1421,27 +1446,88 @@ int aicfw_download_fw_8800(struct aic_usb_dev *usb_dev){
             data & mask = "0x46 0x00" 0x00 0x00 0x00 0x00 0x00 0x00 0x00 "0x30 0xff 0xff 0x43 0x52 0x45 0x4c 0x42"
             using data & mask value condition to wakeup host_wake_bt gpio
 */
-            const uint8_t data[18] = {0x46,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x30,0xff,0xff,0xff,0x43,0x52,0x45,0x4c,0x42};
-            struct ad_data_filter* ad_data = (struct ad_data_filter*)kmalloc(sizeof(struct ad_data_filter), GFP_KERNEL);
-            uint32_t *write_blocks = (uint32_t *)ad_data;
+            struct ble_wakeup_param_t* wakeup_param = (struct ble_wakeup_param_t*)kmalloc(sizeof(struct ble_wakeup_param_t), GFP_KERNEL);
+            uint32_t *write_blocks = (uint32_t *)wakeup_param;
+
+            printk("%s ble scan wakeup \r\n", __func__);
 
-            memset(ad_data, 0, sizeof(struct ad_data_filter));
+            memset(wakeup_param, 0, sizeof(struct ble_wakeup_param_t));
             rwnx_plat_bin_fw_upload_android(usb_dev, RAM_FW_BLE_SCAN_WAKEUP_ADDR, FW_BLE_SCAN_AD_FILTER_NAME);
-            rwnx_send_dbg_mem_write_req(usb_dev, 0x15FF00, 0x53454C42);//magic_num
-            rwnx_send_dbg_mem_write_req(usb_dev, 0x15FF04, ble_scan_wakeup_reboot_time);//reboot time
-            ad_data->ad_len = 0x13;
-            ad_data->ad_type = 0xff;
-            memcpy(ad_data->ad_data, data,ad_data->ad_len-1);// 1100 0000 0111 1111 1100 0000 0000 0000 //0xc07fc000
-            ad_data_filter_mask = 0xc07fc000;
-            rwnx_send_dbg_mem_write_req(usb_dev, 0x15FF08, ad_data_filter_mask);//reboot time
-            for(i = 0; i < 9; i++){
+            wakeup_param->magic_num = 0x53454C42;//magic_num
+            wakeup_param->delay_scan_to = 1000;//delay start scan time(ms)
+            wakeup_param->reboot_to = ble_scan_wakeup_reboot_time;//reboot time
+            /******************************************************************/
+            ///gpio_trigger_idx : 0    if wakeup_param->gpio_dft_lvl[0]=0xfe,this idx will be invalid.
+            wakeup_param->gpio_num[0] = gpio_num;////default select gpiob2 for fw_wakeup_host
+            wakeup_param->gpio_dft_lvl[0] = gpio_dft_lvl;////0:defalut pull down,  1:default pull up
+            ///gpio_trigger_idx : 1    if wakeup_param->gpio_dft_lvl[1]=0xfe,this idx will be invalid.
+            wakeup_param->gpio_num[1] = 3;////default select gpiob2 for fw_wakeup_host
+            wakeup_param->gpio_dft_lvl[1] = 1;////0:defalut pull down,  1:default pull up
+            /********************************************************************/
+            //MAX_AD_FILTER_NUM=5 :num 0
+            {
+                const uint8_t data[11] = {0x59,0x4B,0x32,0x42,0x41,0x5F,0x54,0x45,0x53,0x54,0x33};
+                wakeup_param->ad_filter[0].ad_len = 12;
+                wakeup_param->ad_filter[0].ad_type = 0x09;
+                memcpy(wakeup_param->ad_filter[0].ad_data, data,wakeup_param->ad_filter[0].ad_len-1);// 1111 1111 1110 0000 0000 0000 0000 0000 //0xffe00000
+                wakeup_param->ad_filter[0].ad_data_mask = 0xffe00000;
+                wakeup_param->ad_filter[0].ad_role = ROLE_COMBO|(COMBO_0<<4);
+                wakeup_param->ad_filter[0].gpio_trigger_idx = TG_IDX_0;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+            }
+            /********************************************************************/
+            //MAX_AD_FILTER_NUM=5 :num 1
+            {
+                const uint8_t data[2] = {0x12,0x18};
+                wakeup_param->ad_filter[1].ad_len = 3;
+                wakeup_param->ad_filter[1].ad_type = 0x3;
+                memcpy(wakeup_param->ad_filter[1].ad_data, data,wakeup_param->ad_filter[1].ad_len-1);// 1100 0000 0000 0000 0000 0000 0000 0000 //0xc0000000
+                wakeup_param->ad_filter[1].ad_data_mask = 0xc0000000;
+                wakeup_param->ad_filter[1].ad_role = ROLE_COMBO|(COMBO_0<<4);
+                wakeup_param->ad_filter[1].gpio_trigger_idx = TG_IDX_0;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+            }
+            /********************************************************************/
+            //MAX_AD_FILTER_NUM=5 :num 2
+            {
+                //const uint8_t data[11] = {0x59,0x4B,0x32,0x42,0x41,0x5F,0x54,0x45,0x53,0x54,0x33};
+                wakeup_param->ad_filter[2].ad_len = 0;
+                wakeup_param->ad_filter[2].ad_type = 0;
+                //memcpy(wakeup_param->ad_filter[2].ad_data, data,wakeup_param->ad_filter[2].ad_len-1);// 1100 0000 0111 1111 1100 0000 0000 0000 //0xc07fc000
+                wakeup_param->ad_filter[2].ad_data_mask = 0;
+                wakeup_param->ad_filter[2].ad_role = ROLE_ONLY;
+                wakeup_param->ad_filter[2].gpio_trigger_idx = TG_IDX_0;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+            }
+            /********************************************************************/
+            //MAX_AD_FILTER_NUM=5 :num 3
+            {
+                //const uint8_t data[11] = {0x59,0x4B,0x32,0x42,0x41,0x5F,0x54,0x45,0x53,0x54,0x33};
+                wakeup_param->ad_filter[3].ad_len = 0;
+                wakeup_param->ad_filter[3].ad_type = 0;
+                //memcpy(wakeup_param->ad_filter[2].ad_data, data,wakeup_param->ad_filter[2].ad_len-1);// 1100 0000 0111 1111 1100 0000 0000 0000 //0xc07fc000
+                wakeup_param->ad_filter[3].ad_data_mask = 0;
+                wakeup_param->ad_filter[3].ad_role = ROLE_COMBO|(COMBO_1<<4);
+                wakeup_param->ad_filter[3].gpio_trigger_idx = TG_IDX_0;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+            }
+            /********************************************************************/
+            //MAX_AD_FILTER_NUM=5 :num 4
+            {
+                //const uint8_t data[11] = {0x59,0x4B,0x32,0x42,0x41,0x5F,0x54,0x45,0x53,0x54,0x33};
+                wakeup_param->ad_filter[4].ad_len = 0;
+                wakeup_param->ad_filter[4].ad_type = 0x09;
+                //memcpy(wakeup_param->ad_filter[4].ad_data, data,wakeup_param->ad_filter[4].ad_len-1);// 1111 1111 1110 0000 0000 0000 0000 0000 //0xffe00000
+                wakeup_param->ad_filter[4].ad_data_mask = 0xffe00000;
+                wakeup_param->ad_filter[4].ad_role = ROLE_COMBO|(COMBO_1<<4);
+                wakeup_param->ad_filter[4].gpio_trigger_idx = TG_IDX_0|TG_IDX_1;//0: match for wakeup_param->gpio_num[0]       1: match for wakeup_param->gpio_num[1]
+            }
+
+            for(i = 0; i < (sizeof(struct ble_wakeup_param_t)/4 +1); i++){
                 printk("write_blocks[%d]:0x%08X \r\n", i, write_blocks[i]);
-                rwnx_send_dbg_mem_write_req(usb_dev, 0x15FF0c + (4 * i), write_blocks[i]);
+                rwnx_send_dbg_mem_write_req(usb_dev, 0x15FF00 + (4 * i), write_blocks[i]);
             }
             rwnx_send_dbg_start_app_req(usb_dev, RAM_FW_BLE_SCAN_WAKEUP_ADDR, HOST_START_APP_AUTO);
-            kfree(ad_data);
+            kfree(wakeup_param);
+
             return -1;
-        } else {
+        }else {
             if (rwnx_plat_bin_fw_upload_android(usb_dev, RAM_FW_ADDR, FW_BASE_NAME)) {
                 return -1;;
             }
@@ -1506,6 +1592,8 @@ int aicfw_download_fw(struct aic_usb_dev *usb_dev)
         return aicfw_download_fw_8800(usb_dev);
     }else if(usb_dev->chipid == PRODUCT_ID_AIC8800D80){
         return aicfw_download_fw_8800d80(usb_dev);
+    }else if(usb_dev->chipid == PRODUCT_ID_AIC8800D80X2){
+        return aicfw_download_fw_8800d80x2(usb_dev);
     }else{
         return -1;
     }
@@ -1531,7 +1619,8 @@ static int aicwf_usb_probe(struct usb_interface *intf, const struct usb_device_i
 
 	if(fw_loaded == 1 && 
         (id->idProduct == USB_DEVICE_ID_AIC_8801 || 
-        id->idProduct == USB_DEVICE_ID_AIC_8800D81)){
+        id->idProduct == USB_DEVICE_ID_AIC_8800D81 ||
+	id->idProduct == USB_DEVICE_ID_AIC_8800D41)){
 		return -1;
 	}
 
@@ -1598,8 +1687,8 @@ static int aicwf_usb_probe(struct usb_interface *intf, const struct usb_device_i
 
     aic_bt_platform_init(usb_dev);
 
-    if (usb->speed != USB_SPEED_HIGH) {
-        printk("Aic full speed USB device detected\n");
+    if ((usb->speed != USB_SPEED_HIGH) && (usb->speed != USB_SPEED_SUPER)) {
+        printk("Aic USB device detected speed = %d\n", usb->speed);
         system_reboot(usb_dev);
         goto out_free_bus;
     }
@@ -1625,7 +1714,8 @@ static int aicwf_usb_probe(struct usb_interface *intf, const struct usb_device_i
     return 0;
 
 out_free_bus:
-    aicwf_bus_deinit(dev);
+	aicwf_bus_deinit(dev);
+	aicwf_rx_deinit(usb_dev->rx_priv);
     kfree(bus_if);
 out_free_usb:
     aicwf_usb_deinit(usb_dev);
@@ -1686,6 +1776,9 @@ static struct usb_device_id aicwf_usb_id_table[] = {
     {USB_DEVICE(USB_VENDOR_ID_AIC, USB_DEVICE_ID_AIC_8801)},
     {USB_DEVICE(USB_VENDOR_ID_AIC, USB_DEVICE_ID_AIC_8800D80)},
     {USB_DEVICE(USB_VENDOR_ID_AIC, USB_DEVICE_ID_AIC_8800D81)},
+    {USB_DEVICE(USB_VENDOR_ID_AIC, USB_DEVICE_ID_AIC_8800D40)},
+    {USB_DEVICE(USB_VENDOR_ID_AIC, USB_DEVICE_ID_AIC_8800D41)},
+    {USB_DEVICE(USB_VENDOR_ID_AIC_V2, USB_DEVICE_ID_AIC_8800D80X2)},
     {}
 };
 
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/aicwf_usb.h b/drivers/net/wireless/aic8800/aic_load_fw/aicwf_usb.h
index e86d28468d5e..2880c53f3302 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/aicwf_usb.h
+++ b/drivers/net/wireless/aic8800/aic_load_fw/aicwf_usb.h
@@ -21,8 +21,9 @@
 
 /* USB Device ID */
 #define USB_VENDOR_ID_AIC               0xA69C
+#define USB_VENDOR_ID_AIC_V2            0x368B
 #define USB_DEVICE_ID_AIC               0x8800
-#define USB_DEVICE_ID_AIC_8801		    0x8801
+#define USB_DEVICE_ID_AIC_8801          0x8801
 
 #define CHIP_REV_U01        0x1
 #define CHIP_REV_U02        0x3
@@ -31,11 +32,12 @@
 
 enum AICWF_IC{
     PRODUCT_ID_AIC8800 =   0,
-	PRODUCT_ID_AIC8801,
-	PRODUCT_ID_AIC8800DC,
-	PRODUCT_ID_AIC8800DW,
-	PRODUCT_ID_AIC8800D80,
-	PRODUCT_ID_AIC8800D81,
+    PRODUCT_ID_AIC8801,
+    PRODUCT_ID_AIC8800DC,
+    PRODUCT_ID_AIC8800DW,
+    PRODUCT_ID_AIC8800D80,
+    PRODUCT_ID_AIC8800D81,
+    PRODUCT_ID_AIC8800D80X2,
 };
 
 
@@ -76,6 +78,8 @@ enum AICWF_IC{
 #define FW_USERCONFIG_NAME              "aic_userconfig.txt"
 #define FW_M2D_OTA_NAME                 "m2d_ota.bin"
 
+   /*8800 use 0x100000, 8800D80 use 0x160000*/
+#define RAM_FW_BLE_SCAN_WAKEUP_ADDR_8800D80		0x00160000
 #define RAM_FW_BLE_SCAN_WAKEUP_ADDR		0x00100000
 #define RAM_FW_ADDR                     0x00110000
 #define FW_RAM_ADID_BASE_ADDR           0x00161928
@@ -112,12 +116,46 @@ enum aicwf_usb_state {
     USB_SLEEP_ST
 };
 
-struct ad_data_filter {
+#define MAX_AD_FILTER_NUM        5// Max AD Filter num
+#define MAX_GPIO_TRIGGER_NUM     2// Max user config num of gpio
+#define MAX_ROLE_COMNO_IDX_NUM   2// Max num of ad role type combo,form( enum gpio_combo_idx) 
+
+#define AD_ROLE_FLAG         0x0f
+#define ROLE_COMBO_IDX_FLAG  0xf0
+
+enum ad_role_type {
+    ROLE_ONLY,// ROLE_ONLY will trigger wake up immediately.
+    ROLE_COMBO,//ROLE_COMBO will trigger When all the conditions (ad_role == ROLE_COMBO,and ad_filter is matching)are met.
+};
+
+enum gpio_combo_idx {
+    COMBO_0,
+    COMBO_1,
+};
+
+enum gpio_trigger_bit {
+    TG_IDX_0 = (1<<0),
+    TG_IDX_1 = (1<<1),
+};
+
+struct wakeup_ad_data_filter {
+    uint32_t ad_data_mask;
+    uint8_t gpio_trigger_idx;
+    uint8_t ad_role;//from enum ad_role_type 
     uint8_t ad_len;
     uint8_t ad_type;
     uint8_t ad_data[31];
 };
 
+struct ble_wakeup_param_t {
+    uint32_t magic_num;// "BLES" = 0x53454C42
+    uint32_t delay_scan_to;// timeout for start scan in ms
+    uint32_t reboot_to;// timeout for reboot in ms
+    uint32_t gpio_num[MAX_GPIO_TRIGGER_NUM];
+    uint32_t gpio_dft_lvl[MAX_GPIO_TRIGGER_NUM];
+    struct wakeup_ad_data_filter ad_filter[MAX_AD_FILTER_NUM];
+};
+
 struct aicwf_usb_buf {
     struct list_head list;
     struct aic_usb_dev *usbdev;
@@ -174,6 +212,7 @@ struct aic_usb_dev {
     u16 chipid;
     bool tbusy;
     bool app_cmp;
+    u32 fw_version_uint;
 };
 
 extern void aicwf_usb_exit(void);
diff --git a/drivers/net/wireless/aic8800/aic_load_fw/rwnx_version_gen.h b/drivers/net/wireless/aic8800/aic_load_fw/rwnx_version_gen.h
index 09010086a0d2..19877f2268f1 100644
--- a/drivers/net/wireless/aic8800/aic_load_fw/rwnx_version_gen.h
+++ b/drivers/net/wireless/aic8800/aic_load_fw/rwnx_version_gen.h
@@ -1,4 +1,4 @@
 #define RWNX_VERS_REV "1a4b0054d2M (master)"
 #define RWNX_VERS_MOD "6.4.3.0"
 #define RWNX_VERS_BANNER "rwnx v6.4.3.0 - 1a4b0054d2M (master)"
-#define RELEASE_DATE "2023_0707_1001"
+#define RELEASE_DATE "2024_0712_e2a932c1"
